# 通用权限系统：权限管理

## 一、权限管理

### 1、权限管理介绍

每个系统的权限功能都不尽相同，各有其自身的业务特点，对权限管理的设计也都各有特色。不过不管是怎样的权限设计，大致可归为三种：**页面权限(菜单级)、操作权限（按钮级）、数据权限**。当前系统只是讲解：菜单权限与按钮权限的控制。

#### 1.1、菜单权限

菜单权限就是对页面的控制，就是有这个权限的用户才能访问这个页面，没这个权限的用户就无法访问，它是以整个页面为维度，对权限的控制并没有那么细，所以是一种**粗颗粒权限**。

<img src=".\images\6.权限管理\image-20220606155704023.png" />

#### 1.2、按钮权限

按钮权限就是将页面的**操作**视为资源，比如删除操作，有些人可以操作有些人不能操作。对于后端来说，操作就是一个接口。于前端来说，操作往往是一个按钮，是一种**细颗粒权限**。

<img src=".\images\6.权限管理\image-20220606160034229.png" />

#### 1.3、权限管理设计思路

前面我们讲解了用户管理、角色管理及菜单管理，我们把菜单权限分配给角色，把角色分配给用户，那么用户就拥有了角色的所有权限（权限包含：菜单权限与按钮权限）。

接下来需要实现这两个接口：

1、用户登录

2、登录成功根据token获取用户相关信息（菜单权限及按钮权限数据等）

用户登录我们需要用到JWT，接下来讲解JWT。

### 2、JWT

#### 2.1、JWT介绍

JWT是JSON Web Token的缩写，即JSON Web令牌，是一种自包含令牌。 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准。

JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。

JWT最重要的作用就是对 token信息的防伪作用。

#### 2.2、JWT令牌的组成

一个JWT由三个部分组成：**JWT头、有效载荷、签名哈希**
最后由这三者组合进行base64url编码得到JWT

典型的，一个JWT看起来如下图：该对象为一个很长的字符串，字符之间通过"."分隔符分为三个子串。
https://jwt.io/

<img src=".\images\6.权限管理\3402e929-2225-4c64-8f2e-4471b63366d0.png" />

**JWT头**

JWT头部分是一个描述JWT元数据的JSON对象，通常如下所示。

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

在上面的代码中，alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256）；

typ属性表示令牌的类型，JWT令牌统一写为JWT。

最后，使用Base64 URL算法将上述JSON对象转换为字符串保存。



**有效载荷**

有效载荷部分，是JWT的主体内容部分，也是一个JSON对象，包含需要传递的数据。 JWT指定七个默认字段供选择。

```json
iss: jwt签发者
sub: 主题
aud: 接收jwt的一方
exp: jwt的过期时间，这个过期时间必须要大于签发时间
nbf: 定义在什么时间之前，该jwt都是不可用的.
iat: jwt的签发时间
jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。
```

除以上默认字段外，我们还可以自定义私有字段，如下例：

```json
{
  "name": "Helen",
  "role": "editor",
  "avatar": "helen.jpg"
}
```

请注意，默认情况下JWT是未加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露。

JSON对象也使用Base64 URL算法转换为字符串保存。



**签名哈希**

签名哈希部分是对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。

首先，需要指定一个密码（secret）。该密码仅仅为保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法（默认情况下为HMAC SHA256）根据以下公式生成签名。

```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(claims), secret)    ==>   签名hash
```

在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用"."分隔，就构成整个JWT对象。



**Base64URL算法**

如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。

作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是"+"，"/"和"="，由于在URL中有特殊含义，因此Base64URL中对他们做了替换："="去掉，"+"用"-"替换，"/"用"_"替换，这就是Base64URL算法。

#### 2.3、项目集成JWT

操作模块：common-util

##### 2.3.1、 引入依赖（前面已经引入）

```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
</dependency>
```

##### 2.3.2、 添加JWT帮助类

```java
package com.atguigu.common.helper;

import io.jsonwebtoken.*;
import org.springframework.util.StringUtils;

import java.util.Date;

/**
 * 生成JSON Web令牌的工具类
 */
public class JwtHelper {

    private static long tokenExpiration = 365 * 24 * 60 * 60 * 1000;
    private static String tokenSignKey = "123456";

    public static String createToken(Long userId, String username) {
        String token = Jwts.builder()
                .setSubject("AUTH-USER")
                .setExpiration(new Date(System.currentTimeMillis() + tokenExpiration))
                .claim("userId", userId)
                .claim("username", username)
                .signWith(SignatureAlgorithm.HS512, tokenSignKey)
                .compressWith(CompressionCodecs.GZIP)
                .compact();
        return token;
    }

    public static Long getUserId(String token) {
        try {
            if (StringUtils.isEmpty(token)) return null;

            Jws<Claims> claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token);
            Claims claims = claimsJws.getBody();
            Integer userId = (Integer) claims.get("userId");
            return userId.longValue();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static String getUsername(String token) {
        try {
            if (StringUtils.isEmpty(token)) return "";

            Jws<Claims> claimsJws = Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token);
            Claims claims = claimsJws.getBody();
            return (String) claims.get("username");
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static void removeToken(String token) {
        //jwttoken无需删除，客户端扔掉即可。
    }

    public static void main(String[] args) {
        String token = JwtHelper.createToken(1L, "admin");//"eyJhbGciOiJIUzUxMiIsInppcCI6IkdaSVAifQ.H4sIAAAAAAAAAKtWKi5NUrJSCjAK0A0Ndg1S0lFKrShQsjI0MzY2sDQ3MTbQUSotTi3yTFGyMjKEsP0Sc1OBWp6unfB0f7NSLQDxzD8_QwAAAA.2eCJdsJXOYaWFmPTJc8gl1YHTRl9DAeEJprKZn4IgJP9Fzo5fLddOQn1Iv2C25qMpwHQkPIGukTQtskWsNrnhQ";//JwtHelper.createToken(7L, "admin");
        System.out.println(token);
        System.out.println(JwtHelper.getUserId(token));
        System.out.println(JwtHelper.getUsername(token));
    }
}
```

### 3、用户登录

修改IndexController类登录方法

```java
@Autowired
private SysUserService sysUserService;

@ApiOperation("登录")
@PostMapping("login")
public Result login(@RequestBody LoginVO vo) {
    LambdaQueryWrapper<SysUser> wrapper = new QueryWrapper<SysUser>().lambda()
        .eq(SysUser::getUsername, vo.getUsername());
    SysUser sysUser = sysUserService.getOne(wrapper);
    if (sysUser == null) {
        throw new CustomException(ResultCodeEnum.USER_NOT_EXIST.getCode(), ResultCodeEnum.USER_NOT_EXIST.getMessage());
    }
    if (sysUser.getStatus() != 1) {
        throw new CustomException(ResultCodeEnum.USE_LOCKED.getCode(), ResultCodeEnum.USE_LOCKED.getMessage());
    }
    if (!SecureUtil.sha1(vo.getPassword()).equals(sysUser.getPassword())) {
        throw new CustomException(ResultCodeEnum.USERNAME_OR_PASSWORD_WRONG.getCode(), ResultCodeEnum.USERNAME_OR_PASSWORD_WRONG.getMessage());
    }
    Map<String, Object> map = new HashMap<>();
    map.put("token", JwtHelper.createToken(sysUser.getId(), sysUser.getUsername()));
    return Result.ok(map);
}
```

### 4、获取用户信息

接口数据：

```java
Map<String, Object> map = new HashMap<>();
map.put("roles","[admin]");
map.put("username","admin");
map.put("avatar","https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg");
map.put("buttons", new ArrayList<>());
map.put("routers", new ArrayList<>());
```

说明：主要是获取当前登录用户的菜单权限及按钮权限数据

#### 4.1、获取用户菜单权限

说明：获取菜单权限数据，我们要将菜单数据构建成路由数据结构

##### 4.1.1、定义接口

SysMenuService类

```java
/**
* 获取系统用户信息，包含权限相关信息
* @param username
* @return
*/
SysUserAuthVO getSysUserAuthInfo(String username);
```

##### 4.1.2、接口实现

```java
@Override
public SysUserAuthVO getSysUserAuthInfo(String username) {
    SysUserAuthVO result = new SysUserAuthVO();
    // 根据用户名查询用户信息
    LambdaQueryWrapper<SysUser> sysUserWrapper = new QueryWrapper<SysUser>().lambda()
        .eq(SysUser::getStatus, 1) // 可用状态
        .eq(SysUser::getUsername, username);
    SysUser sysUser = getBaseMapper().selectOne(sysUserWrapper);
    result.setUsername(username);
    result.setAvatar(sysUser.getHeadUrl());
    Long userId = sysUser.getId();
    // 1.角色列表
    List<String> roleNames = getBaseMapper().getRoleNames(userId);
    result.setRoles(roleNames);
    // 2.菜单（路由）信息
    List<RouterVO> routers = getRouters(userId);
    result.setRouters(routers);
    // 3.按钮信息
    List<String> buttons = getButtons(userId);
    result.setButtons(buttons);
    return result;
}

/**
* 获取用户具备的权限信息（只包含按钮级别）
*
* @param userId
* @return
*/
private List<String> getButtons(Long userId) {
    List<SysMenu> sysMenus;
    // 如果用户ID为1，为超级管理员，则应该具备所有权限
    if (userId == 1) {
        LambdaQueryWrapper<SysMenu> sysMenuWrapper = new QueryWrapper<SysMenu>().lambda()
            .eq(SysMenu::getStatus, 1)  // 可用状态
            .eq(SysMenu::getType, 2)  // 类型为2
            .orderByAsc(SysMenu::getSortValue);
        sysMenus = sysMenuMapper.selectList(sysMenuWrapper);
    } else {
        // 用户不是超级管理员，则查询他的相关权限
        List<SysMenu> buttons = getBaseMapper().getAuthorities(userId);
        // 过滤掉那些隐藏菜单，按钮级别的权限component为null
        sysMenus = buttons.stream()
            .filter(it -> it.getType() == 2 && !StringUtils.hasText(it.getComponent()))
            .collect(Collectors.toList());

    }
    // SysMenu集合转为String集合
    return sysMenus.stream()
        .map(SysMenu::getPerms)
        .collect(Collectors.toList());
}

/**
* 获取路由信息
*
* @param userId
* @return
*/
private List<RouterVO> getRouters(Long userId) {
    List<SysMenu> sysMenus;
    // 如果用户ID为1，为超级管理员，则应该具备所有权限
    if (userId == 1) {
        LambdaQueryWrapper<SysMenu> sysMenuWrapper = new QueryWrapper<SysMenu>().lambda()
            .eq(SysMenu::getStatus, 1)
            .orderByAsc(SysMenu::getSortValue);
        sysMenus = sysMenuMapper.selectList(sysMenuWrapper);
    } else {
        // 其他用户，则需要另外查询
        sysMenus = getBaseMapper().getAuthorities(userId)
            .stream().distinct().collect(Collectors.toList()); //去重处理
    }
    // 转成树形结构
    sysMenus = MenuHelper.buildTree(sysMenus);
    // 构建出路由列表
    return RouterHelper.buildRouters(sysMenus);
}
```

##### 4.1.3、添加Router帮助类

```java
public class RouterHelper {

    /**
     * 根据菜单构建路由
     *
     * @param menus
     * @return
     */
    public static List<RouterVO> buildRouters(List<SysMenu> menus) {
        List<RouterVO> routers = new LinkedList<>();
        for (SysMenu menu : menus) {
            RouterVO router = createRouter(menu, false); // 先创建一个路由出来
            List<SysMenu> children = menu.getChildren();
            switch (menu.getType()){
                case 0:
                    routers.add(router);
                    // 如果还有子菜单，则进入递归
                    if (!CollectionUtils.isEmpty(children)) {
                        router.setAlwaysShow(true); // 展开
                        router.setChildren(buildRouters(children));
                    }
                    break;
                case 1:
                    routers.add(router);
                    // type为1，下面会包含按钮或者需要隐藏显示的子菜单（路由）
                    // 需要隐藏的子菜单，如“系统管理”下面的“角色授权”
                    if (!CollectionUtils.isEmpty(children)){
                        children.forEach(it -> {
                            // 通过component是否有值来找到这些需要隐藏的路由
                            if (StringUtils.hasText(it.getComponent())){
                                routers.add(createRouter(it, true));
                            }
                        });
                    }
                    break;
            }
        }
        return routers;
    }

    /**
     * 根据SysMenu对象构建出来
     * @param menu
     * @param hidden
     * @return
     */
    private static RouterVO createRouter(SysMenu menu, boolean hidden) {
        RouterVO router = new RouterVO();
        router.setHidden(hidden);
        router.setAlwaysShow(false);
        router.setPath(getRouterPath(menu));
        router.setComponent(menu.getComponent());
        router.setMeta(new MetaVO(menu.getName(), menu.getIcon()));
        return router;
    }

    /**
     * 获取路由地址
     *
     * @param menu 菜单信息
     * @return 路由地址
     */
    private static String getRouterPath(SysMenu menu) {
        // 当parentId为0，拼接上 "/"
        return menu.getParentId() == 0 ? "/" + menu.getPath() : menu.getPath();
    }

}
```

##### 4.1.4、添加mapper接口

SysUserMapper类

```java
/**
* 根据用户ID查询用户所具有的权限，包括（菜单（包含隐藏菜单）和按钮级别的所有权限）
* @param userId
* @return
*/
@Select("select m.* from sys_menu m " +
        "inner join sys_role_menu rm on m.id = rm.menu_id and m.deleted = 0 and rm.deleted = 0 and m.status = 1 " +
        "inner join sys_user_role ur on rm.role_id = ur.role_id and ur.deleted = 0 " +
        "where ur.user_id = #{userId}")
List<SysMenu> getAuthorities(Long userId);
```

##### 4.1.5、controller实现

IndexController类

```java
@ApiOperation("获取用户信息")
@ApiImplicitParam(name = "token", value = "登录返回的令牌" ,required = true, paramType = "header", dataType = "String")
@GetMapping("info")
public Result<SysUserAuthVO> info( HttpServletRequest request) {
    // 从token中解析出用户名
    String token = request.getHeader("token");
    String username = JwtHelper.getUsername(token);
    return Result.ok(sysUserService.getSysUserAuthInfo(username));
}
```

### 5、前端对接

参考前端对接文档：《前端权限对接文档》

可直接引入前端项目完整代码

### 6、总结

当前我们已经实现前端菜单及按钮的权限控制，服务器端还没加任何控制，那么服务器端怎么控制呢？其实很简单，就是要在页面按钮对应的controller方法上面加对应的权限控制，即在进入controller方法前判断当前用户是否有访问权限。

怎么实现呢？如果我们自己实现，那么肯定想到的就是Fillter加Aop就可以实现，有现成的开源技术框架吗？答案是肯定的，如：Spring Security、Shiro等一系列开源框架可供选择。

## 二、Spring Security介绍

### 1、Spring Security简介

Spring 是非常流行和成功的 Java 应用开发框架，Spring Security 正是 Spring 家族中的成员。Spring Security 基于 Spring 框架，提供了一套 Web 应用安全性的完整解决方案。

正如你可能知道的关于安全方面的两个核心功能是“**认证**”和“**授权**”，一般来说，Web 应用的安全性包括**用户认证（Authentication）和用户授权（Authorization）**两个部分，这两点也是 SpringSecurity 重要核心功能。

（1）用户认证指的是：验证某个用户是否为系统中的合法主体，也就是说用户能否访问该系统。用户认证一般要求用户提供用户名和密码，系统通过校验用户名和密码来完成认证过程。

**通俗点说就是系统认为用户是否能登录**

（2）用户授权指的是验证某个用户是否有权限执行某个操作。在一个系统中，不同用户所具有的权限是不同的。比如对一个文件来说，有的用户只能进行读取，而有的用户可以进行修改。一般来说，系统会为不同的用户分配不同的角色，而每个角色则对应一系列的权限。

**通俗点讲就是系统判断用户是否有权限去做某些事情。**

### 2、历史

“Spring Security 开始于 2003 年年底,““spring 的 acegi 安全系统”。 起因是 Spring开发者邮件列表中的一个问题,有人提问是否考虑提供一个基于 spring 的安全实现。

Spring Security 以“The Acegi Secutity System for Spring” 的名字始于 2013 年晚些时候。一个问题提交到 Spring 开发者的邮件列表，询问是否已经有考虑一个基于 Spring 的安全性社区实现。那时候 Spring 的社区相对较小（相对现在）。实际上 Spring 自己在2013 年只是一个存在于 ScourseForge 的项目，这个问题的回答是一个值得研究的领域，虽然目前时间的缺乏阻止了我们对它的探索。

考虑到这一点，一个简单的安全实现建成但是并没有发布。几周后，Spring 社区的其他成员询问了安全性，这次这个代码被发送给他们。其他几个请求也跟随而来。到 2014 年一月大约有 20 万人使用了这个代码。这些创业者的人提出一个 SourceForge 项目加入是为了，这是在 2004 三月正式成立。

在早些时候，这个项目没有任何自己的验证模块，身份验证过程依赖于容器管理的安全性和 Acegi 安全性。而不是专注于授权。开始的时候这很适合，但是越来越多的用户请求额外的容器支持。容器特定的认证领域接口的基本限制变得清晰。还有一个相关的问题增加新的容器的路径，这是最终用户的困惑和错误配置的常见问题。

Acegi 安全特定的认证服务介绍。大约一年后，Acegi 安全正式成为了 Spring 框架的子项目。1.0.0 最终版本是出版于 2006 -在超过两年半的大量生产的软件项目和数以百计的改进和积极利用社区的贡献。

Acegi 安全 2007 年底正式成为了 Spring 组合项目，更名为"Spring Security"。

### 3、同款产品对比

#### 3.1、Spring Security

Spring 技术栈的组成部分。

https://spring.io/projects/spring-security

通过提供完整可扩展的认证和授权支持保护你的应用程序。

**SpringSecurity 特点：**

⚫ 和 Spring 无缝整合。

⚫ 全面的权限控制。

⚫ 专门为 Web 开发而设计。

​	◼旧版本不能脱离 Web 环境使用。

​	◼新版本对整个框架进行了分层抽取，分成了核心模块和 Web 模块。单独引入核心模块就可以脱离 Web 环境。

⚫ 重量级。

#### 3.2、 Shiro

Apache 旗下的轻量级权限控制框架。

**特点：**

⚫ 轻量级。Shiro 主张的理念是把复杂的事情变简单。针对对性能有更高要求的互联网应用有更好表现。

⚫ 通用性。

​	◼好处：不局限于 Web 环境，可以脱离 Web 环境使用。

​	◼缺陷：在 Web 环境下一些特定的需求需要手动编写代码定制。

Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。

相对于 Shiro，在 SSM 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。

自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了自动化配置方案，可以使用更少的配置来使用 Spring Security。

因此，一般来说，常见的安全管理技术栈的组合是这样的：

• SSM + Shiro

• Spring Boot/Spring Cloud + Spring Security

**以上只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的**

## 三、Spring Security实现权限

要对Web资源进行保护，最好的办法莫过于Filter
要想对方法调用进行保护，最好的办法莫过于[AOP](https://so.csdn.net/so/search?q=AOP&spm=1001.2101.3001.7020)。

Spring Security进行认证和鉴权的时候,就是利用的一系列的Filter来进行拦截的。

<img src="https://img-blog.csdnimg.cn/20201231155747261.png" />

如图所示，一个请求想要访问到API就会从左到右经过蓝线框里的过滤器，其中**绿色部分是负责认证的过滤器，蓝色部分是负责异常处理，橙色部分则是负责授权**。进过一系列拦截最终访问到我们的API。

这里面我们只需要重点关注两个过滤器即可：`UsernamePasswordAuthenticationFilter`负责登录认证，`FilterSecurityInterceptor`负责权限授权。

说明：**Spring Security的核心逻辑全在这一套过滤器中，过滤器里会调用各种组件完成功能，掌握了这些过滤器和组件你就掌握了Spring Security**！这个框架的使用方式就是对这些过滤器和组件进行扩展。

### 1、Spring Security入门

我们在现有的项目基础上做集成，Spring Security权限控制部分也是公共模块，后续哪个service服务模块需要，直接引入即可。

后续我们的Spring Cloud微服务项目可能就基于该权限系统开发，因此我们要做好技术扩展。

#### 1.1、创建spring-security模块

在common模块下创建spring-security公共模块，创建方式如：service-util模块

#### 1.2、添加依赖

修改pom.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>com.atguigu</groupId>
        <artifactId>common</artifactId>
        <version>1.0</version>
    </parent>

    <version>1.0</version>
    <artifactId>spring-security</artifactId>
    <packaging>jar</packaging>

    <dependencies>
        <dependency>
            <groupId>com.atguigu</groupId>
            <artifactId>common-util</artifactId>
            <version>1.0</version>
        </dependency>
         <dependency>
            <groupId>com.atguigu</groupId>
            <artifactId>model</artifactId>
            <version>1.0</version>
        </dependency>
        <!-- Spring Security依赖 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
			<scope>provided </scope>
		</dependency>
    </dependencies>

</project>
```

说明：依赖包（spring-boot-starter-security）导入后，Spring Security就默认提供了许多功能将整个应用给保护了起来：

​	1、要求经过身份验证的用户才能与应用程序进行交互

​	2、创建好了默认登录表单

​	3、生成用户名为`user`的随机密码并打印在控制台上

​	4、`CSRF`攻击防护、`Session Fixation`攻击防护

​	5、等等等等......

#### 1.3、添加配置类

```java
package com.atguigu.system.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;


@Configuration
@EnableWebSecurity //@EnableWebSecurity是开启SpringSecurity的默认行为
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {


}
```

#### 1.4、service-system模块引入

在service-system引入权限模块，将依赖添加到pom.xml文件

```xml
<dependency>
    <groupId>com.atguigu</groupId>
    <artifactId>spring-security</artifactId>
    <version>1.0</version>
</dependency>
```

#### 1.5、启动项目测试

在浏览器访问：http://localhost:8800/admin/system/sysRole/findAll

自动跳转到了登录页面

<img src=".\images\6.权限管理\image-20220606095319741.png" />

默认的用户名：user

密码在项目启动的时候在控制台会打印，**注意每次启动的时候密码都会发生变化！**

<img src=".\images\6.权限管理\image-20220607103826495.png" />

输入用户名，密码，成功访问到controller方法并返回数据，说明Spring Security默认安全保护生效。

在实际开发中，这些默认的配置是不能满足我们需要的，我们需要扩展Spring Security组件，完成自定义配置，实现我们的项目需求。

### 2、用户认证

用户认证流程：

<img src=".\images\6.权限管理\image-20220620115942257.png" />

#### 2.1、用户认证核心组件

我们系统中会有许多用户，确认当前是哪个用户正在使用我们系统就是登录认证的最终目的。这里我们就提取出了一个核心概念：**当前登录用户/当前认证用户**。整个系统安全都是围绕当前登录用户展开的，这个不难理解，要是当前登录用户都不能确认了，那A下了一个订单，下到了B的账户上这不就乱套了。这一概念在Spring Security中的体现就是 **`Authentication`**，它存储了认证信息，代表当前登录用户。

我们在程序中如何获取并使用它呢？我们需要通过 **`SecurityContext`** 来获取`Authentication`，`SecurityContext`就是我们的上下文对象！这个上下文对象则是交由 **`SecurityContextHolder`** 进行管理，你可以在程序**任何地方**使用它：

```java
Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
```

`SecurityContextHolder`原理非常简单，就是使用`ThreadLocal`来保证一个线程中传递同一个对象！

**现在我们已经知道了Spring Security中三个核心组件：**

​	1、`Authentication`：存储了认证信息，代表当前登录用户

​	2、`SeucirtyContext`：上下文对象，用来获取`Authentication`

​	3、`SecurityContextHolder`：上下文管理对象，用来在程序任何地方获取`SecurityContext`

**`Authentication`中是什么信息呢：**

​	1、`Principal`：用户信息，没有认证时一般是用户名，认证后一般是用户对象

​	2、`Credentials`：用户凭证，一般是密码

​	3、`Authorities`：用户权限

#### 2.2、用户认证

Spring Security是怎么进行用户认证的呢？

**`AuthenticationManager`** 就是Spring Security用于执行身份验证的组件，只需要调用它的`authenticate`方法即可完成认证。Spring Security默认的认证方式就是在`UsernamePasswordAuthenticationFilter`这个过滤器中进行认证的，该过滤器负责认证逻辑。

Spring Security用户认证关键代码如下：

```java
// 生成一个包含账号密码的认证信息
Authentication authenticationToken = new UsernamePasswordAuthenticationToken(username, passwrod);
// AuthenticationManager校验这个认证信息，返回一个已认证的Authentication
Authentication authentication = authenticationManager.authenticate(authenticationToken);
// 将返回的Authentication存到上下文中
SecurityContextHolder.getContext().setAuthentication(authentication);
```

下面我们来分析一下。

##### 2.2.1、认证接口分析

`AuthenticationManager`的校验逻辑非常简单：

根据用户名先查询出用户对象(没有查到则抛出异常)将用户对象的密码和传递过来的密码进行校验，密码不匹配则抛出异常。

这个逻辑没啥好说的，再简单不过了。重点是这里每一个步骤Spring Security都提供了组件：

​	1、是谁执行 **根据用户名查询出用户对象** 逻辑的呢？用户对象数据可以存在内存中、文件中、数据库中，你得确定好怎么查才行。这一部分就是交由**`UserDetialsService`** 处理，该接口只有一个方法`loadUserByUsername(String username)`，通过用户名查询用户对象，默认实现是在内存中查询。

​	2、那查询出来的 **用户对象** 又是什么呢？每个系统中的用户对象数据都不尽相同，咱们需要确认我们的用户数据是啥样的才行。Spring Security中的用户数据则是由**`UserDetails`** 来体现，该接口中提供了账号、密码等通用属性。

​	3、**对密码进行校验**大家可能会觉得比较简单，`if、else`搞定，就没必要用什么组件了吧？但框架毕竟是框架考虑的比较周全，除了`if、else`外还解决了密码加密的问题，这个组件就是**`PasswordEncoder`**，负责密码加密与校验。

我们可以看下`AuthenticationManager`校验逻辑的大概源码：

```java
public Authentication authenticate(Authentication authentication) throws AuthenticationException {
...省略其他代码

    // 传递过来的用户名
    String username = authentication.getName();
    // 调用UserDetailService的方法，通过用户名查询出用户对象UserDetail（查询不出来UserDetailService则会抛出异常）
    UserDetails userDetails = this.getUserDetailsService().loadUserByUsername(username);
    String presentedPassword = authentication.getCredentials().toString();

    // 传递过来的密码
    String password = authentication.getCredentials().toString();
    // 使用密码解析器PasswordEncoder传递过来的密码是否和真实的用户密码匹配
    if (!passwordEncoder.matches(password, userDetails.getPassword())) {
        // 密码错误则抛出异常
        throw new BadCredentialsException("错误信息...");
    }

    // 注意哦，这里返回的已认证Authentication，是将整个UserDetails放进去充当Principal
    UsernamePasswordAuthenticationToken result = new UsernamePasswordAuthenticationToken(userDetails,
            authentication.getCredentials(), userDetails.getAuthorities());
    return result;

...省略其他代码
}
```

`UserDetialsService`、`UserDetails`、`PasswordEncoder`，这三个组件Spring Security都有默认实现，这一般是满足不了我们的实际需求的，所以这里我们自己来实现这些组件！

下面我们就在项目里面来实现用户认证。

##### 2.2.3、加密器PasswordEncoder

加密我们项目采取MD5加密

操作模块：spring-security模块

**自定义加密处理组件：Sha1PasswordEncoder**

```java
/**
 * 密码加密器
 */
@Component
public class Sha1PasswordEncoder implements PasswordEncoder {
    @Override
    public String encode(CharSequence rawPassword) {
        return SecureUtil.sha1(rawPassword.toString());
    }

    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        return encodedPassword.equals(SecureUtil.sha1(rawPassword.toString()));
    }
}
```

##### 2.2.4、用户对象UserDetails

该接口就是我们所说的用户对象，它提供了用户的一些通用属性，源码如下：

```java
public interface UserDetails extends Serializable {
	/**
     * 用户权限集合（这个权限对象现在不管它，到权限时我会讲解）
     */
    Collection<? extends GrantedAuthority> getAuthorities();
    /**
     * 用户密码
     */
    String getPassword();
    /**
     * 用户名
     */
    String getUsername();
    /**
     * 用户没过期返回true，反之则false
     */
    boolean isAccountNonExpired();
    /**
     * 用户没锁定返回true，反之则false
     */
    boolean isAccountNonLocked();
    /**
     * 用户凭据(通常为密码)没过期返回true，反之则false
     */
    boolean isCredentialsNonExpired();
    /**
     * 用户是启用状态返回true，反之则false
     */
    boolean isEnabled();
}
```

实际开发中我们的用户属性各种各样，这些默认属性可能是满足不了，所以我们一般会自己实现该接口，然后设置好我们实际的用户实体对象。实现此接口要重写很多方法比较麻烦，我们可以继承Spring Security提供的`org.springframework.security.core.userdetails.User`类，该类实现了`UserDetails`接口帮我们省去了重写方法的工作：

操作模块：spring-security模块

**添加SecurityUser对象**

```java
/**
 * 将SysUser包装为SpringSecurity下的User，用于SpringSecurity的认证和授权过程
 */
@Getter
@Setter
public class SecurityUser extends User {

    private SysUser sysUser;

    public SecurityUser(SysUser sysUser, Collection<? extends GrantedAuthority> authorities) {
        // 调用父类的构造方法，传入用户名，密码，权限列表
        super(sysUser.getUsername(), sysUser.getPassword(), authorities);
        this.sysUser = sysUser;
    }

}
```

##### 2.2.5 业务对象UserDetailsService

该接口很简单只有一个方法：

```java
public interface UserDetailsService {
    /**
     * 根据用户名获取用户对象（获取不到直接抛异常）
     */
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

我们实现该接口，就完成了自己的业务

**操作模块：service-system**

**添加SecurityUserDetailsServiceImpl类，实现UserDetailsService接口**

```java
/**
 * SpringSecurity在做用户认证时，需要通过UserDetailsService查询出用户信息
 */
@Slf4j
@Component
public class SecurityUserDetailsServiceImpl implements UserDetailsService {

    @Autowired
    private SysUserMapper sysUserMapper;

    /**
     * 通过用户名查询出用户信息，并用于认证
     *
     * @param username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        LambdaQueryWrapper<SysUser> wrapper = new QueryWrapper<SysUser>().lambda()
                .eq(SysUser::getUsername, username);
        SysUser sysUser = sysUserMapper.selectOne(wrapper);
        if (sysUser == null) {
            throw new CustomException(ResultCodeEnum.USER_NOT_EXIST.getCode(), ResultCodeEnum.USER_NOT_EXIST.getMessage());
        }
        if (sysUser.getStatus() != 1) {
            throw new CustomException(ResultCodeEnum.USER_LOCKED.getCode(), ResultCodeEnum.USER_LOCKED.getMessage());
        }        
        return new SecurityUser(sysUser, Collections.emptyList());
    }
}
```

`AuthenticationManager`校验所调用的三个组件我们就已经做好实现了！

##### 2.2.6、自定义用户认证接口

```java
/**
 * SpringSecurity认证（用户登录）
 */
@Slf4j
public class SecurityLoginFilter extends UsernamePasswordAuthenticationFilter {

    public SecurityLoginFilter(AuthenticationManager authenticationManager) {
        setAuthenticationManager(authenticationManager);
        setPostOnly(false);
        // 指定登录接口的地址
        setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher("/admin/system/index/login", "POST"));
    }

    /**
     * 认证（登录）
     *
     * @param request
     * @param response
     * @return
     * @throws AuthenticationException
     */
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            LoginVO loginVO = new ObjectMapper().readValue(request.getInputStream(), LoginVO.class);
            Authentication authentication = new UsernamePasswordAuthenticationToken(loginVO.getUsername(), loginVO.getPassword());
            return this.getAuthenticationManager().authenticate(authentication);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // 登录成功，生成token并返回
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {
        SecurityUser user = (SecurityUser) authResult.getPrincipal();
        String token = JwtHelper.createToken(user.getSysUser().getId(), user.getSysUser().getUsername());
        Map<String, String> map = new HashMap<>();
        map.put("token", token);
        ResponseUtil.out(response, Result.ok(map));
    }

    // 登录失败
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        // 登录失败会引发AuthenticationException异常，我们要获取引发AuthenticationException异常的原始异常
        // 并向客户端输出错误信息
        // 我们在loadUserByUsername方法中抛出的CustomException，都是RuntimeException
        if (failed.getCause() instanceof RuntimeException) {
            // 直接输出异常信息
            ResponseUtil.out(response, Result.fail().message(failed.getCause().getMessage()));
        } else {
            // 否则，输出用户登录失败
            ResponseUtil.out(response, Result.fail(ResultCodeEnum.USER_LOGIN_FAILED));
        }
    }
}
```

添加工具类：ResponseUtil

添加模块：common-util

```java
public class ResponseUtil {

    public static void out(HttpServletResponse response, Result r) {
        ObjectMapper mapper = new ObjectMapper();
        response.setStatus(HttpStatus.OK.value());
        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);
        try {
            mapper.writeValue(response.getWriter(), r);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

##### 2.2.7、认证解析token

因为用户登录状态在token中存储在客户端，所以每次请求接口请求头携带token， 后台通过自定义token过滤器拦截解析token完成认证并填充用户信息实体。

```java
/**
 * 对系统的每一个请求进行过滤
 * 1.如果是访问登录接口，直接放行
 * 2.访问其他接口则需要从token中解析用户信息（包含权限信息），用户信息将给到SpringSecurity做授权使用
 */
public class SecurityAuthenticationFilter extends OncePerRequestFilter {

    private static final String LOGIN_URL = "/admin/system/index/login";

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 登录接口，放行
        if (LOGIN_URL.equals(request.getRequestURI())) {
            filterChain.doFilter(request, response);
            return;
        }
        // 有可能用户已经登录过了，所以可以从token解析出用户信息，然后把权限信息给到SpringSecurity去做
        Authentication authentication = getAuthentication(request, response);
        if (authentication != null) {
            SecurityContextHolder.getContext().setAuthentication(authentication);
            filterChain.doFilter(request, response);
        } else {
            // token为空，则提示非法访问
            ResponseUtil.out(response, Result.fail(ResultCodeEnum.ILLEGAL_ACCESS));
        }
    }

    /**
     * 从token中解析出用户信息
     *
     * @param request
     * @param response
     * @return
     */
    private Authentication getAuthentication(HttpServletRequest request, HttpServletResponse response) {
        String token = request.getHeader("token");
        String username = null;
        if (StringUtils.hasText(token)) {
            try {
                username = JwtHelper.getUsername(token);
            } catch (ExpiredJwtException e) {
                // 登录信息超时，向客户端返回超时信息
                ResponseUtil.out(response, Result.fail(ResultCodeEnum.TOKEN_EXPIRE));
                throw e;
            }
            return new UsernamePasswordAuthenticationToken(username, null, Collections.emptyList());
        }
        return null;
    }
}
```

##### 2.2.8、配置用户认证

修改WebSecurityConfig配置类

```java
@Configuration
@EnableWebSecurity // 开启SpringSecurity的默认行为
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private Sha1PasswordEncoder sha1PasswordEncoder;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()  // 跨站请求伪造保护（Cross-site request forgery），暂时不需要
                .cors() // 开启跨域请求
                .and().authorizeRequests()
                .antMatchers("/admin/system/index/login").permitAll() // 登录接口不需要认证
                .anyRequest().authenticated() // 其它接口都需要认证
                .and().addFilterBefore(new SecurityAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class) // 把拦截加在认证过滤器之前
                .addFilter(new SecurityLoginFilter(authenticationManager()));
        // 禁用session
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }

    // 指定密码加密器
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(sha1PasswordEncoder);
    }

    // 指定哪些请求不拦截
    @Override
    public void configure(WebSecurity web) throws Exception {
        // swagger 有关的请求，放行
        web.ignoring().antMatchers("/favicon.ico","/swagger-resources/**", "/webjars/**", "/v2/**", "/swagger-ui.html/**", "/doc.html");
    }
}
```

**说明：**

**1、我们是前后端分离项目，使用`jwt`生成token ，即用户状态保存在客户端中，前后端交互通过api接口 `无session`生成，所以我们不需要配置`formLogin`，session禁用**

**2、在浏览器访问：http://localhost:8800/admin/system/sysRole/findAll**

```
{
    "code": 209,
    "message": "没有权限",
    "data": null
}
```

##### 2.2.9、通过swagger测试登录

http://localhost:8800/doc.html

在相应的自定义组件设置断点，查看是否按照预期执行。

1、先输入正确的用户名与密码

2、输入错误的用户名与密码

结论：跟预期一致

### 3、用户授权

 在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的**Authentication**，然后获取其中的权限信息。判断当前用户是否拥有访问当前资源所需的权限。

**SpringSecurity中的Authentication类：**

```java
public interface Authentication extends Principal, Serializable {
	//权限数据列表
    Collection<? extends GrantedAuthority> getAuthorities();

    Object getCredentials();

    Object getDetails();

    Object getPrincipal();

    boolean isAuthenticated();

    void setAuthenticated(boolean var1) throws IllegalArgumentException;
}
```



前面登录时执行loadUserByUsername方法时，return new CustomUser(sysUser, Collections.emptyList());后面的空数据对接就是返回给Spring Security的权限数据。

在TokenAuthenticationFilter中怎么获取权限数据呢？登录时我们把权限数据保存到redis中（用户名为key，权限数据为value即可），这样通过token获取用户名即可拿到权限数据，这样就可构成出完整的Authentication对象。

#### 3.1、修改loadUserByUsername接口方法

```java
/**
* 通过用户名查询出用户信息，并用于认证
*
* @param username
* @return
* @throws UsernameNotFoundException
*/
@Override
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    LambdaQueryWrapper<SysUser> wrapper = new QueryWrapper<SysUser>().lambda()
        .eq(SysUser::getUsername, username);
    SysUser sysUser = sysUserMapper.selectOne(wrapper);
    if (sysUser == null) {
        throw new CustomException(ResultCodeEnum.USER_NOT_EXIST.getCode(), ResultCodeEnum.USER_NOT_EXIST.getMessage());
    }
    if (sysUser.getStatus() != 1) {
        throw new CustomException(ResultCodeEnum.USER_LOCKED.getCode(), ResultCodeEnum.USER_LOCKED.getMessage());
    }
    // 获取用户权限列表
    List<SimpleGrantedAuthority> authorities = sysUserMapper.getAuthorities(sysUser.getId())
        .stream()
        .map(SysMenu::getPerms)
        .filter(StringUtils::hasText)  // 从SysMenu集合中提取一个字符串集合
        .map(SimpleGrantedAuthority::new) // 转为SimpleGrantedAuthority集合
        .collect(Collectors.toList());
    log.debug("authorities from database:"+authorities.toString());
    return new SecurityUser(sysUser, authorities);
}
```

#### 3.2、spring-security模块配置redis

添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

#### 3.3、修改SecurityLoginFilter登录成功方法

登录成功我们将权限数据保存到reids

```java
/**
 * SpringSecurity认证（用户登录）
 */
@Slf4j
public class SecurityLoginFilter extends UsernamePasswordAuthenticationFilter {

    private StringRedisTemplate redisTemplate;

    public SecurityLoginFilter(AuthenticationManager authenticationManager, StringRedisTemplate redisTemplate) {
        setAuthenticationManager(authenticationManager);
        setPostOnly(false);
        // 指定登录接口的地址
        setRequiresAuthenticationRequestMatcher(new AntPathRequestMatcher("/admin/system/index/login", "POST"));
        this.redisTemplate = redisTemplate;
    }

    /**
     * 认证（登录）
     *
     * @param request
     * @param response
     * @return
     * @throws AuthenticationException
     */
    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        try {
            LoginVO loginVO = new ObjectMapper().readValue(request.getInputStream(), LoginVO.class);
            Authentication authentication = new UsernamePasswordAuthenticationToken(loginVO.getUsername(), loginVO.getPassword());
            return this.getAuthenticationManager().authenticate(authentication);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // 登录成功，生成token并返回
    @Override
    protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {
        SecurityUser user = (SecurityUser) authResult.getPrincipal();
        String token = JwtHelper.createToken(user.getSysUser().getId(), user.getSysUser().getUsername());
        Map<String, String> map = new HashMap<>();
        map.put("token", token);
        // 权限数据保存到redis中，后续需要使用
        redisTemplate.opsForValue().set(user.getUsername(), JSON.toJSONString(user.getAuthorities()));
        log.debug("authorities to redis:"+JSON.toJSONString(user.getAuthorities()));
        ResponseUtil.out(response, Result.ok(map));
    }

    // 登录失败
    @Override
    protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
        // 登录失败会引发AuthenticationException异常，我们要获取引发AuthenticationException异常的原始异常
        // 并向客户端输出错误信息
        // 我们在loadUserByUsername方法中抛出的CustomException，都是RuntimeException
        if (failed.getCause() instanceof RuntimeException) {
            // 直接输出异常信息
            ResponseUtil.out(response, Result.fail().message(failed.getCause().getMessage()));
        } else {
            // 否则，输出用户登录失败
            ResponseUtil.out(response, Result.fail(ResultCodeEnum.USER_LOGIN_FAILED));
        }
    }
}
```

#### 3.4、修改SecurityAuthenticationFilter

认证是redis里面获取权限数据

完整代码：

```java
/**
 * 对系统的每一个请求进行过滤
 * 1.如果是访问登录接口，直接放行
 * 2.访问其他接口则需要从token中解析用户信息（包含权限信息），用户信息将给到SpringSecurity做授权使用
 */
public class SecurityAuthenticationFilter extends OncePerRequestFilter {

    private static final String LOGIN_URL = "/admin/system/index/login";

    private StringRedisTemplate redisTemplate;

    public SecurityAuthenticationFilter(StringRedisTemplate redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // 登录接口，放行
        if (LOGIN_URL.equals(request.getRequestURI())) {
            filterChain.doFilter(request, response);
            return;
        }
        // 有可能用户已经登录过了，所以可以从token解析出用户信息，然后把权限信息给到SpringSecurity去做
        Authentication authentication = getAuthentication(request, response);
        if (authentication != null) {
            SecurityContextHolder.getContext().setAuthentication(authentication);
            filterChain.doFilter(request, response);
        } else {
            // token为空，则提示非法访问
            ResponseUtil.out(response, Result.fail(ResultCodeEnum.ILLEGAL_ACCESS));
        }
    }

    /**
     * 从token中解析出用户信息
     *
     * @param request
     * @param response
     * @return
     */
    private Authentication getAuthentication(HttpServletRequest request, HttpServletResponse response) {
        String token = request.getHeader("token");
        String username = null;
        if (StringUtils.hasText(token)) {
            try {
                username = JwtHelper.getUsername(token);
            } catch (ExpiredJwtException e) {
                // 登录信息超时，向客户端返回超时信息
                ResponseUtil.out(response, Result.fail(ResultCodeEnum.TOKEN_EXPIRE));
                throw e;
            }
            // 从redis读取用户权限
            String json = redisTemplate.opsForValue().get(username);
            if (json == null){
                // redis重启会导致缓存被清空，直接让用户重新登录
                // 实际上这里应该从数据库重新读取数据加入到缓存中
                ResponseUtil.out(response, Result.fail(ResultCodeEnum.TOKEN_EXPIRE));
                return null;
            }
            List<SimpleGrantedAuthority> authorities = JSON.parseArray(json, AuthorityVO.class)
                    .stream()
                    .map(AuthorityVO::getAuthority)
                    .map(SimpleGrantedAuthority::new)
                    .collect(Collectors.toList());
            return new UsernamePasswordAuthenticationToken(username, null, authorities);
        }
        return null;
    }
}
```

#### 3.5、修改配置类

修改WebSecurityConfig类

配置类添加注解：

开启基于方法的安全认证机制，也就是说在web层的controller启用注解机制的安全确认

```java
@EnableGlobalMethodSecurity(prePostEnabled = true)
```

添加注入bean：

```java
@Autowired
private RedisTemplate redisTemplate;
```

添加参数：

两个fillter添加redisTemplate参数

**完整代码如下：**

```java
@Configuration
@EnableWebSecurity // 开启SpringSecurity的默认行为
@EnableGlobalMethodSecurity(prePostEnabled = true) // 开启注解功能
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private UserDetailsService userDetailsService;

    @Autowired
    private Sha1PasswordEncoder sha1PasswordEncoder;

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .csrf().disable()  // 跨站请求伪造保护（Cross-site request forgery），暂时不需要
                .cors() // 开启跨域请求
                .and().authorizeRequests()
                .antMatchers("/admin/system/index/login").permitAll() // 登录接口不需要认证
                .anyRequest().authenticated() // 其它接口都需要认证
                .and().addFilterBefore(new SecurityAuthenticationFilter(redisTemplate), UsernamePasswordAuthenticationFilter.class) // 把拦截加在认证过滤器之前
                .addFilter(new SecurityLoginFilter(authenticationManager(), redisTemplate));
        // 禁用session
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);
    }

    // 指定密码加密器
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        auth.userDetailsService(userDetailsService).passwordEncoder(sha1PasswordEncoder);
    }

    // 指定哪些请求不拦截
    @Override
    public void configure(WebSecurity web) throws Exception {
        // swagger 有关的请求，放行
        web.ignoring().antMatchers("/favicon.ico","/swagger-resources/**", "/webjars/**", "/v2/**", "/swagger-ui.html/**", "/doc.html");
    }
}
```

#### 3.6、service-system模块添加redis配置

application-dev.yml配文件

```yaml
spring:
  redis:
    host: 192.168.6.100
    port: 6379
    database: 0
    timeout: 1800000
    password:
    jedis:
      pool:
        max-active: 20 #最大连接数
        max-wait: -1    #最大阻塞等待时间(负数表示没限制)
        max-idle: 5    #最大空闲
        min-idle: 0     #最小空闲
```

#### 3.7、控制controller层接口权限

**Spring Security默认是禁用注解的，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，来判断用户对某个控制层的方法是否具有访问权限**

通过@PreAuthorize标签控制controller层接口权限

```java
public class SysRoleController {

    @Autowired
    private SysRoleService sysRoleService;

    @PreAuthorize("hasAuthority('bnt.sysRole.list')")
    @ApiOperation(value = "获取分页列表")
    @GetMapping("/{page}/{limit}")
    public Result index(
            @ApiParam(name = "page", value = "当前页码", required = true)
            @PathVariable Long page,

            @ApiParam(name = "limit", value = "每页记录数", required = true)
            @PathVariable Long limit,

            @ApiParam(name = "roleQueryVo", value = "查询对象", required = false)
                    SysRoleQueryVo roleQueryVo) {
        Page<SysRole> pageParam = new Page<>(page, limit);
        IPage<SysRole> pageModel = sysRoleService.selectPage(pageParam, roleQueryVo);
        return Result.ok(pageModel);
    }

    @PreAuthorize("hasAuthority('bnt.sysRole.list')")
    @ApiOperation(value = "获取")
    @GetMapping("/get/{id}")
    public Result get(@PathVariable Long id) {
        SysRole role = sysRoleService.getById(id);
        return Result.ok(role);
    }

    @PreAuthorize("hasAuthority('bnt.sysRole.add')")
    @ApiOperation(value = "新增角色")
    @PostMapping("/save")
    public Result save(@RequestBody @Validated SysRole role) {
        sysRoleService.save(role);
        return Result.ok();
    }

    @PreAuthorize("hasAuthority('bnt.sysRole.update')")
    @ApiOperation(value = "修改角色")
    @PutMapping("/update")
    public Result updateById(@RequestBody SysRole role) {
        sysRoleService.updateById(role);
        return Result.ok();
    }

    @PreAuthorize("hasAuthority('bnt.sysRole.remove')")
    @ApiOperation(value = "删除角色")
    @DeleteMapping("/remove/{id}")
    public Result remove(@PathVariable Long id) {
        sysRoleService.removeById(id);
        return Result.ok();
    }

    @PreAuthorize("hasAuthority('bnt.sysRole.remove')")
    @ApiOperation(value = "根据id列表删除")
    @DeleteMapping("/batchRemove")
    public Result batchRemove(@RequestBody List<Long> idList) {
        sysRoleService.removeByIds(idList);
        return Result.ok();
    }
    ...
}
```

#### 3.8、测试服务器端权限

登录后台，分配权限进行测试，页面如果添加了按钮权限控制，可临时去除方便测试

测试结论：

​	1、分配了权限的能够成功返回接口数据

​	2、没有分配权限的会抛出异常：org.springframework.security.access.AccessDeniedException: 不允许访问

#### 3.9、异常处理

异常处理有2种方式：

​	1、扩展Spring Security异常处理类：AccessDeniedHandler、AuthenticationEntryPoint

​	2、在spring boot全局异常统一处理

**第一种方案说明：如果系统实现了全局异常处理，那么全局异常首先会获取AccessDeniedException异常，要想Spring Security扩展异常生效，必须在全局异常再次抛出该异常。**

**第二种方案最简单，我们使用第二种方案，第一种方案自行研究。**

**全局异常添加处理**

操作模块：service-util

```java
// SpringSecurity拦截非法访问，会抛出异常
@ExceptionHandler(AccessDeniedException.class)
public Result caught(AccessDeniedException e) {
    e.printStackTrace();
    // 从异常信息中获取code和message，设置到响应结果中
    return Result.fail().message(e.getMessage());
}
```

AccessDeniedException需要引入依赖，Spring Security对应的异常

在service-util模块引入依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
    <scope>provided</scope>
</dependency>
```
