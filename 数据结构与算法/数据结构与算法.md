# 课程介绍


## 课程目标

数据结构和算法这门课程无论在哪个学校的计算机专业，都是一门必修课，因为这门课程非常重要的，是编程必备的基础，但是这门课程是一门不太好学习的课程，因为它学习起来有一定的难度。但是如果你想让自己的编程能力有质的飞跃，不再停留于调用现成的API，而是追求更完美的实现，那么这门课程就是你的必修课，因为程序设计=数据结构+算法。

通过对基础数据结构和算法的学习，能更深层次的理解程序，提升编写代码的能力，让程序的代码更优雅，性能更高。

## 课程特征

数据结构与算法与其他的内容相比

相同点：

1.都有抽象模型
2.什么是理解？弄清楚逻辑关系
3.理解了之后，自然容易记住一些

不同点：

逻辑关系可能更加复杂，需要把复杂的逻辑关系，分解成若干个简单的逻辑关系

## 课程内容

1. 数据结构和算法概述

2. 算法分析

3. 排序

4. 线性表

5. 符号表

6. 树

7. 堆

8. 优先队列

9. 并查集

10.  图

# 数据结构和算法概述

## 什么是数据结构？

**官方解释：**

数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。  

**大白话：**

数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据

## 数据结构分类

传统上，我们可以把数据结构分为逻辑结构和物理结构两大类。

**逻辑结构分类：**

逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是我们后面课题中需要关注和讨论的问题。

a. 集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。

![](.\images\集合结构.png)

b. 线性结构：线性结构中的数据元素之间存在一对一的关系

![](.\images\线性结构.png)

c. 树形结构：树形结构中的数据元素之间存在一对多的层次关系

![](.\images\树形结构.png)

d. 图形结构：图形结构的数据元素是多对多的关系

![](.\images\图形结构.png)

**物理结构分类：**

逻辑结构在计算机中真正的表示方式（又称为映像）称为物理结构，也可以叫做存储结构。常见的物理结构有顺序存储结构、链式存储结构。

顺序存储结构：

把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的  ，比如我们常用的数组就是顺序存储结构。

![](.\images\顺序存储结构.png)

顺序存储结构存在一定的弊端，就像生活中排队时也会有人插队也可能有人有特殊情况突然离开，这时候整个结构都处于变化中，此时就需要链式存储结构。

链式存储结构：

是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置

![](.\images\链式存储结构.png)

## 什么是算法？

**官方解释：**

算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。

**大白话：**

根据一定的条件，对一些数据进行计算，得到需要的结果。

**算法初体验**

在生活中，我们如果遇到某个问题，常常解决方案不是唯一的。

例如从西安到北京，如何去？会有不同的解决方案，我们可以坐飞机，可以坐火车，可以坐汽车，甚至可以步行，不同的解决方案带来的时间成本和金钱成本是不一样的，比如坐飞机用的时间最少，但是费用最高，步行费用最低，但时间最长。

再例如在北京二环内买一套四合院，如何付款？也会有不同的解决方案，可以一次性现金付清，也可以通过银行做按揭。这两种解决方案带来的成本也不一样，一次性付清，虽然当时出的钱多，压力大，但是没有利息，按揭虽然当时出的钱少，压力比较小，但是会有利息，而且30年的总利息几乎是贷款额度的一倍，需要多付钱。

在程序中，我们也可以用不同的算法解决相同的问题，而不同的算法的成本也是不相同的。总体上，一个优秀的算法追求以下两个目标：

1. 花最少的时间完成需求；
2. 占用最少的内存空间完成需求；

下面我们用一些实际案例体验一些算法。

**需求：**

计算1到100的和。

第一种解法：

```java
public static void main(String[] args) {
	int sum = 0;
	int n=100;
	for (int i = 1; i <= n; i++) {
		sum += i;
	}
	System.out.println("sum=" + sum); 
}
```

第二种解法：

 ```java
 public static void main(String[] args) {
 	int sum = 0;
 	int n=100;
 	sum = (n+1)*n/2;
 	System.out.println("sum="+sum); 
 }
 ```

第一种解法要完成需求，要完成以下几个动作：

1. 定义两个整型变量；
2. 执行100次加法运算；
3. 打印结果到控制台；

第二种解法要完成需求，要完成以下几个动作：

1. 定义两个整型变量；
2. 执行1次加法运算，1次乘法运算，一次除法运算，总共3次运算；
3. 打印结果到控制台；

很明显，第二种算法完成需求，花费的时间更少一些。

 

**需求2：**

计算10的阶乘

第一种解法：

```java
public class Test {
    public static void main(String[] args) {
        //测试，计算10的阶乘
        long result = fun1(10);
        System.out.println(result);
    }
    
	//计算n的阶乘
	public static long fun1(long n){
		if (n==1){
			return 1;
		}
		return n*fun1(n-1); 
	}    
}
```

第二种解法：

```java
public class Test {
    public static void main(String[] args) {
        //测试，计算10的阶乘
        long result = fun2(10);
        System.out.println(result);
    }
	//计算n的阶乘
	public static long fun2(long n){
		int result=1;
		for (long i = 1; i <= n; i++) {
			result*=i;
		}
		return result; 
	}
}
```



第一种解法，使用递归完成需求，fun1方法会执行10次，并且第一次执行未完毕，调用第二次执行，第二次执行未完毕，调用第三次执行...最终，最多的时候，需要在栈内存同时开辟10块内存分别执行10个fun1方法。

第二种解法，使用for循环完成需求，fun2方法只会执行一次，最终，只需要在栈内存开辟一块内存执行fun2方法  即可。

很明显，第二种算法完成需求，占用的内存空间更小。

# 算法分析

前面我们已经介绍了，研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。有关算法时间耗费分析，我们称之为算法的时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析。

## 算法的时间复杂度分析

我们要计算算法时间耗费情况，首先我们得度量算法的执行时间，那么如何度量呢？ 

**事后分析估算方法：**

比较容易想到的方法就是我们把算法执行若干次，然后拿个计时器在旁边计时，这种事后统计的方法看上去的确不错，并且也并非要我们真的拿个计算器在旁边计算，因为计算机都提供了计时的功能。这种统计方法主要是通过设计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低，但是这种方法有很大的缺陷：必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件环境)的差别导致测试的结果差异也很大。

```java
public static void main(String[] args) {
    long start = System.currentTimeMillis();
    int sum = 0;
    int n=100;
    for (int i = 1; i <= n; i++) { 
        sum += i;
    }
    System.out.println("sum=" + sum);

    long end = System.currentTimeMillis(); 
    System.out.println(end-start);
}
```

**事前分析估算方法：**

在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序在计算机上运行所消耗的时间取决于下列因素：

1. 算法采用的策略和方案；
2. 编译产生的代码质量；
3. 问题的输入规模(所谓的问题输入规模就是输入量的多少)；
4. 机器执行指令的速度；



由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。  如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。

我们再次以之前的求和案例为例，进行分析。

**需求：**

计算1到100的和。

第一种解法：

```java
// 如果输入量为n为1，则需要计算1次；
// 如果输入量n为1亿，则需要计算1亿次；
public static void main(String[] args) {
	int sum = 0;//执行1次
	int n=100;//执行1次
	for (int i = 1; i <= n; i++) {//执行了n+1次
		sum += i;//执行了n次
	}
	System.out.println("sum=" + sum); 
}
```

第二种解法：

```java
// 如果输入量为n为1，则需要计算1次；
// 如果输入量n为1亿，则需要计算1次；
public static void main(String[] args) {
	int sum = 0;//执行1次
	int n=100;//执行1次
	sum = (n+1)*n/2;//执行1次
	System.out.println("sum="+sum); 
}
```

因此，当输入规模为n时，第一种算法执行了1+1+(n+1)+n=2n+3次；第二种算法执行了1+1+1=3次。如果我们把第一种算法的循环体看做是一个整体，忽略结束条件的判断，那么其实这两个算法运行时间的差距就是n和1的差距。

为什么循环判断在算法1里执行了n+1次，看起来是个不小的数量，但是却可以忽略呢？我们来看下一个例子：  

**需求：**

计算100个1+100个2+100个3+...100个100的结果

代码：

```java
public static void main(String[] args) {
	int sum=0;
	int n=100;
	for (int i = 1; i <=n ; i++) {
		for (int j = 1; j <=n ; j++) {
			sum+=i;
		}
	}
	System.out.println("sum="+sum); 
}
```

上面这个例子中，如果我们要精确的研究循环的条件执行了多少次，是一件很麻烦的事情，并且，由于真正计算和的代码是内循环的循环体，所以，在研究算法的效率时，我们只考虑核心代码的执行次数，这样可以简化分析。
我们研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量的一个抽象(规律)，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译期优化等问题，容易主次跌倒。
我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止的条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最重要的是把程序看做是独立于程序设计语言的算法或一系列步骤。我们分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来。

![](.\images\算法效率对比.png)

## 函数渐近增长

**概念：**

给定两个函数f(n)和g(n),如果存在一个整数N，使得对于所有的n>N,f(n)总是比g(n)大，那么我们说f(n)的增长渐近快于g(n)。

概念似乎有点艰涩难懂，那接下来我们做几个测试。

**测试一：**

假设四个算法的输入规模都是n：

1. 算法A1要做2n+3次操作，可以这么理解：先执行n次循环，执行完毕后，再有一个n次循环，最后有3次运算；

2. 算法A2要做2n次操作；

3. 算法B1要做3n+1次操作，可以这个理解：先执行n次循环，再执行一个n次循环，再执行一个n次循环，最后有1

   次运算。

5. 算法B2要做3n次操作；

那么，上述算法，哪一个更快一些呢？

![](.\images\测试一执行次数.png)

![](.\images\测试一效率对比.png)

通过数据表格，比较算法A1和算法B1：

- 当输入规模n=1时，A1需要执行5次，B1需要执行4次，所以A1的效率比B1的效率低；

- 当输入规模n=2时，A1需要执行7次，B1需要执行7次，所以A1的效率和B1的效率一样；

- 当输入规模n>2时，A1需要的执行次数一直比B1需要执行的次数少，所以A1的效率比B1的效率高；

所以我们可以得出结论：

**当输入规模n>2时，算法A1的渐近增长小于算法B1 的渐近增长**

通过观察折线图，我们发现，随着输入规模的增大，算法A1和算法A2逐渐重叠到一块，算法B1和算法B2逐渐重叠到一块，所以我们得出结论：

**随着输入规模的增大，算法的常数操作可以忽略不计**

**测试二：**
假设四个算法的输入规模都是n：

1. 算法C1需要做4n+8次操作
2. 算法C2需要做n次操作
3. 算法D1需要做2n^2次操作
4. 算法D2需要做n^2次操作

那么上述算法，哪个更快一些？

![](.\images\测试二执行次数.png)

![](.\images\测试二效率对比.png)

通过数据表格，对比算法C1和算法D1：

- 当输入规模n<=3时，算法C1执行次数多于算法D1，因此算法C1效率低一些；

- 当输入规模n>3时，算法C1执行次数少于算法D1，因此，算法D2效率低一些， 所以，总体上，算法C1要优于算法D1.



通过折线图，对比对比算法C1和C2：

- 随着输入规模的增大，算法C1和算法C2几乎重叠通过折线图

对比算法C系列和算法D系列：

- 随着输入规模的增大，即使去除n^2前面的常数因子，D系列的次数要远远高于C系列。

 

因此，可以得出结论：

**随着输入规模的增大，与最高次项相乘的常数可以忽略**



**测试三：**

假设四个算法的输入规模都是n： 

算法E1:

2n^2+3n+1;

算法E2：

n^2

算 法 F1： 

2n^3+3n+1 

算 法 F2： 

n^3

那么上述算法，哪个更快一些？

![](.\images\测试三执行次数.png)

![](.\images\测试三效率对比.png)

通过数据表格，对比算法E1和算法F1：

- 当n=1时，算法E1和算法F1的执行次数一样；

- 当n>1时，算法E1的执行次数远远小于算法F1的执行次数； 所以算法E1总体上是由于算法F1的。

通过折线图我们会看到，算法F系列随着n的增长会变得特块，算法E系列随着n的增长相比较算法F来说，变得比较慢，所以可以得出结论：

**最高次项的指数大的，随着n的增长，结果也会变得增长特别快**

 

**测试四：**

假设五个算法的输入规模都是n： 

算法G：

n^3;

算法H:

n^2;

算法I：

n:

算法J：

logn 

算法K:

1

> log表示对数函数。一般地，函数y=log(a)X，（其中a是常数，a>0且a不等于1）叫做对数函数，它实际上就是指数函数的反函数，可表示为x=a^y。
>
> log2 代表：log(2)2

那么上述算法，哪个效率更高呢？

![](.\images\测试四执行次数.png)

![](.\images\测试四效率对比.png)

通过观察数据表格和折线图，很容易可以得出结论： **算法函数中n最高次幂越小，算法效率越高**

总上所述，在我们比较算法随着输入规模的增长量时，可以有以下规则：

1. **算法函数中的常数可以忽略；**
2. **算法函数中最高次幂的常数因子可以忽略；**
3. **算法函数中最高次幂越小，算法效率越高。**

## 算法时间复杂度

### 大O记法

**定义：**

在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。

在这里，我们需要明确一个事情：**执行次数=执行时间**

用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。

下面我们使用大O表示法来表示一些求和算法的时间复杂度： 

算法一：

```java
public static void main(String[] args) {
	int sum = 0;//执行1次
	int n=100;//执行1次
	sum = (n+1)*n/2;//执行1次
	System.out.println("sum="+sum); 
}
```

算法二：

```java
public static void main(String[] args) {
	int sum = 0;//执行1次
	int n=100;//执行1次
	for (int i = 1; i <= n; i++) {
		sum += i;//执行了n次
	}
	System.out.println("sum=" + sum); 
}
```

算法三：

```java
public static void main(String[] args) {
	int sum=0;//执行1次
	int n=100;//执行1次
	for (int i = 1; i <=n ; i++) {
		for (int j = 1; j <=n ; j++) {
			sum+=i;//执行n^2次
		}
	}
	System.out.println("sum="+sum); 
}
```

如果忽略判断条件的执行次数和输出语句的执行次数，那么当输入规模为n时，以上算法执行的次数分别为：  

算法一：3次

算法二：n+3次 

算法三：n^2+2次

如果用大O记法表示上述每个算法的时间复杂度，应该如何表示呢？基于我们对函数渐近增长的分析，推导大O阶的表示法有以下几个规则可以使用：

**1.** **用常数1取代运行时间中的所有加法常数；**

**2.** **在修改后的运行次数中，只保留高阶项；**

**3.** **如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；** 

所以，上述算法的大O记法分别为：

算法一：O(1) 

算法二：O(n)

算法三：O(n^2)

### 常见的大O阶

**线性阶**

一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：

```java
public static void main(String[] args) {
	int sum = 0;
	int n=100;
	for (int i = 1; i <= n; i++) {
		sum += i;
	}
	System.out.println("sum=" + sum); 
}
```

上面这段代码，它的循环的时间复杂度为O(n),因为循环体中的代码需要执行n次

**平方阶**

一般嵌套循环属于这种时间复杂度

```java
public static void main(String[] args) {
    int sum=0,n=100;
	for (int i = 1; i <=n ; i++) {
		for (int j = 1; j <=n ; j++) { 
            sum+=i;
		}
	}
	System.out.println(sum);
}
```

上面这段代码，n=100，也就是说，外层循环每执行一次，内层循环就执行100次，那总共程序想要从这两个循环中出来，就需要执行100*100次，也就是n的平方次，所以这段代码的时间复杂度是O(n^2).

**立方阶**

一般三层嵌套循环属于这种时间复杂度

```java
public static void main(String[] args) {
    int x=0,n=100;
	for (int i = 1; i <=n ; i++) {
		for (int j = i; j <=n ; j++) {
			for (int j = i; j <=n ; j++) { 
                x++;
			}
		}
	}
	System.out.println(x);
}
```

上面这段代码，n=100，也就是说，外层循环每执行一次，中间循环循环就执行100次，中间循环每执行一次，最  内层循环需要执行100次，那总共程序想要从这三个循环中出来，就需要执行100*100*100次，也就是n的立方，所以这段代码的时间复杂度是O(n^3).

**对数阶**

对数，属于高中数学的内容，我们分析程序以程序为主，数学为辅，所以不用过分担心。

```java
int i=1,n=100;
while(i<n){
	i = i*2; 
}
```

由于每次i*2之后，就距离n更近一步，假设有x个2相乘后大于n，则会退出循环。由于是2^x=n,得到x=log(2)n,所以这个循环的时间复杂度为O(logn);

对于对数阶，由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会**忽略底数**。

![](.\images\对数阶执行次数.png)

![](.\images\对数阶效率对比.png)

**常数阶**

一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。例如：

```java
public static void main(String[] args) { 
    int n=100;
	int i=n+2;
	System.out.println(i);
}
```

上述代码，不管输入规模n是多少，都执行2次，根据大O推导法则，常数用1来替换，所以上述代码的时间复杂度  为O(1)

下面是对常见时间复杂度的一个总结：

| **描述**     | **增长的数量级** | **说明** | **举例**       |
| ------------ | ---------------- | -------- | -------------- |
| 常数级别     | 1                | 普通语句 | 将两个数相加   |
| 对数级别     | logN             | 二分策略 | 二分查找       |
| 线性级别     | N                | 循环     | 找出最大元素   |
| 线型对数级别 | NlogN            | 分治思想 | 归并排序       |
| 平方级别     | N^2              | 双层循环 | 检查所有元素对 |
| 立方级别     | N^3              | 三层循环 | 检查所有三元组 |
| 指数级别     | 2^N              | 穷举查找 | 检查所有子集   |

他们的复杂程度从低到高依次为：

O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)

根据前面的折线图分析，我们会发现，从平方阶开始，随着输入规模的增大，时间成本会急剧增大，所以，我们的算法，尽可能的追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、  立方阶或者更复杂的，那我们可以认为这种算法是不可取的，需要优化。

### 函数调用的时间复杂度分析

之前，我们分析的都是单个函数内，算法代码的时间复杂度，接下来我们分析函数调用过程中时间复杂度。  

**案例一：**

```java
public static void main(String[] args) {
    int n=100;
    for (int i = 0; i < n; i++) { 
        show(i);
    }
}
private static void show(int i) {
	System.out.println(i);
}
```

在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部只执行了一行代码，所以show方法的时间复杂度为O(1),那main方法的时间复杂度就是O(n)

**案例二：**

```java
public static void main(String[] args) {
	int n=100;
	for (int i = 0; i < n; i++) { 
        show(i);
	}
}
private static void show(int i) {
	for (int j = 0; j < i; i++) { 
        System.out.println(i);
	}
}
```

在main方法中，有一个for循环，循环体调用了show方法，由于show方法内部也有一个for循环，所以show方法  的时间复杂度为O(n),那main方法的时间复杂度为O(n^2)

**案例三：**

```java
public static void main(String[] args) {
    int n=100; 
    show(n);
    for (int i = 0; i < n; i++) { 
        show(i);
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) { 
            System.out.println(j);
        }
    }
}
private static void show(int i) {
    for (int j = 0; j < i; i++) { 
        System.out.println(i);
    }
}
```

在show方法中，有一个for循环，所以show方法的时间复杂度为O(n),在main方法中，show(n)这行代码内部执行的次数为n，第一个for循环内调用了show方法，所以其执行次数为n^2,第二个嵌套for循环内只执行了一行代码，  所以其执行次数为n^2,那么main方法总执行次数为n+n^2+n^2=2n^2+n。根据大O推导规则，去掉n保留最高阶项，并去掉最高阶项的常数因子2，所以最终main方法的时间复杂度为O(n^2)

### 最坏情况

从心理学角度讲，每个人对发生的事情都会有一个预期，比如看到半杯水，有人会说：哇哦，还有半杯水哦！但也有人会说：天哪，只有半杯水了。一般人处于一种对未来失败的担忧，而在预期的时候趋向做最坏的打算，这样即使最糟糕的结果出现，当事人也有了心理准备，比较容易接受结果。假如最糟糕的结果并没有出现，当事人会很快乐。

算法分析也是类似，假如有一个需求：

有一个存储了n个随机数字的数组，请从中查找出指定的数字。

```java
public int search(int num){
	int[] arr={11,10,8,9,7,22,23,0};
	for (int i = 0; i < arr.length; i++) {
		if (num==arr[i]){
			return i;
		}
	}
	return -1; 
}
```

**最好情况：**

查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1) 

**最坏情况：**

查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n) 

**平均情况：**

任何数字查找的平均成本是O(n/2)

最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非特别指定，我们提到的运行时间都指的是**最坏情况下的运行时间**。

## 算法的空间复杂度分析

计算机的软硬件都经历了一个比较漫长的演变史，作为为运算提供环境的内存，更是如此，从早些时候的512k,经   历了1M，2M，4M...等，发展到现在的8G，甚至16G和32G，所以早期，算法在运行过程中对内存的占用情况也是  一个经常需要考虑的问题。我们可以用算法的空间复杂度来描述算法对内存的占用。

### Java 中常见内存占用

1. 基本数据类型内存占用情况：

| **数据类型** | **内存占用字节数** |
| ------------ | ------------------ |
| byte         | 1                  |
| short        | 2                  |
| int          | 4                  |
| long         | 8                  |
| ﬂoat         | 4                  |
| double       | 8                  |
| boolean      | 1                  |
| char         | 2                  |

2. 计算机访问内存的方式都是一次一个字节

![](.\images\计算机访问内存方式.png)

3. 一个引用（机器地址）需要8个字节表示：

   例如： Date date = new Date(),则date这个变量需要占用8个字节来表示

4. 创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。

5. 一般内存的使用，如果不够8个字节，都会被自动填充为8字节：

![](.\images\自动填充.png)

6. java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要

   24字节的头信息(16个自己的对象开销，4字节用于保存长度以及4个填充字节)再加上保存值所需的内存。

### 算法的空间复杂度

了解了java的内存最基本的机制，就能够有效帮助我们估计大量程序的内存使用情况。

算法的空间复杂度计算公式记作：S(n)=O(f(n)),其中n为输入规模，f(n)为语句关于n所占存储空间的函数。  

**案例：**

对指定的数组元素进行反转，并返回反转的内容。

解法一：

```java
public static int[] reverse1(int[] arr){
	int n=arr.length;//申请4个字节
	int temp;//申请4个字节
	for(int start=0,end=n-1;start<=end;start++,end--){
		temp=arr[start];
		arr[start]=arr[end];
		arr[end]=temp; 
	}
	return arr; 
}
```

解法二：

```java
public static int[] reverse2(int[] arr){
	int n=arr.length;//申请4个字节
	int[] temp=new int[n];//申请n*4个字节+数组自身头信息开销24个字节
	for (int i = n-1; i >=0; i--) {
		temp[n-1-i]=arr[i]; 
	}
	return temp; 
}
```

忽略判断条件占用的内存，我们得出的内存占用情况如下：

 算法一：

不管传入的数组大小为多少，始终额外申请4+4=8个字节； 

算法二：

4+4n+24=4n+28;

根据大O推导法则，算法一的空间复杂度为O(1),算法二的空间复杂度为O(n),所以从空间占用的角度讲，算法一要优于算法二。

由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化（例如即时编译），我们无法精确的评估一  个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。

由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。

但是，如果你做的程序是嵌入式开发、或者移动开发，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几kb，这个时候对算法的空间复杂度就有要求了。

# 简单排序

在我们的程序中，排序是非常常见的一种需求，提供一些数据元素，把这些数据元素按照一定的规则进行排序。比  如查询一些订单，按照订单的日期进行排序；再比如查询一些商品，按照商品的价格进行排序等等。所以，接下来  我们要学习一些常见的排序算法。

在java的开发工具包jdk中，已经给我们提供了很多数据结构与算法的实现，比如List，Set，Map，Math等等，都  是以API的方式提供，这种方式的好处在于一次编写，多处使用。我们借鉴jdk的方式，也把算法封装到某个类中，  那如果是这样，在我们写java代码之前，就需要先进行API的设计，设计好之后，再对这些API进行实现。

就比如我们先设计一套API如下：

| **类名** | **ArrayList**                                                |
| -------- | ------------------------------------------------------------ |
| 构造方法 | ArrayList()：创建ArrayList对象                               |
| 成员方法 | 1.boolean add(E e)：向集合中添加元素<br />2.E remove(int index):从集合中删除指定的元素 |

然后再使用java代码去实现它。以后我们讲任何数据结构与算法都是以这种方式讲解

## Comparable 接口介绍

由于我们这里要讲排序，所以肯定会在元素之间进行比较，而Java提供了一个接口Comparable就是用来定义排序规则的，在这里我们以案例的形式对Comparable接口做一个简单的回顾。

**需求：**

1. 定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则；
2. 定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1,Comparable c2)完成测试

```java
//学生类
public class Student implements Comparable<Student>{
    private String username;
	private int age;

	public String getUsername() { 
        return username;
	}

    public void setUsername(String username) { 
        this.username = username;
    }

    public int getAge() { 
        return age;
    }
    public void setAge(int age) { 
        this.age = age;
	}

    @Override
    public String toString() { 
        return "Student{" +"username='" + username + '\'' + ", age=" + age +'}';
    }
    //定义比较规则
    @Override
    public int compareTo(Student o) { 
        return this.getAge()-o.getAge();
    }
}

//测试类
public class Test {
    public static void main(String[] args) 
        Student stu1 = new Student();
        stu1.setUsername("zhangsan");
        stu1.setAge(17); 
        Student stu2 = new Student();
        stu2.setUsername("lisi");
        stu2.setAge(19); 
        Comparable max = getMax(stu1, stu2);
        System.out.println(max); 
    }
    //测试方法，获取两个元素中的较大值
    public static Comparable getMax(Comparable c1,Comparable c2){
        int cmp = c1.compareTo(c2);
        if (cmp>=0){
            return c1;
        }else{
            return c2;
        }
    }
}
```

## 冒泡排序

冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。

**需求：**

排序前：{4,5,6,3,2,1}

排序后：{1,2,3,4,5,6}

**排序原理：**

1. 比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。
2. 对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。

![](.\images\冒泡排序.png)

**冒泡排序API设计：**

| **类名** | **Bubble**                                                   |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Bubble()：创建Bubble对象                                     |
| 成员方法 | 1. public static void sort(Comparable[] a)：对数组内的元素进行排序<br />2. private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br />3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

**冒泡排序的代码实现：**

```java
//排序代码
public class Bubble 
	/*
	对数组a中的元素进行排序
	*/
    public static void sort(Comparable[] a){
    	// 外层循环控制冒泡次数，内层循环控制比较次数
    	for(int i=1;i<a.length;i++){
            for(int j=0;j<a.length - i;j++){
                //比较索引j和索引j+1处的值
                if (greater(a[j],a[j+1])){
                    exch(a,j,j+1);
                }
            }
            System.out.printf("第 %d 次冒泡，结果为：%s \n",i, Arrays.toString(a));
        }
    }
    /*
    比较v元素是否大于w元素
    */
	private static boolean greater(Comparable v,Comparable w){ 
        return v.compareTo(w)>0;
	}

    /*
    数组元素i和j交换位置
    */
    private static void exch(Comparable[] a,int i,int j){ 
        Comparable t = a[i];
    	a[i]=a[j]; 
        a[j]=t;
    }
}
//测试代码
public class Test {
    public static void main(String[] args) { 
        Integer[] a = {4, 5, 6, 3, 2, 1};
    	Bubble.sort(a); 
        System.out.println(Arrays.toString(a));
    }
}
```

**冒泡排序的时间复杂度分析**  冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以， 我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。

在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么： 

元素比较的次数为：

(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;

元素交换的次数为：

(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;

总执行次数为：

(N^2/2-N/2)+(N^2/2-N/2)=N^2-N;

按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N^2).

## 选择排序

选择排序是一种更加简单直观的排序方法。

**需求：**

排序前：{4,6,8,7,9,2,10,1}

排序后：{1,2,4,5,7,8,9,10}

**排序原理：**

1. 每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引

2. 交换第一个索引处和最小值所在的索引处的值

![](.\images\选择排序.png)

**选择排序API设计：**

| **类名** | **Selection**                                                |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Selection()：创建Selection对象                               |
| 成员方法 | 1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br />2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br />3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

**选择排序的代码实现：**

```java
//排序代码
public class Selection 
	/*
	对数组a中的元素进行排序
	*/
    public static void sort(Comparable[] a){
        // 外层循环控制排序次数，内层循环控制比较次数
        for(int i=0;i<a.length-1;i++){
            //定义一个变量，记录最小元素所在的索引，默认为第一个元素所在的位置
            int minIndex = i;
            for(int j=i+1;j<a.length;j++){
                //如果比 minIndex 处的值小，对 minIndex 重新赋值
                if (greater(a[minIndex],a[j])){
                    minIndex=j;
                }
            }

            //交换最小元素所在索引minIndex处的值和索引i处的值
            exch(a,i,minIndex);
        }
    }
	/*
	比较v元素是否大于w元素
	*/
    private static boolean greater(Comparable v,Comparab
        return v.compareTo(w)>0; 
    }
	/*
	数组元素i和j交换位置
	*/
    private static void exch(Comparable[] a,int i,int j)
        Comparable t = a[i];
        a[i]=a[j];
        a[j]=t;
    }
}
//测试代码
public class Test {
    public static void main(String[] args) 
        Integer[] a = {4,6,8,7,9,2,10,1};
        Selection.sort(a);
        System.out.println(Arrays.toString(a)); 
    }
}
```

**选择排序的时间复杂度分析：**

选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据  交换次数和数据比较次数：

数据比较次数：

(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;

数据交换次数：

N-1

时间复杂度：N^2/2-N/2+（N-1）=N^2/2+N/2-1;

根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2);

## 插入排序

插入排序（Insertion sort）是一种简单直观且稳定的排序算法。

插入排序的工作方式非常像人们排序一手扑克牌一样。开始时，我们的左手为空并且桌子上的牌面朝下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在  手中的每张牌进行比较，如下图所示：

![](.\images\打牌.png)

**需求：**

排序前：{4,3,2,10,12,1,5,6}

排序后：{1,2,3,4,5,6,10,12}

**排序原理：**

1. 把所有的元素分为两组，已经排序的和未排序的；

2. 找到未排序的组中的第一个元素，向已经排序的组中进行插入；

3. 倒序遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待插入元素放到这个位置，其他的元素向后移动一位；

![](.\images\插入排序.png)

**插入排序API设计：**

| **类名** | **Insertion**                                                |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Insertion()：创建Insertion对象                               |
| 成员方法 | 1. public static void sort(Comparable[] a)：对数组内的元素进行排序<br />2. private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br />3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

 **插入排序代码实现：**

```java
public class Insertion {
    /*
       对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        // 8个元素，排序 7 次
        // 第 1 次排序，有序列表中有 1 个元素参与比较
        // 第 2 次排序，有序列表中有 2 个元素参与比较
        // ...
        // 外层循环控制排序次数，内层循环控制比较次数
        for(int i=1;i<a.length;i++){
            System.out.println(i);
            for(int j=i;j>0;j--){
                //比较索引j处的值和索引j-1处的值，如果索引j-1处的值比索引j处的值大，则交换数据，如果不大，那么就找到合适的位置了，退出循环即可；
                if (greater(a[j-1],a[j])){
                    exch(a,j-1,j);
                }else{
                    break;
                }
            }

        }
    }

    /*
        比较v元素是否大于w元素
     */
    private static  boolean greater(Comparable v,Comparable w){
        return v.compareTo(w)>0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;
    }
}
```

**插入排序的时间复杂度分析**

插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复  杂度，主要分析一下内层循环体的执行次数即可。

最坏情况，也就是待排序的数组元素为{12,10,6,5,4,3,2,1}，那么： 比较的次数为：

(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;

交换的次数为：

(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;

总执行次数为：

(N^2/2-N/2)+(N^2/2-N/2)=N^2-N;

按照大O推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为O(N^2).

# 高级排序

之前我们学习过基础排序，包括冒泡排序，选择排序还有插入排序，并且对他们在最坏情况下的时间复杂度做了分  析，发现都是O(N^2)，而平方阶通过我们之前学习算法分析我们知道，随着输入规模的增大，时间成本将急剧上   升，所以这些基本排序方法不能处理更大规模的问题，接下来我们学习一些高级的排序算法，争取降低算法的时间  复杂度最高阶次幂。

## 希尔排序

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。

前面学习插入排序的时候，我们会发现一个很不友好的事儿，如果已排序的分组元素为{2,5,7,9,10}，未排序的分组  元素为{1,8}，那么下一个待插入元素为1，我们需要拿着1从后往前，依次和10,9,7,5,2进行交换位置，才能完成真  正的插入，每次交换只能和相邻的元素交换位置。那如果我们要提高效率，直观的想法就是一次交换，能把1放到   更前面的位置，比如一次交换就能把1插到2和5之间，这样一次交换1就向前走了5个位置，可以减少交换的次数，  这样的需求如何实现呢？接下来我们来看看希尔排序的原理。

**需求：**

排序前：{9,1,2,5,7,4,8,6,3,5}

排序后：{1,2,3,4,5,5,6,7,8,9}

**排序原理：**

1. 选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组；
2. 对分好组的每一组数据完成插入排序；
3. 减小增长量，最小减为1，重复第二步操作。

![](.\images\希尔排序.png)

增长量h的确定：增长量h的值每一固定的规则，我们这里采用以下规则：

```java
int h=1
while(h<length/2){//5
	h=2*h+1; //3,7
}
// 循环结束后我们就可以确定h的最大值，h的减小规则为：h=h/2
```

**希尔排序的API设计：**

| **类名** | **Shell**                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Shell()：创建Shell对象                                       |
| 成员方法 | 1.public static void sort(Comparable[] a)：对数组内的元素进行排序<br />2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br />3.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |

**希尔排序的代码实现：**

```java
public class Shell {
    /*
       对数组a中的元素进行排序
    */
    public static void sort(Comparable[] a){
        //1.根据数组a的长度，确定增长量h的初始值；
        int h = 1;
        while(h<a.length/2){
            h=2*h+1;
        }
        //2.希尔排序
        while(h>=1){
            //排序
            //2.1.找到待插入的元素
            for (int i=h;i<a.length;i++){
                //2.2把待插入的元素插入到有序数列中
                for (int j=i;j>=h;j-=h){

                    //待插入的元素是a[j],比较a[j]和a[j-h]
                    if (greater(a[j-h],a[j])){
                        //交换元素
                        exch(a,j-h,j);
                    }else{
                        //待插入元素已经找到了合适的位置，结束循环；
                        break;
                    }
                }

            }
            //减小h的值
            h= h/2;
        }

    }

    /*
        比较v元素是否大于w元素
     */
    private static  boolean greater(Comparable v,Comparable w){
        return v.compareTo(w)>0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a,int i,int j){
        Comparable temp;
        temp = a[i];
        a[i]=a[j];
        a[j]=temp;
    }
}
```

**希尔排序的时间复杂度分析**

在希尔排序中，增长量h并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最好的，对于希尔排序的时间复杂度分析，已经超出了我们课程设计的范畴，所以在这里就不做分析了。

我们可以使用事后分析法对希尔排序和插入排序做性能比较。

在资料的测试数据文件夹下有一个reverse_shell_insertion.txt文件，里面存放的是从100000到1的逆向数据，我们  可以根据这个批量数据完成测试。测试的思想：在执行排序前前记录一个时间，在排序完成后记录一个时间，两个  时间的时间差就是排序的耗时。

**希尔排序和插入排序性能比较测试代码：**

```java
public class SortCompare {
    //调用不同的测试方法，完成测试
    public static void main(String[] args) throws Exception{
        //1.创建一个ArrayList集合，保存读取出来的整数
        ArrayList<Integer> list = new ArrayList<>();

        //2.创建缓存读取流BufferedReader，读取数据，并存储到ArrayList中；
        BufferedReader reader = new BufferedReader(new InputStreamReader(SortCompare.class.getClassLoader().getResourceAsStream("reverse_arr.txt")));
        String line=null;
        while((line=reader.readLine())!=null){
            //line是字符串，把line转换成Integer，存储到集合中
            int i = Integer.parseInt(line);
            list.add(i);
        }

        reader.close();


        //3.把ArrayList集合转换成数组
        Integer[] a = new Integer[list.size()];
        list.toArray(a);
        //4.调用测试代码完成测试
        //testInsertion(a);//37499毫秒
        testShell(a);//30毫秒
    }

    //测试希尔排序
    public static void testShell(Integer[] a){
        //1.获取执行之前的时间
        long start = System.currentTimeMillis();
        //2.执行算法代码
        Shell.sort(a);
        //3.获取执行之后的时间
        long end = System.currentTimeMillis();
        //4.算出程序执行的时间并输出
        System.out.println("希尔排序执行的时间为："+(end-start)+"毫秒");

    }

    //测试插入排序
    public static void testInsertion(Integer[] a){
        //1.获取执行之前的时间
        long start = System.currentTimeMillis();
        //2.执行算法代码
        Insertion.sort(a);
        //3.获取执行之后的时间
        long end = System.currentTimeMillis();
        //4.算出程序执行的时间并输出
        System.out.println("插入排序执行的时间为："+(end-start)+"毫秒");
    }
}
```

通过测试发现，在处理大批量数据时，希尔排序的性能确实高于插入排序。

## 归并排序

### 递归

正式学习归并排序之前，我们得先学习一下递归算法。

**定义：**

定义方法时，在方法内部调用方法本身，称之为递归.

```java
public void show(){
	System.out.println("aaaa");
	show(); 
}
```

**作用：**

它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的  程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。

**注意事项：**

在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟  新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出。

![](.\images\递归调用.png)

**需求：**

请定义一个方法，使用递归完成求N的阶乘；

```
分析：
1!:		1
2!:		2*1=2*1!
3!:		3*2*1=3*2!
4!:		4*3*2*1=4*3!
...
n!:		n*(n-1)*(n-2)...*2*1=n*(n-1)!

所以，假设有一个方法factorial(n)用来求n的阶乘，那么n的阶乘还可以表示为n*factorial(n-1)
```

**代码实现：**

```java
public class Test {
    public static void main(String[] args) throws Exception { 
        int result = factorial(5); 
        System.out.println(result);
    }
    public static int factorial(int n){
        if (n==1){
            return 1;
        }
        return n*factorial(n-1);
    }
}
```

### 归并排序

归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子  序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序  表，称为二路归并。

**需求：**

排序前：{8,4,5,7,1,3,6,2}

排序后：{1,2,3,4,5,6,7,8}

**排序原理：**

1. 尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。
2. 将相邻的两个子组进行合并成一个有序的大组；
3. 不断的重复步骤2，直到最终只有一个组为止。

![](.\images\归并排序排序前后数据对比.png)

**归并排序API设计：**

 

| **类名** | **Merge**                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Merge()：创建Merge对象                                       |
| 成员方法 | 1. public static void sort(Comparable[] a)：对数组内的元素进行排序<br />2. private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序<br />3. private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到索引mid为一个子组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组（从  索引lo到索引hi）<br />4. private static boolean less(Comparable v,Comparable w):判断v是否小于w<br />5. private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |
| 成员变量 | 1.private static Comparable[] assist：完成归并操作需要的辅助数组 |

**归并原理：**

![](.\images\归并原理1.png)

![](.\images\归并原理2.png)

![](.\images\归并原理3.png)

**归并排序代码实现：**

```java
public class Merge {
    //归并所需要的辅助数组
    private static Comparable[] assist;

    /*
       比较v元素是否小于w元素
    */
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w)<0;
    }

    /*
    数组元素i和j交换位置
     */
    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }


    /*
           对数组a中的元素进行排序
        */
    public static void sort(Comparable[] a) {
        //1.初始化辅助数组assist；
        assist = new Comparable[a.length];
        //2.定义一个lo变量，和hi变量，分别记录数组中最小的索引和最大的索引；
        int lo=0;
        int hi=a.length-1;
        //3.调用sort重载方法完成数组a中，从索引lo到索引hi的元素的排序
        sort(a,lo,hi);
    }

    /*
    对数组a中从lo到hi的元素进行排序
     */
    private static void sort(Comparable[] a, int lo, int hi) {
        //做安全性校验；
        if (hi<=lo){
            return;
        }

        //对lo到hi之间的数据进行分为两个组
        int mid = lo+(hi-lo)/2;//   5,9  mid=7

        //分别对每一组数据进行排序
        sort(a,lo,mid);
        sort(a,mid+1,hi);

        //再把两个组中的数据进行归并
        merge(a,lo,mid,hi);
    }

    /*
    对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并
     */
    private static void merge(Comparable[] a, int lo, int mid, int hi) {
        //定义三个指针
        int i=lo;
        int p1=lo;
        int p2=mid+1;

        //遍历，移动p1指针和p2指针，比较对应索引处的值，找出小的那个，放到辅助数组的对应索引处
        while(p1<=mid && p2<=hi){
            //比较对应索引处的值
            if (less(a[p1],a[p2])){
                assist[i++] = a[p1++];
            }else{
                assist[i++]=a[p2++];
            }
        }

        //遍历，如果p1的指针没有走完，那么顺序移动p1指针，把对应的元素放到辅助数组的对应索引处
        while(p1<=mid){
            assist[i++]=a[p1++];
        }
        //遍历，如果p2的指针没有走完，那么顺序移动p2指针，把对应的元素放到辅助数组的对应索引处
        while(p2<=hi){
            assist[i++]=a[p2++];
        }
        //把辅助数组中的元素拷贝到原数组中
        for(int index=lo;index<=hi;index++){
            a[index]=assist[index];
        }

    }

}
```

**归并排序时间复杂度分析：**

归并排序是分治思想的最典型的例子，上面的算法中，对a[lo...hi]进行排序，先将它分为a[lo...mid]和a[mid+1...hi]  两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果  一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。

![](.\images\归并排序时间复杂度分析.png)

用树状图来描述归并，如果一个数组有8个元素，那么它将每次除以2找最小的子数组，共拆log8次，值为3，所以  树共有3层,那么自顶向下第k层有2^k个子数组，每个数组的长度为2^(3-k)，每个数组归并最多需要2^(3-k)次比较。因此每层  的比较次数为 2^k * 2^(3-k)=2^3,那么3层总共为 3*2^3。

假设元素的个数为n，那么使用归并排序拆分的次数为log2(n),所以共log2(n)层，那么使用log2(n)替换上面3 * 2^3中  的3这个层数，最终得出的归并排序的时间复杂度为：log2(n)*   2^(log2(n))=log2(n)*n,根据大O推导法则，忽略底数，最终归并排序的时间复杂度为O(nlogn);

**归并排序的缺点：**

需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。 

**归并排序与希尔排序性能测试：**

之前我们通过测试可以知道希尔排序的性能是由于插入排序的，那现在学习了归并排序后，归并排序的效率与希尔  排序的效率哪个高呢？我们使用同样的测试方式来完成一样这两个排序算法之间的性能比较。

在资料的测试数据文件夹下有一个reverse_arr.txt文件，里面存放的是从1000000到1的逆向数据，我们可以根据   这个批量数据完成测试。测试的思想：在执行排序前前记录一个时间，在排序完成后记录一个时间，两个时间的时  间差就是排序的耗时。

**希尔排序和插入排序性能比较测试代码：**

```java
public class SortCompare {
    //调用不同的测试方法，完成测试
    public static void main(String[] args) throws Exception{
        //1.创建一个ArrayList集合，保存读取出来的整数
        ArrayList<Integer> list = new ArrayList<>();

        //2.创建缓存读取流BufferedReader，读取数据，并存储到ArrayList中；
        BufferedReader reader = new BufferedReader(new InputStreamReader(SortCompare.class.getClassLoader().getResourceAsStream("reverse_arr.txt")));
        String line=null;
        while((line=reader.readLine())!=null){
            //line是字符串，把line转换成Integer，存储到集合中
            int i = Integer.parseInt(line);
            list.add(i);
        }

        reader.close();


        //3.把ArrayList集合转换成数组
        Integer[] a = new Integer[list.size()];
        list.toArray(a);
        //4.调用测试代码完成测试
        //testMerge(arr);//使用归并排序耗时：1200 
        testShell(arr);//使用希尔排序耗时：1277

    }

    //测试希尔排序
    public static void testShell(Integer[] a){
        //1.获取执行之前的时间
        long start = System.currentTimeMillis();
        //2.执行算法代码
        Shell.sort(a);
        //3.获取执行之后的时间
        long end = System.currentTimeMillis();
        //4.算出程序执行的时间并输出
        System.out.println("希尔排序执行的时间为："+(end-start)+"毫秒");

    }

    //测试归并排序
    public static void testMerge(Integer[] a){
        //1.获取执行之前的时间
        long start = System.currentTimeMillis();
        //2.执行算法代码
        Merge.sort(a);
        //3.获取执行之后的时间
        long end = System.currentTimeMillis();
        //4.算出程序执行的时间并输出
        System.out.println("归并排序执行的时间为："+(end-start)+"毫秒");
    }

}
```

通过测试，发现希尔排序和归并排序在处理大批量数据时差别不是很大。

## 快速排序

快速排序是对冒泡排序的一种改进。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

**需求：**

排序前:{6, 1, 2, 7, 9, 3, 4, 5, 8}

排序后:{1, 2, 3, 4, 5, 6, 7, 8, 9}

**排序原理：**

1. 首先设定一个分界值，通过该分界值将数组分成左右两部分；
2. 将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于  或等于分界值，而右边部分中各元素都大于或等于分界值；
3. 然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两  部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。
4. 重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当  左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。

![](.\images\快速排序排序原理.png)

**快速排序API设计**

| **类名** | **Quick**                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Quick()：创建Quick对象                                       |
| 成员方法 | 1. public static void sort(Comparable[] a)：对数组内的元素进行排序<br />2. private static void sort(Comparable[] a, int lo, int hi)：对数组a中从索引lo到索引hi之间的元素进行排序<br />3. public static int partition(Comparable[] a,int lo,int hi):对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引<br />4. private static boolean less(Comparable v,Comparable w):判断v是否小于w<br />5.private static void exch(Comparable[] a,int i,int j)：交换a数组中，索引i和索引j处的值 |



**切分原理：**

把一个数组切分成两个子数组的基本思想：

1. 找一个基准值，用两个指针分别指向数组的头部和尾部；
2. 先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置；
3. 再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置；
4. 交换当前左边指针位置和右边指针位置的元素；
5. 重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。

![](.\images\快速排序切分原理.png)

![](.\images\快速排序切分原理2.png)

**快速排序代码实现：**

```java
public class Quick {
    /*
      比较v元素是否小于w元素
   */
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }



    /*
   数组元素i和j交换位置
    */
    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    //对数组内的元素进行排序
    public static void sort(Comparable[] a) {
        int lo = 0;
        int hi = a.length-1;
        sort(a,lo,hi);
    }

    //对数组a中从索引lo到索引hi之间的元素进行排序
    private static void sort(Comparable[] a, int lo, int hi) {
        //安全性校验
        if (hi<=lo){
            return;
        }

        //需要对数组中lo索引到hi索引处的元素进行分组（左子组和右子组）；
        int partition = partition(a, lo, hi);//返回的是分组的分界值所在的索引，分界值位置变换后的索引

        //让左子组有序
        sort(a,lo,partition-1);

        //让右子组有序
        sort(a,partition+1,hi);
    }

    //对数组a中，从索引 lo到索引 hi之间的元素进行分组，并返回分组界限对应的索引
    public static int partition(Comparable[] a, int lo, int hi) {
       //确定分界值
        Comparable key = a[lo];
        //定义两个指针，分别指向待切分元素的最小索引处和最大索引处的下一个位置
        int left=lo;
        int right=hi+1;

        //切分
        while(true){
            //先从右往左扫描，移动right指针，找到一个比分界值小的元素，停止
            while(less(key,a[--right])){
                if (right==lo){
                    break;
                }
            }

            //再从左往右扫描，移动left指针，找到一个比分界值大的元素，停止
            while(less(a[++left],key)){
                if (left==hi){
                    break;
                }
            }
            //判断 left>=right,如果是，则证明元素扫描完毕，结束循环，如果不是，则交换元素即可
            if (left>=right){
                break;
            }else{
                exch(a,left,right);
            }
        }

        //交换分界值
        exch(a,lo,right);

       return right;
    }

}
```

**快速排序和归并排序的区别：**

快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序  是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的  方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在  处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。

**快速排序时间复杂度分析：**

快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为O(n),但整个  快速排序的时间复杂度和切分的次数相关。

最优情况：每一次切分选择的基准数字刚好将当前序列等分。

![](.\images\快速排序最优情况.png)

如果我们把数组的切分看做是一个树，那么上图就是它的最优情况的图示，共切分了logn次，所以，最优情况下快  速排序的时间复杂度为O(nlogn);

最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总  共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2);

![](.\images\快速排序最差情况.png)

平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证    明，快速排序的时间复杂度为O(nlogn),由于数学归纳法有很多数学相关的知识，容易使我们混乱，所以这里就不对  平均情况的时间复杂度做证明了。

## 排序的稳定性

**稳定性的定义：**

数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保  证A元素依然在B元素的前面，可以说这个该算法是稳定的。

![](.\images\稳定性的定义.png)

**稳定性的意义：**

如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例  如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第  二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需  要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。

 

第一次按照价格从低到高排序：

| **商品名称** | **价格** | **销量** |
| ------------ | -------- | -------- |
| 三星Note9    | 3999     | 21       |
| 华为mate30   | 4999     | 65       |
| 华为p30      | 5999     | 65       |
| Iphone 11    | 6899     | 32       |

 

第二次按照销量进行从高到低排序：

| **商品名称** | **价格** | **销量** |
| ------------ | -------- | -------- |
| 华为mate30   | 4999     | 65       |
| 华为p30      | 5999     | 65       |
| Iphone 11    | 6899     | 32       |
| 三星Note9    | 3999     | 21       |

 

**常见排序算法的稳定性：** 

冒泡排序：

只有当arr[i]>arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种稳定排序  算法。

选择排序:

选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2， 所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种不稳定的排序算法。

插入排序：

比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其  后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等  元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序  是稳定的。

希尔排序：

希尔排序是按照不同步长对元素进行插入排序  ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不  稳定的。

归并排序：

归并排序在归并的过程中，只有arr[i]<arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它  并不会破坏稳定性，归并排序是稳定的。

快速排序：

快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素，  然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种不稳定的算法。

# 线性表

线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。

![](.\images\线性表.png)

前驱元素：

若A元素在B元素的前面，则称A为B的前驱元素

后继元素：

若B元素在A元素的后面，则称B为A的后继元素

**线性表的特征：**数据元素之间具有一种“一对一”的逻辑关系。

- 第一个数据元素没有前驱，这个数据元素被称为头结点；
- 最后一个数据元素没有后继，这个数据元素被称为尾结点；
- 除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。

如果把线性表用数学语言来定义，则可以表示为(a1,...ai-1,ai,ai+1,...an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的  前驱元素，ai+1是ai的后继元素

![](.\images\线性表数学定义.png)

**线性表的分类：**

线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。

## 顺序表

顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存  储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。

![](.\images\顺序表.png)

### 顺序表的实现

**顺序表 API设计：**

| **类名** | **SequenceList**                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | SequenceList(int capacity)：创建容量为capacity的SequenceList对象 |
| 成员方法 | 1. public void clear()：空置线性表<br />2. public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false <br />3.public int length():获取线性表中元素的个数<br />4. public T get(int i):读取并返回线性表中的第i个元素的值<br />5. public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br />6.public void insert(T t):向线性表中添加一个元素t<br />7. public T remove(int i):删除并返回线性表中第i个数据元素。<br />8. public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。 |
| 成员变量 | 1.private T[] eles：存储元素的数组<br />2.private int N:当前线性表的长度 |

**顺序表的代码实现：**

```java
public class SequenceList<T>{
    //存储元素的数组
    private T[] eles;
    //记录当前顺序表中的元素个数
    private int N;

    //构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles=(T[])new Object[capacity];
        //初始化长度
        this.N=0;
    }

    //将一个线性表置为空表
    public void clear(){
        this.N=0;
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
       return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线型表中添加元素t
    public void insert(T t){
        if (N==eles.length){
            resize(2*eles.length);
        }

        eles[N++]=t;
    }

    //在i元素处插入元素t
    public void insert(int i,T t){        
        //先把i索引处的元素及其后面的元素依次向后移动一位
        for(int index=N;index>i;index--){
            eles[index]=eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i]=t;

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];
        //索引i后面元素依次向前移动一位即可
        for(int index=i;index<N-1;index++){
            eles[index]=eles[index+1];
        }
        //元素个数-1
        N--;
        return current;
    }


    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for(int i=0;i<N;i++){
            if (eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }
}

public class SequenceListTest {

    public static void main(String[] args) {
        //创建顺序表对象
        SequenceList<String> sl = new SequenceList<>(10);
        //测试插入
        sl.insert("姚明");
        sl.insert("科比");
        sl.insert("麦迪");
        sl.insert(1,"詹姆斯");

        //测试获取
        String getResult = sl.get(1);
        System.out.println("获取索引1处的结果为："+getResult);
        //测试删除
        String removeResult = sl.remove(0);
        System.out.println("删除的元素是："+removeResult);
        //测试清空
        sl.clear();
        System.out.println("清空后的线性表中的元素个数为:"+sl.length());
    }
}
```

### 顺序表的遍历

一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。

在 Java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则需要做如下操作：

1. 让SequenceList实现Iterable接口，重写iterator方法；

2. 在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法； 

代码：

```java
public class SequenceList<T> implements Iterable<T>{
    //存储元素的数组
    private T[] eles;
    //记录当前顺序表中的元素个数
    private int N;

    //构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles=(T[])new Object[capacity];
        //初始化长度
        this.N=0;
    }

    //将一个线性表置为空表
    public void clear(){
        this.N=0;
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
       return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线型表中添加元素t
    public void insert(T t){
        eles[N++]=t;
    }

    //在i元素处插入元素t
    public void insert(int i,T t){
        //先把i索引处的元素及其后面的元素依次向后移动一位
        for(int index=N;index>i;index--){
            eles[index]=eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i]=t;

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];
        //索引i后面元素依次向前移动一位即可
        for(int index=i;index<N-1;index++){
            eles[index]=eles[index+1];
        }
        //元素个数-1
        N--;
        return current;
    }


    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for(int i=0;i<N;i++){
            if (eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }


    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{
        private int cusor;
        public SIterator(){
            this.cusor=0;
        }
        @Override
        public boolean hasNext() {
            return cusor<N;
        }

        @Override
        public Object next() {
            return eles[cusor++];
        }
    }
}

public class SequenceListTest {

    public static void main(String[] args) {
        //创建顺序表对象
        SequenceList<String> sl = new SequenceList<>(10);
        //测试插入
        sl.insert("姚明");
        sl.insert("科比");
        sl.insert("麦迪");
        sl.insert(1,"詹姆斯");

        for (String s : sl) {
            System.out.println(s);
        }
    }
}
```

### 顺序表的容量可变

在之前的实现中，当我们使用SequenceList时，先new  SequenceList(5)创建一个对象，创建对象时就需要指定容器的大小，初始化指定大小的数组来存储元素，当我们插入元素时，如果已经插入了5个元素，还要继续插入数据，则会报错，就不能插入了。这种设计不符合容器的设计理念，因此我们在设计顺序表时，应该考虑它的容量的伸缩性。

考虑容器的容量伸缩性，其实就是改变存储数据元素的数组的大小，那我们需要考虑什么时候需要改变数组的大小？

1. 添加元素时：

添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我  们这里创建一个是原数组两倍容量的新数组存储元素。

![](.\images\顺序表容量可变-添加元素时.png)

2. 移除元素时：

移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存  空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建   一个是原数组容量的1/2的新数组存储元素。

![](.\images\顺序表容量可变-移除元素时.png)

**顺序表的容量可变代码：**

```java
public class SequenceList<T> implements Iterable<T>{
    //存储元素的数组
    private T[] eles;
    //记录当前顺序表中的元素个数
    private int N;

    //构造方法
    public SequenceList(int capacity){
        //初始化数组
        this.eles=(T[])new Object[capacity];
        //初始化长度
        this.N=0;
    }

    //将一个线性表置为空表
    public void clear(){
        this.N=0;
    }

    //判断当前线性表是否为空表
    public boolean isEmpty(){
       return N==0;
    }

    //获取线性表的长度
    public int length(){
        return N;
    }

    //获取指定位置的元素
    public T get(int i){
        return eles[i];
    }

    //向线型表中添加元素t
    public void insert(T t){
        if (N==eles.length){
            resize(2*eles.length);
        }

        eles[N++]=t;
    }

    //在i元素处插入元素t
    public void insert(int i,T t){
        if (N==eles.length){
            resize(2*eles.length);
        }

        //先把i索引处的元素及其后面的元素依次向后移动一位
        for(int index=N;index>i;index--){
            eles[index]=eles[index-1];
        }
        //再把t元素放到i索引处即可
        eles[i]=t;

        //元素个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回该元素
    public T remove(int i){
        //记录索引i处的值
        T current = eles[i];
        //索引i后面元素依次向前移动一位即可
        for(int index=i;index<N-1;index++){
            eles[index]=eles[index+1];
        }
        //元素个数-1
        N--;

        if (N<eles.length/4){
            resize(eles.length/2);
        }

        return current;
    }


    //查找t元素第一次出现的位置
    public int indexOf(T t){
        for(int i=0;i<N;i++){
            if (eles[i].equals(t)){
                return i;
            }
        }
        return -1;
    }

    //根据参数newSize，重置eles的大小
    public void resize(int newSize){
        //定义一个临时数组，指向原数组
        T[] temp=eles;
        //创建新数组
        eles=(T[])new Object[newSize];
        //把原数组的数据拷贝到新数组即可
        for(int i=0;i<N;i++){
            eles[i]=temp[i];
        }
    }
    
    public int capacity(){ 
        return eles.length;
	}

    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{
        private int cusor;
        public SIterator(){
            this.cusor=0;
        }
        @Override
        public boolean hasNext() {
            return cusor<N;
        }

        @Override
        public Object next() {
            return eles[cusor++];
        }
    }
}

public class SequenceListTest {

    public static void main(String[] args) {
        //创建顺序表对象
        SequenceList<String> sl = new SequenceList<>(5);
        //测试插入
        squence.insert(0, "姚明");
        squence.insert(1, "科比");
        squence.insert(2, "麦迪");
        squence.insert(3, "艾佛森");
        squence.insert(4, "卡特");
		System.out.println(squence.capacity());

		squence.insert(5,"aa");
        System.out.println(squence.capacity());
    }
}
```

### 顺序表的时间复杂度

get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);

insert(int  i,T  t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时间复杂为O(n);

remove(int  i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复杂度为O(n);

由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺  序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显

### Java 中 ArrayList 实现

Java 中 ArrayList 集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。  

1. 是否用数组实现；

2. 有没有扩容操作；

3. 有没有提供遍历方式；

## 链表

之前我们已经使用顺序存储结构实现了线性表，我们会发现虽然顺序表的查询很快，时间复杂度为O(1),但是增删的  效率是比较低的，因为每一次增删操作都伴随着大量的数据元素移动。这个问题有没有解决方案呢？有，我们可以  使用另外一种存储结构实现线性表，链式存储结构。

链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能直观的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点（链表中的每一个元素称为结点）组成，  结点可以在运行时动态生成。

![](.\images\链表.png)

那我们如何使用链表呢？按照面向对象的思想，我们可以设计一个类，来描述结点这个事物，用一个属性描述这个  结点存储的元素，用来另外一个属性描述这个结点的下一个结点。

**结点 API设计：**

| **类名** | **Node**                                       |
| -------- | ---------------------------------------------- |
| 构造方法 | Node(T t,Node next)：创建Node对象              |
| 成员变量 | T item:存储数据Node <br />next：指向下一个结点 |

**结点类实现：**

```java
//结点类
public class Node {
    //存储数据
    T item;
    //下一个结点
    Node next;

    public Node(T item, Node next) {
        this.item = item;
        this.next = next;
    }
}
```

**生成链表：**

```java
public static void main(String[] args) throws Exception {
	//构建结点
	Node<Integer> first = new Node<Integer>(11, null); 
    Node<Integer> second = new Node<Integer>(13, null); 
    Node<Integer> third = new Node<Integer>(12, null); 
    Node<Integer> fourth = new Node<Integer>(8, null);
	Node<Integer> fifth = new Node<Integer>(9, null);
    //生成链表
	first.next = second; 
    second.next = third; 
    third.next = fourth;
	fourth.next = fifth;
}   
```

### 单向链表

单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，  指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。

![](.\images\单向链表.png)

**单向链表 API 设计**

| **类名**   | **LinkList**                                                 |
| ---------- | ------------------------------------------------------------ |
| 构造方法   | LinkList()：创建LinkList对象                                 |
| 成员方法   | 1.public void clear()：空置线性表<br />2.public boolean isEmpty()：判断线性表是否为空，是返回true，否返回false <br />3.public int length():获取线性表中元素的个数<br />4.public T get(int i):读取并返回线性表中的第i个元素的值<br />5.public void insert(T t)：往线性表中添加一个元素；<br />6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br />7.public T remove(int i):删除并返回线性表中第i个数据元素。<br />8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。 |
| 成员内部类 | private class Node:结点类                                    |
| 成员变量   | 1.private Node head:记录首结点<br />2.private int N:记录链表的长度 |

**单向链表代码实现**

```java
public class LinkList<T> implements Iterable<T>{
    //记录头结点
    private Node head;
    //记录链表的长度
    private int N;



    //结点类
    private class Node {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public LinkList() {
        //初始化头结点、
        this.head = new Node(null,null);
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear() {
        head.next=null;
        this.N=0;
    }

    //获取链表的长度
    public int length() {
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //获取指定位置i出的元素
    public T get(int i) {

        //通过循环,从头结点开始往后找，依次找i次，就可以找到对应的元素
        Node n = head.next;
        for(int index=0;index<i;index++){
            n=n.next;
        }

        return n.item;
    }

    //向链表中添加元素t
    public void insert(T t) {
        //找到当前最后一个结点

        Node n = head;
        while(n.next!=null){
            n=n.next;
        }


        //创建新结点，保存元素t
        Node newNode = new Node(t, null);
        //让当前最后一个结点指向新结点
        n.next=newNode;
        //元素的个数+1
        N++;
    }

    //向指定位置i出，添加元素t
    public void insert(int i, T t) {
        //找到i位置前一个结点
        Node pre = head;
        for(int index=0;index<=i-1;index++){
            pre=pre.next;
        }

        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点，并且新结点需要指向原来i位置的结点
        Node newNode = new Node(t, curr);
        //原来i位置的前一个节点指向新结点即可
        pre.next=newNode;
        //元素的个数+1
        N++;
    }

    //删除指定位置i处的元素，并返回被删除的元素
    public T remove(int i) {
        //找到i位置的前一个节点
        Node pre = head;
        for(int index=0;index<=i-1;i++){
            pre=pre.next;
        }
        //要找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode = curr.next;
        //前一个结点指向下一个结点
        pre.next=nextNode;
        //元素个数-1
        N--;
        return curr.item;
    }

    //查找元素t在链表中第一次出现的位置
    public int indexOf(T t) {
        //从头结点开始，依次找到每一个结点，取出item，和t比较，如果相同，就找到了
        Node n = head;
        for(int i=0;n.next!=null;i++){
            n=n.next;
            if (n.item.equals(t)){
                return i;
            }
        }
        return -1;
    }


    @Override
    public Iterator<T> iterator() {
        return new LIterator();
    }

    private class LIterator implements Iterator{
        private Node n;
        public LIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }

    //用来反转整个链表
    public void reverse(){

        //判断当前链表是否为空链表，如果是空链表，则结束运行，如果不是，则调用重载的reverse方法完成反转
        if (isEmpty()){
            return;
        }

        reverse(head.next);
    }

    //反转指定的结点curr，并把反转后的结点返回
    public Node reverse(Node curr){
        if (curr.next==null){
            head.next=curr;
            return curr;
        }
        //递归的反转当前结点curr的下一个结点；返回值就是链表反转后，当前结点的上一个结点
        Node pre = reverse(curr.next);
        //让返回的结点的下一个结点变为当前结点curr；
        pre.next=curr;
        //把当前结点的下一个结点变为null
        curr.next=null;
        return curr;
    }
}
```

### 双向链表

双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。

![](.\images\双向链表.png)

按照面向对象的思想，我们需要设计一个类，来描述结点这个事物。由于结点是属于链表的，所以我们把结点类作为链表类的一个内部类来实现

**结点 API 设计**

| **类名** | **Node**                                                     |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(T t,Node pre,Node next)：创建Node对象                   |
| 成员变量 | T item:存储数据Node next：指向下一个结点Node pre:指向上一个结点 |

**双向链表 API 设计**

| **类名**   | **TowWayLinkList**                                           |
| ---------- | ------------------------------------------------------------ |
| 构造方法   | TowWayLinkList()：创建TowWayLinkList对象                     |
| 成员方法   | 1. public void clear()：空置线性表<br />2. publicboolean isEmpty()：判断线性表是否为空，是返回true，否返回false <br />3.public int length():获取线性表中元素的个数<br />4.public T get(int i):读取并返回线性表中的第i个元素的值<br />5.public void insert(T t)：往线性表中添加一个元素；<br />6.public void insert(int i,T t)：在线性表的第i个元素之前插入一个值为t的数据元素。<br />7.public T remove(int i):删除并返回线性表中第i个数据元素。<br />8. public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。<br />9. public T getFirst():获取第一个元素<br />10.public T getLast():获取最后一个元素 |
| 成员内部类 | private class Node:结点类                                    |
| 成员变量   | 1.private Node ﬁrst:记录首结点<br />2.private Node last:记录尾结点<br />3.private int N:记录链表的长度 |

**双向链表代码实现**

```java
public class TowWayLinkList<T> implements Iterable<T> {
    //首结点
    private Node head;
    //最后一个结点
    private Node last;

    //链表的长度
    private int N;



    //结点类
    private class Node{
        public Node(T item, Node pre, Node next) {
            this.item = item;
            this.pre = pre;
            this.next = next;
        }

        //存储数据
        public T item;
        //指向上一个结点
        public Node pre;
        //指向下一个结点
        public Node next;
    }

    public TowWayLinkList() {
       //初始化头结点和尾结点
        this.head = new Node(null,null,null);
        this.last=null;
        //初始化元素个数
        this.N=0;
    }

    //清空链表
    public void clear(){
        this.head.next=null;
        this.head.pre=null;
        this.head.item=null;
        this.last=null;
        this.N=0;
    }

    //获取链表长度
    public int length(){
        return N;
    }

    //判断链表是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //获取第一个元素
    public T getFirst(){
        if (isEmpty()){
            return null;
        }
        return head.next.item;
    }

    //获取最后一个元素
    public T getLast(){
        if (isEmpty()){
            return null;
        }
        return last.item;
    }

    //插入元素t
    public void insert(T t){

        if (isEmpty()){
            //如果链表为空：

            //创建新的结点
            Node newNode = new Node(t,head, null);
            //让新结点称为尾结点
            last=newNode;
            //让头结点指向尾结点
            head.next=last;
        }else {
            //如果链表不为空
            Node oldLast = last;

            //创建新的结点
            Node newNode = new Node(t, oldLast, null);

            //让当前的尾结点指向新结点
            oldLast.next=newNode;
            //让新结点称为尾结点
            last = newNode;
        }

        //元素个数+1
        N++;

    }

    //向指定位置i处插入元素t
    public void insert(int i,T t){
        //找到i位置的前一个结点
        Node pre = head;
        for(int index=0;index<i;index++){
            pre=pre.next;
        }
        //找到i位置的结点
        Node curr = pre.next;
        //创建新结点
        Node newNode = new Node(t, pre, curr);
        //让i位置的前一个结点的下一个结点变为新结点
        pre.next=newNode;
        //让i位置的前一个结点变为新结点
        curr.pre=newNode;
        //元素个数+1
        N++;
    }

    //获取指定位置i处的元素
    public T get(int i){
        Node n = head.next;
        for(int index=0;index<i;index++){
            n=n.next;
        }
        return n.item;
    }

    //找到元素t在链表中第一次出现的位置
    public int indexOf(T t){
        Node n = head;
        for(int i=0;n.next!=null;i++){
            n=n.next;
            if (n.next.equals(t)){
                return i;
            }
        }
        return -1;
    }

    //删除位置i处的元素，并返回该元素
    public T remove(int i){
        //找到i位置的前一个结点
        Node pre = head;
        for(int index=0;index<i;index++){
            pre=pre.next;
        }
        //找到i位置的结点
        Node curr = pre.next;
        //找到i位置的下一个结点
        Node nextNode= curr.next;
        //让i位置的前一个结点的下一个结点变为i位置的下一个结点
        pre.next=nextNode;
        //让i位置的下一个结点的上一个结点变为i位置的前一个结点
        nextNode.pre=pre;
        //元素的个数-1
        N--;
        return curr.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new TIterator();
    }

    private class TIterator implements Iterator{
        private Node n;
        public TIterator(){
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n=n.next;
            return n.item;
        }
    }

}
```

**Java 中 LinkedList 实现**

Java 中 LinkedList 集合也是使用双向链表实现，并提供了增删改查等相关方法 
1.底层是否用双向链表实现；

2.结点类是否有三个域

### 链表的复杂度分析

get(int  i):每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为O(n)

insert(int  i,T  t):每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n);

remove(int  i):每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n)

相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，  它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,,同时它并没有涉及的元素的交换。

相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删  操作比较多，建议使用链表。

### 链表反转

单链表的反转，是面试中的一个高频题目。
**需求：**

原链表中数据为：1->2->3>4

反转后链表中数据为：4->3->2->1

**反转 API：**

public void reverse()：对整个链表反转

public Node reverse(Node curr)：反转链表中的某个结点curr,并把反转后的curr结点返回

使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点，  直到把最后一个结点反转完毕，整个链表就反转完毕。

![](.\images\链表反转.png)

```java
//用来反转整个链表
public void reverse(){

    //判断当前链表是否为空链表，如果是空链表，则结束运行，如果不是，则调用重载的reverse方法完成反转
    if (isEmpty()){
        return;
    }

    reverse(head.next);
}

//反转指定的结点curr，并把反转后的结点返回
public Node reverse(Node curr){
    if (curr.next==null){
        head.next=curr;
        return curr;
    }
    //递归的反转当前结点curr的下一个结点；返回值就是链表反转后，当前结点的上一个结点
    Node pre = reverse(curr.next);
    //让返回的结点的下一个结点变为当前结点curr；
    pre.next=curr;
    //把当前结点的下一个结点变为null
    curr.next=null;
    return curr;
}

//测试代码
public class Test {
    public static void main(String[] args) throws Exception {
        LinkList<Integer> list = new LinkList<>();
        list.insert(1); 
        list.insert(2); 
        list.insert(3); 
        list.insert(4);

        for (Integer i : list) { 
            System.out.print(i+" ");
        }
        System.out.println();
        System.out.println("	");
        list.reverse();
        for (Integer i : list) { 
            System.out.print(i+" ");
        }
    }
}
```

### 快慢指针

快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以让我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍

#### 中间值问题

我们先来看下面一段代码，然后完成需求。

```java
public class FastSlowTest {

    public static void main(String[] args) throws Exception {
        //创建结点
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;

        //查找中间值
        String mid = getMid(first);
        System.out.println("中间值为："+mid);
    }

    /**
     * @param first 链表的首结点
     * @return 链表的中间结点的值
     */
    public static String getMid(Node<String> first) {    
        return null;
    }

    //结点类
    private static class Node<T> {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

**需求：**

请完善测试类Test中的getMid方法，可以找出链表的中间元素值并返回。

利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以 此来达到找到中间节点的目的。

如下图，最开始，slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。

![](.\images\快慢指针.png)



```java
/**
* @param first 链表的首结点
* @return 链表的中间结点的值
*/
public static String getMid(Node<String> first) {
    //定义两个指针
    Node<String> fast = first;
    Node<String> slow = first;
    //使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，结束之后，慢指针指向的结点就是中间值
    while(fast!=null &&fast.next!=null){
        //变化fast的值和slow的值
        fast = fast.next.next;
        slow=slow.next;
    }

    return slow.item;
}
```

#### 单向链表是否有环问题

![](.\images\单向链表是否有环问题.png)

看下面代码，完成需求：

```java
public class CircleListCheckTest {
    public static void main(String[] args) throws Exception {
        //创建结点
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
//        //产生环
//        seven.next = third;

        //判断链表是否有环
        boolean circle = isCircle(first);
        System.out.println("first链表中是否有环："+circle);
    }

    /**
     * 判断链表中是否有环
     * @param first 链表首结点
     * @return ture为有环，false为无环
     */
    public static boolean isCircle(Node<String> first) {      
        return false;
    }

    //结点类
    private static class Node<T> {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

**需求：**

请完善测试类Test中的isCircle方法，返回链表中是否有环。

使用快慢指针的思想，还是把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道  中，两个人有速度差，那么迟早两个人会相遇，只要相遇那么就说明有环。

![](.\images\链表中是否有环1.png)



![](.\images\链表中是否有环2.png)

**代码：**

```java
/**
* 判断链表中是否有环
* @param first 链表首结点
* @return ture为有环，false为无环
*/
public static boolean isCircle(Node<String> first) {
    //定义快慢指针
    Node<String> fast = first;
    Node<String> slow = first;

    //遍历链表，如果快慢指针指向了同一个结点，那么证明有环
    while(fast!=null && fast.next!=null){
        //变换fast和slow
        fast = fast.next.next;
        slow = slow.next;

        if (fast.equals(slow)){
            return true;
        }
    }

    return false;
}
```

#### 有环链表入口问题

同样看下面这段代码，完成需求：

```java
public class CircleListInTest {
    public static void main(String[] args) throws Exception {
        Node<String> first = new Node<String>("aa", null);
        Node<String> second = new Node<String>("bb", null);
        Node<String> third = new Node<String>("cc", null);
        Node<String> fourth = new Node<String>("dd", null);
        Node<String> fifth = new Node<String>("ee", null);
        Node<String> six = new Node<String>("ff", null);
        Node<String> seven = new Node<String>("gg", null);

        //完成结点之间的指向
        first.next = second;
        second.next = third;
        third.next = fourth;
        fourth.next = fifth;
        fifth.next = six;
        six.next = seven;
        //产生环
        seven.next = third;

        //查找环的入口结点
        Node<String> entrance = getEntrance(first);
        System.out.println("first链表中环的入口结点元素为："+entrance.item);
    }

    /**
     * 查找有环链表中环的入口结点
     * @param first 链表首结点
     * @return 环的入口结点
     */
    public static Node getEntrance(Node<String> first) {        
        return null;
    }
    //结点类
    private static class Node<T> {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

**需求：**

请完善Test类中的getEntrance方法，查找有环链表中环的入口结点。

当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样为1，则慢指针与“新”指针相遇的地方就是环的入口。证明这一结论牵涉到数论的知识，这里略，只讲实现。

![](.\images\有环链表入口问题.png)

```java
/**
* 查找有环链表中环的入口结点
* @param first 链表首结点
* @return 环的入口结点
*/
public static Node getEntrance(Node<String> first) {
    //定义快慢指针
    Node<String> fast = first;
    Node<String> slow = first;
    Node<String> temp = null;

    //遍历链表，先找到环(快慢指针相遇),准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时所指向的结点就是环的入口
    while(fast!=null && fast.next!=null){
        //变换快慢指针
        fast = fast.next.next;
        slow = slow.next;

        //判断快慢指针是否相遇
        if (fast.equals(slow)){
            temp = first;
            continue;
        }

        //让临时结点变换
        if (temp!=null){
            temp = temp.next;
            //判断临时指针是否和慢指针相遇
            if (temp.equals(slow)){
                break;
            }
        }
    }

    return temp;
}
```

### 循环链表

循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结  点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。

![](.\images\循环链表.png)

**循环链表的构建：**

```java
public class Test {
    public static void main(String[] args) throws Exception {
        //构建结点
        Node<Integer> first = new Node<Integer>(1, null);
        Node<Integer> second = new Node<Integer>(2, null);
        Node<Integer> third = new Node<Integer>(3, null);
        Node<Integer> fourth = new Node<Integer>(4, null);
        Node<Integer> fifth = new Node<Integer>(5, null);
        Node<Integer> six = new Node<Integer>(6, null);
        Node<Integer> seven = new Node<Integer>(7, null);
        //构建单链表
        first.next = second; 
        second.next = third; 
        third.next = fourth; 
        fourth.next = fifth; 
        fifth.next = six; 
        six.next = seven;
    	//构建循环链表,让最后一个结点指向第一个结点
        seven.next = first;
    }
}
```

### 约瑟夫问题

**问题描述：**

传说有这样一个故事，在罗马人占领乔塔帕特后，39  个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，从而逃过了这场死亡游戏 。

**问题转换：**

41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。

1. 编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈；
2. 自退出那个人开始的下一个人再次从1开始报数，以此类推；
3. 求出最后退出的那个人的编号。

**图示：**

![](.\images\约瑟夫问题.png)

**解题思路：**

1. 构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人；
2. 使用计数器count，记录当前报数的值；
3. 遍历链表，每循环一次，count++；
4. 判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0； 

**代码：**

```java
public class JosephTest {
    public static void main(String[] args) {
        //解决约瑟夫问题

        //1.构建循环链表，包含41个结点，分别存储1~41之间的值
        //用来记录首结点
        Node<Integer> first = null;
        //用来记录前一个结点
        Node<Integer> pre = null;

        for(int i = 1;i<=41;i++){

            //如果是第一个结点
            if (i==1){
                first = new Node<>(i,null);
                pre = first;
                continue;
            }

            //如果不是第一个结点
            Node<Integer> newNode = new Node<>(i, null);
            pre.next=newNode;
            pre=newNode;
            //如果是最后一个结点，那么需要让最后一个结点的下一个结点变为first,变为循环链表了
            if (i==41){
                pre.next=first;
            }

        }

        //2.需要count计数器，模拟报数
        int count=0;
        //3.遍历循环链表
        //记录每次遍历拿到的结点，默认从首结点开始
        Node<Integer> n = first;
        //记录当前结点的上一个结点
        Node<Integer> before = null;
        // n==n.next 成立，自己指向自己，说明只剩最后一个节点了
        while(n!=n.next){
            //模拟报数
            count++;
            //判断当前报数是不是为3
            if (count==3){
                //如果是3，则把当前结点删除调用，打印当前结点，重置count=0，让当前结点n后移
                before.next=n.next;
                System.out.print(n.item+",");
                count=0;
                n=n.next;
            }else{
                //如果不是3，让before变为当前结点，让当前结点后移；
                before=n;
                n=n.next;
            }
        }

        //打印最后一个元素
        System.out.println(n.item);
    }


    //结点类
    private static class Node<T> {
        //存储数据
        T item;
        //下一个结点
        Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
}
```

## 栈

### 栈概述

**生活中的栈**

存储货物或供旅客住宿的地方,可引申为仓库、中转站  。例如我们现在生活中的酒店，在古时候叫客栈，是供旅客休息的地方，旅客可以进客栈休息，休息完毕后就离开客栈。

<img src=".\images\客栈.png" style="zoom: 50%;" />

**计算机中的栈**

我们把生活中的栈的概念引入到计算机中，就是供数据休息的地方，它是一种数据结构，数据既可以进入到栈中，  又可以从栈中出去。

栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出  的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一  个数据被第一个读出来）。

我们称数据进入到栈的动作为**压栈**，数据从栈中出去的动作为**弹栈**。

![](.\images\计算机中的栈.png)

### 栈的实现

**栈 API 设计**

| **类名** | **Stack**                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Stack)：创建Stack对象                                        |
| 成员方法 | 1.public boolean isEmpty()：判断栈是否为空，是返回true，否返回false <br />2.public int size():获取栈中元素的个数<br />3. public T pop():弹出栈顶元素<br />4. public void push(T t)：向栈中压入元素t |
| 成员变量 | 1.private Node head:记录首结点<br />2.private int N:当前栈的元素个数 |

**栈代码实现**

```java
public class Stack<T> implements Iterable<T>{
    //记录首结点
    private Node head;
    //栈中元素的个数
    private int N;



    private class Node{
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }

    public Stack() {
        this.head = new Node(null,null);
        this.N=0;
    }

    //判断当前栈中元素个数是否为0
    public boolean isEmpty(){
        return N==0;
    }

    //获取栈中元素的个数
    public int size(){
        return N;
    }

    //把t元素压入栈
    public void push(T t){
        //找到首结点指向的第一个结点
        Node oldFirst = head.next;
        //创建新结点
        Node newNode = new Node(t, null);
        //让首结点指向新结点
        head.next = newNode;
        //让新结点指向原来的第一个结点
        newNode.next=oldFirst;
        //元素个数+1；
        N++;
    }

    //弹出栈顶元素
    public T pop(){
        //找到首结点指向的第一个结点
        Node oldFirst = head.next;
        if (oldFirst==null){
            return null;
        }
        //让首结点指向原来第一个结点的下一个结点
        head.next=oldFirst.next;
        //元素个数-1；
        N--;
        return oldFirst.item;
    }

    @Override
    public Iterator<T> iterator() {
        return new SIterator();
    }

    private class SIterator implements Iterator{
        private Node n;

        public SIterator(){
            this.n=head;
        }

        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }

}

public class StackTest {
    public static void main(String[] args) {
        //创建栈对象
        Stack<String> stack = new Stack<>();

        //测试压栈
        stack.push("a");
        stack.push("b");
        stack.push("c");
        stack.push("d");

        for (String item : stack) {
            System.out.println(item);
        }
        System.out.println("------------------------------");
        //测试弹栈
        String result = stack.pop();
        System.out.println("弹出的元素是："+result);
        System.out.println("剩余的元素个数："+stack.size());

    }
}
```

### 案例

#### 括号匹配问题

 **问题描述 :** 

给定一个字符串，里边可能包含"()"小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。

例如：

​	"(上海)(长安)"：正确匹配

​	"上海((长安))"：正确匹配

​	"上海(长安(北京)(深圳)南京)":正确匹配

​	"上海(长安))"：错误匹配

​	"((上海)长安"：错误匹配

**示例代码：**

```java
public class BracketsMatchTest {
    public static void main(String[] args) {
        String str = "上海(长安)())";
        boolean match = isMatch(str);
        System.out.println(str+"中的括号是否匹配："+match);
    }

    /**
     * 判断str中的括号是否匹配
     * @param str 括号组成的字符串
     * @return 如果匹配，返回true，如果不匹配，返回false
     */
    public static boolean isMatch(String str){
        return false;
    }
}
```

请完善 isMath方法。

**分析：**

1.创建一个栈用来存储左括号

2.从左往右遍历字符串，拿到每一个字符

3.判断该字符是不是左括号，如果是，放入栈中存储

4.判断该字符是不是右括号，如果不是，继续下一次循环

5.如果该字符是右括号，则从栈中弹出一个元素t；

6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的左括号

7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配

<img src=".\images\括号匹配问题1.png" style="zoom: 80%;" />

<img src=".\images\括号匹配问题2.png" style="zoom: 80%;" />

**代码实现：**

```java
public class BracketsMatchTest {
    public static void main(String[] args) {
        String str = "上海(长安)())";
        boolean match = isMatch(str);
        System.out.println(str+"中的括号是否匹配："+match);
    }

    /**
     * 判断str中的括号是否匹配
     * @param str 括号组成的字符串
     * @return 如果匹配，返回true，如果不匹配，返回false
     */
    public static boolean isMatch(String str){
        //1.创建栈对象，用来存储左括号
        Stack<String> chars = new Stack<>();
        //2.从左往右遍历字符串
        for (int i = 0; i < str.length(); i++) {
            String currChar = str.charAt(i)+ "";

            //3.判断当前字符是否为左括号，如果是，则把字符放入到栈中
            if (currChar.equals("(")){
                chars.push(currChar);
            }else if(currChar.equals(")")){
                //4.继续判断当前字符是否是有括号，如果是，则从栈中弹出一个左括号，并判断弹出的结果是否为null,如果为null证明没有匹配的左括号，如果不为null，则证明有匹配的左括号
                String pop = chars.pop();
                if (pop==null){
                    return false;
                }
            }

        }
        //5.判断栈中还有没有剩余的左括号，如果有，则证明括号不匹配
        if (chars.size()==0){
            return true;
        }else{
            return false;
        }

    }
}
```

#### 逆波兰表达式求值问题

逆波兰表达式求值问题是我们计算机中经常遇到的一类问题，要研究明白这个问题，首先我们得搞清楚什么是逆波兰表达式？要搞清楚逆波兰表达式，我们得从中缀表达式说起。

**中缀表达式：**

中缀表达式就是我们平常生活中使用的表达式，例如：1+3*2,2-(1+3)等等，中缀表达式的特点是：二元运算符总  是置于两个操作数中间。

中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的  运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级相关操作。

**逆波兰表达式 (后缀表达式)：**

逆波兰表达式是波兰逻辑学家J・卢卡西维兹( J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表达式的特点：运算符总是放在跟它相关的操作数之后。

| **中缀表达式** | **逆波兰表达式** |
| -------------- | ---------------- |
| a+b            | ab+              |
| a+(b-c)        | abc-+            |
| a+(b-c)*d      | abc-d*+          |
| a*(b-c)+d      | abc-*d+          |

**需求：**

给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。

```java
public class ReversePolishNotationTest {

    public static void main(String[] args) {
        //中缀表达式 3*（17-15）+18/6 的逆波兰表达式如下 6+3=9
        String[] notation = {"3", "17", "15", "-", "*", "18", "6", "/", "+"};
        int result = caculate(notation);
        System.out.println("逆波兰表达式的结果为：" + result);
    }

    /**
     * @param notaion 逆波兰表达式的数组表示方式
     * @return 逆波兰表达式的计算结果
     */
    public static int caculate(String[] notaion) {        
        return -1;
    }

}
```

完善caculate方法，计算出逆波兰表达式的结果。

**分析：**

1.创建一个栈对象oprands存储操作数

2.从左往右遍历逆波兰表达式，得到每一个字符串

3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中

4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2

5.使用该运算符计算o1和o2，得到结果result

6.把该结果压入oprands栈中

7.遍历结束后，拿出栈中最终的结果返回

![](.\images\逆波兰表达式求值问题.png)

**代码实现：**

```java
public class ReversePolishNotationTest {

    public static void main(String[] args) {
        //中缀表达式 3*（17-15）+18/6 的逆波兰表达式如下 6+3=9
        String[] notation = {"3", "17", "15", "-", "*", "18", "6", "/", "+"};
        int result = caculate(notation);
        System.out.println("逆波兰表达式的结果为：" + result);
    }

    /**
     * @param notaion 逆波兰表达式的数组表示方式
     * @return 逆波兰表达式的计算结果
     */
    public static int caculate(String[] notaion) {
        //1.定义一个栈，用来存储操作数
        Stack<Integer> oprands = new Stack<>();
        //2.从左往右遍历逆波兰表达式，得到每一个元素
        for (int i = 0; i < notaion.length; i++) {
            String curr = notaion[i];
            //3.判断当前元素是运算符还是操作数
            Integer o1;
            Integer o2;
            Integer result;
            switch (curr) {
                case "+":
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 + o1;
                    oprands.push(result);
                    break;
                case "-":
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 - o1;
                    oprands.push(result);
                    break;
                case "*":
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 * o1;
                    oprands.push(result);
                    break;
                case "/":
                    //4.运算符，从栈中弹出两个操作数，完成运算，运算完的结果再压入栈中
                    o1 = oprands.pop();
                    o2 = oprands.pop();
                    result = o2 / o1;
                    oprands.push(result);

                    break;
                default:
                    //5.操作数，把该操作数放入到栈中；
                    oprands.push(Integer.parseInt(curr));
                    break;
            }

        }


        //6.得到栈中最后一个元素，就是逆波兰表达式的结果
        int result = oprands.pop();

        return result;
    }

}
```

## 队列

队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。

![](.\images\队列.png)

**队列的 API 设计**

| **类名** | **Queue**                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Queue()：创建Queue对象                                       |
| 成员方法 | 1.public boolean isEmpty()：判断队列是否为空，是返回true，否返回false <br />2.public int size():获取队列中元素的个数<br />3.public T dequeue():从队列中拿出一个元素<br />4.public void enqueue(T t)：往队列中插入一个元素 |
| 成员变量 | 1.private Node head:记录首结点<br />2.private int N:当前栈的元素个数<br />3.private Node last:记录最后一个结点 |

**队列的实现**

```java
public class Queue<T> implements Iterable<T>{
    //记录首结点
    private Node head;
    //记录最后一个结点
    private Node last;
    //记录队列中元素的个数
    private int N;


    private class Node{
        public T item;
        public Node next;

        public Node(T item, Node next) {
            this.item = item;
            this.next = next;
        }
    }
    public Queue() {
        this.head = new Node(null,null);
        this.last=null;
        this.N=0;
    }

    //判断队列是否为空
    public boolean isEmpty(){
        return N==0;
    }

    //返回队列中元素的个数
    public int size(){
        return N;
    }

    //向队列中插入元素t
    public void enqueue(T t){

        if (last==null){
            //当前尾结点last为null
            last= new Node(t,null);
            head.next=last;
        }else {
            //当前尾结点last不为null
            Node oldLast = last;
            last = new Node(t, null);
            oldLast.next=last;
        }

        //元素个数+1
        N++;
    }

    //从队列中拿出一个元素
    public T dequeue(){
        if (isEmpty()){
            return null;
        }

        Node oldFirst= head.next;
        head.next=oldFirst.next;
        N--;

        //因为出队列其实是在删除元素，因此如果队列中的元素被删除完了，需要重置last=null;

        if (isEmpty()){
            last=null;
        }
        return oldFirst.item;
    }


    @Override
    public Iterator<T> iterator() {
        return new QIterator();
    }

    private class QIterator implements Iterator{
        private Node n;

        public QIterator(){
            this.n=head;
        }
        @Override
        public boolean hasNext() {
            return n.next!=null;
        }

        @Override
        public Object next() {
            n = n.next;
            return n.item;
        }
    }
}

public class QueueTest {

    public static void main(String[] args) {
        //创建队列对象
        Queue<String> q = new Queue<>();

        //测试队列的enqueue方法
        q.enqueue("a");
        q.enqueue("b");
        q.enqueue("c");
        q.enqueue("d");

        for (String str : q) {
            System.out.println(str);
        }

        System.out.println("-------------------------------");
        //测试队列的dequeue方法
        String result = q.dequeue();
        System.out.println("出队列的元素是："+result);
        System.out.println("剩余的元素个数："+q.size());

    }
}
```

# 符号表

符号表最主要的目的就是将一个键和一个值联系起来，符号表能够将存储的数据元素是一个键和一个值共同组成的  键值对数据，我们可以根据键来查找对应的值。

![](.\images\符号表.png)

符号表中，键具有唯一性。

符号表在实际生活中的使用场景是非常广泛的，见下表：

| **应用** | **查找目的**             | **键** | **值**   |
| -------- | ------------------------ | ------ | -------- |
| 字典     | 找出单词的释义           | 单词   | 释义     |
| 图书索引 | 找出某个术语相关的页码   | 术语   | 一串页码 |
| 网络搜索 | 找出某个关键字对应的网页 | 关键字 | 网页名称 |

## 符号表 API 设计

**结点类：**

| **类名** | **Node<Key,Value>**                                          |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key,Value value,Node next)：创建Node对象            |
| 成员变量 | 1.public Key key:存储键<br />2.public Value value:存储值<br />3.public Node next:存储下一个结点 |

**符号表：**

| **类名** | **SymbolTable<Key,Value>**                                   |
| -------- | ------------------------------------------------------------ |
| 构造方法 | SymbolTable()：创建SymbolTable对象                           |
| 成员方法 | 1. public Value get(Key key)：根据键key，找对应的值<br />2. public void put(Key key,Value val):向符号表中插入一个键值对<br />3.public void delete(Key key):删除键为key的键值对<br />4.public int size()：获取符号表的大小 |
| 成员变量 | 1.private Node head:记录首结点<br />2.private int N:记录符号表中键值对的个数 |

**符号表实现**

```java
public class SymbolTable<Key,Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    private class Node{
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public SymbolTable() {
        this.head = new Node(null,null,null);
        this.N=0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return N;
    }

    //往符号表中插入键值对
    public void put(Key key,Value value){
        //符号表中已经存在了键为key的键值对，那么只需要找到该结点，替换值为value即可
        Node n = head;
        while(n.next!=null){
            //变换n
            n = n.next;
            //判断n结点存储的键是否为key，如果是，则替换n结点的值
            if (n.key.equals(key)){
                n.value = value;
                return;
            }

        }

        //如果符号表中不存在键为key的键值对，只需要创建新的结点，保存要插入的键值对，把新结点插入到链表的头部  head.next=新结点即可
        Node newNode = new Node(key, value, null);
        Node oldFirst = head.next;
        newNode.next = oldFirst;
        head.next = newNode;


        //元素个数+1；
        N++;

    }
    //删除符号表中键为key的键值对
    public void delete(Key key){
        //找到键为key的结点，把该结点从链表中删除

        Node n = head;
        while(n.next!=null){
            //判断n结点的下一个结点的键是否为key，如果是，就删除该结点
            if (n.next.key.equals(key)){
                n.next = n.next.next;
                N--;
                return;
            }


            //变换n
            n = n.next;
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while(n.next!=null){
            //变换n
            n = n.next;
            if (n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }
}

public class SymbolTableTest {
    public static void main(String[] args) {
        //创建符号表对象
        SymbolTable<Integer, String> symbolTable = new SymbolTable<>();

        //测试put方法（插入,替换）
        symbolTable.put(1,"乔峰");
        symbolTable.put(2,"虚竹");
        symbolTable.put(3,"段誉");

        System.out.println("插入完毕后，元素的个数为:"+symbolTable.size());

        symbolTable.put(2, "慕容复");
        System.out.println("替换完毕后的元素的个数为:"+symbolTable.size());

        //测试get方法
        System.out.println("替换完毕后，键2对应的值为:"+symbolTable.get(2));

        //测试删除方法
        symbolTable.delete(2);
        System.out.println("删除完毕后，元素的个数:"+symbolTable.size());


    }
}
```

## 有序符号表

刚才实现的符号表，我们可以称之为无序符号表，因为在插入的时候，并没有考虑键值对的顺序，而在实际生活  中，有时候我们需要根据键的大小进行排序，插入数据时要考虑顺序，那么接下来我们就实现一下有序符号表。

```java
public class OrderSymbolTable<Key extends Comparable<Key>,Value> {
    //记录首结点
    private Node head;
    //记录符号表中元素的个数
    private int N;

    private class Node{
        //键
        public Key key;
        //值
        public Value value;
        //下一个结点
        public Node next;

        public Node(Key key, Value value, Node next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }

    public OrderSymbolTable() {
        this.head = new Node(null,null,null);
        this.N=0;
    }

    //获取符号表中键值对的个数
    public int size(){
        return N;
    }

    //往符号表中插入键值对
    public void put(Key key,Value value){
        //定义两个Node变量，分别记录当前结点和当前结点的上一个结点

        Node curr = head.next;
        Node pre = head;
        while(curr!=null && key.compareTo(curr.key)>0){

            //变换当前结点和前一个结点即可
            pre = curr;
            curr = curr.next;
        }

        //如果当前结点curr的键和要插入的key一样，则替换
        if (curr!=null && key.compareTo(curr.key)==0){
            curr.value = value;
            return;
        }

        //如果当前结点curr的键和要插入的key不一样，把新的结点插入到curr之前
        Node newNode = new Node(key, value, curr);
        pre.next = newNode;

        //元素的个数+1；
        N++;

    }
    //删除符号表中键为key的键值对
    public void delete(Key key){
        //找到键为key的结点，把该结点从链表中删除

        Node n = head;
        while(n.next!=null){
            //判断n结点的下一个结点的键是否为key，如果是，就删除该结点
            if (n.next.key.equals(key)){
                n.next = n.next.next;
                N--;
                return;
            }


            //变换n
            n = n.next;
        }
    }

    //从符号表中获取key对应的值
    public Value get(Key key){
        //找到键为key的结点
        Node n = head;
        while(n.next!=null){
            //变换n
            n = n.next;
            if (n.key.equals(key)){
                return n.value;
            }
        }
        return null;
    }
}

public class OrderSymbolTableTest {

    public static void main(String[] args) {
        //创建有序符号表对象
        OrderSymbolTable<Integer, String> table = new OrderSymbolTable<>();

        table.put(1,"张三");
        table.put(2,"李四");
        table.put(4,"赵六");
        table.put(7,"田七");

        table.put(3,"王五");

    }
}
```

# 二叉树入门

之前我们实现的符号表中，不难看出，符号表的增删查操作，随着元素个数N的增多，其耗时也是线性增多的，时间复杂度都是O(n),为了提高运算效率，接下来我们学习树这种数据结构。

## 树的基本定义

树是我们计算机中非常重要的一种数据结构，同时使用树这种数据结构，可以描述现实生活中的很多事物，例如家谱、单位的组织架构、等等。

树是由n（n>=1）个有限结点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

![](.\images\树的基本定义.png)

树具有以下特点：

1. 每个结点有零个或多个子结点；
2. 没有父结点的结点为根结点；
3. 每一个非根结点只有一个父结点；
4. 每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；

## 树的相关术语

**结点的度：**

一个结点含有的子树的个数称为该结点的度； 

**叶结点：**

度为0的结点称为叶结点，也可以叫做终端结点

**分支结点：**

度不为0的结点称为分支结点，也可以叫做非终端结点

**结点的层次：**

从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推

**结点的层序编号：**

将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。 

**树的度：**

树中所有结点的度的最大值

**树的高度(深度)：**

树中结点的最大层次

**森林：**

m（m>=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根  结点，森林就变成一棵树

![](.\images\森林.png)

**孩子结点：**

一个结点的直接后继结点称为该结点的孩子结点

**双亲结点(父结点)：**

一个结点的直接前驱称为该结点的双亲结点

**兄弟结点：**

同一双亲结点的孩子结点间互称兄弟结点

## 二叉树的基本定义

二叉树就是度不超过2的树(每个结点最多有两个子结点)

![](.\images\二叉树的基本定义.png)

**满二叉树：**

一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。

![](.\images\满二叉树.png)

**完全二叉树：**

叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

![](.\images\完全二叉树.png)

## 二叉查找树的创建

### 二叉树的结点类

根据对图的观察，我们发现二叉树其实就是由一个一个的结点及其之间的关系组成的，按照面向对象的思想，我们设计一个结点类来描述结点这个事物。

**结点类 API 设计：**

| **类名** | **Node<Key,Value>**                                          |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key, Value value, Node left, Node right)：创建Node对象 |
| 成员变量 | 1.public Node left:记录左子结点<br />2.public Node right:记录右子结点<br />3.public Key key:存储键<br />4.public Value value:存储值 |

**代码实现：**

```java
private class Node {
    //存储键
    public Key key;
    //存储值
    private Value value;
    //记录左子结点
    public Node left;
    //记录右子结点
    public Node right;

    public Node(Key key, Value value, Node left, Node right) {
        this.key = key;
        this.value = value;
        this.left = left;
        this.right = right;
    }
}
```

### 二叉查找树 API 设计

| **类名** | **BinaryTree,Value value>**                                  |
| -------- | ------------------------------------------------------------ |
| 构造方法 | BinaryTree()：创建BinaryTree对象                             |
| 成员变量 | 1.private Node root:记录根结点<br />2.private int N:记录树中元素的个数 |
| 成员方法 | 1. public void put(Key key,Value value):向树中插入一个键值对<br />2. private Node put(Node x, Key key, Value val)：给指定树x上，添加一个键值对，并返回添加后的新树<br />3. public Value get(Key key):根据key，从树中找出对应的值<br />4. private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br />5.public void delete(Key key):根据key，删除树中对应的键值对<br />6. private Node delete(Node x, Key key):删除指定树x上的键为key的键值对，并返回删除后的新树<br />7. public int size():获取树中元素的个数 |

### 二叉查找树实现

**插入方法 put 实现思想：**

1. 如果当前树中没有任何一个结点，则直接把新结点当做根结点使用

2. 如果当前树不为空，则从根结点开始：

   - 如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；

   - 如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；

   - 如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。

![](.\images\二叉树插入元素.png)

**查询方法 get 实现思想：** 

从根节点开始：

1. 如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；
2. 如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；
3. 如果要查询的key等于当前结点的key，则树中返回当前结点的value。

**删除方法 delete实现思想：**

1. 找到被删除结点；
2. 找到被删除结点右子树中的最小结点minNode
3. 删除右子树中的最小结点
4. 让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子  树
5. 让被删除结点的父节点指向最小结点minNode

![](.\images\二叉树删除元素.png)

![](.\images\二叉树删除元素2.png)

**代码：**

```java
public class BinaryTree<Key extends Comparable<Key>, Value> {
    //记录根结点
    private Node root;
    //记录树中元素的个数
    private int N;

    private class Node {
        //存储键
        public Key key;
        //存储值
        private Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;

        public Node(Key key, Value value, Node left, Node right) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }

    //获取树中元素的个数
    public int size() {
        return N;
    }

    //向树中添加元素key-value
    public void put(Key key, Value value) {
        root = put(root, key, value);
    }

    //向指定的树x中添加key-value,并返回添加元素后新的树
    private Node put(Node x, Key key, Value value) {
        //如果x子树为空，
        if (x==null){
            N++;
            return new Node(key,value, null,null);
        }

        //如果x子树不为空
        //比较x结点的键和key的大小：

        int cmp = key.compareTo(x.key);
        if (cmp>0){
            //如果key大于x结点的键，则继续找x结点的右子树
            x.right = put(x.right,key,value);

        }else if(cmp<0){
            //如果key小于x结点的键，则继续找x结点的左子树
            x.left = put(x.left,key,value);
        }else{
            //如果key等于x结点的键，则替换x结点的值为value即可
            x.value = value;
        }
        return x;
    }

    //查询树中指定key对应的value
    public Value get(Key key) {
        return get(root,key);
    }

    //从指定的树x中，查找key对应的值
    public Value get(Node x, Key key) {
        //x树为null
        if (x==null){
            return null;
        }

        //x树不为null

        //比较key和x结点的键的大小
        int cmp = key.compareTo(x.key);
        if (cmp>0){
            //如果key大于x结点的键，则继续找x结点的右子树
            return get(x.right,key);

        }else if(cmp<0){
            //如果key小于x结点的键，则继续找x结点的左子树
            return get(x.left,key);
        }else{
            //如果key等于x结点的键，就找到了键为key的结点，只需要返回x结点的值即可
            return x.value;
        }

    }


    //删除树中key对应的value
    public void delete(Key key) {
        delete(root, key);
    }

    //删除指定树x中的key对应的value，并返回删除后的新树
    public Node delete(Node x, Key key) {
        //x树为null
        if (x==null){
            return null;
        }

        //x树不为null
        int cmp = key.compareTo(x.key);
        if (cmp>0){
            //如果key大于x结点的键，则继续找x结点的右子树
            x.right = delete(x.right,key);

        }else if(cmp<0){
            //如果key小于x结点的键，则继续找x结点的左子树
            x.left = delete(x.left,key);
        }else{
            //如果key等于x结点的键，完成真正的删除结点动作，要删除的结点就是x；

            //让元素个数-1
            N--;
            //得找到右子树中最小的结点
            if (x.right==null){
                return x.left;
            }

            if (x.left==null){
                return x.right;
            }

            Node minNode = x.right;
            while(minNode.left!=null){
                minNode = minNode.left;
            }

            //删除右子树中最小的结点
            Node n = x.right;
            while(n.left!=null){
                if (n.left.left==null){
                    n.left=null;
                }else{
                    //变换n结点即可
                    n = n.left;
                }
            }

            //让x结点的左子树成为minNode的左子树
            minNode.left = x.left;
            //让x结点的右子树成为minNode的右子树
            minNode.right = x.right;
            //让x结点的父结点指向minNode
            x = minNode;



        }

        return x;
    }
}

public class BinaryTreeTest {
    public static void main(String[] args) {
        //创建二叉查找树对象
        BinaryTree<Integer, String> tree = new BinaryTree<>();

        //测试插入
        tree.put(1,"张三");
        tree.put(2,"李四");
        tree.put(3,"王五");
        System.out.println("插入完毕后元素的个数："+tree.size());

        //测试获取
        System.out.println("键2对应的元素是："+tree.get(2));

        //测试删除

        tree.delete(3);
        System.out.println("删除后的元素个数："+tree.size());
        System.out.println("删除后键3对应的元素:"+tree.get(3));
    }

}
```

### 二叉查找树其他便捷方法

#### 查找二叉树中最小的键

在某些情况下，我们需要查找出树中存储所有元素的键的最小值，比如我们的树中存储的是学生的排名和姓名数据，那么需要查找出排名最低是多少名？这里我们设计如下两个方法来完成：

| **public Key min()**     | **找出树中最小的键**            |
| ------------------------ | ------------------------------- |
| private Node min(Node x) | 找出指定树x中，最小键所在的结点 |

```java
//查找整个树中最小的键
public Key min(){
    return min(root).key;
}

//在指定树x中找出最小键所在的结点
private Node min(Node x){
    //需要判断x还有没有左子结点，如果有，则继续向左找，如果没有，则x就是最小键所在的结点
    if (x.left!=null){
        return min(x.left);
    }else{
        return x;
    }
}
```

#### 查找二叉树中最大的键

在某些情况下，我们需要查找出树中存储所有元素的键的最大值，比如比如我们的树中存储的是学生的成绩和学生  的姓名，那么需要查找出最高的分数是多少？这里我们同样设计两个方法来完成：

| **public Key max()**    | **找出树中最大的键**            |
| ----------------------- | ------------------------------- |
| public Node max(Node x) | 找出指定树x中，最大键所在的结点 |

```java
//在整个树中找到最大的键
public Key max(){
    return max(root).key;
}

//在指定的x中，找到最大的键所在的结点
public Node max(Node x){
    //判断x还有没有右子结点，如果有，则继续向右查找，如果没有，则x就是最大键所在的结点
    if (x.right!=null){
        return max(x.right);
    }else{
        return x;
    }
}
```

## 二叉树的基础遍历

很多情况下，我们可能需要像遍历数组一样，遍历树，从而拿出树中存储的每一个元素，由于树状结构和线性结构不一样，它没有办法从头开始依次向后遍历，所以存在如何遍历，也就是按照什么样的**搜索路径**进行遍历的问题。

![](.\images\二叉树的基础遍历.png)

我们把树简单的画作上图中的样子，由一个根节点、一个左子树、一个右子树组成，那么按照根节点什么时候被访问，我们可以把二叉树的遍历分为以下三种方式：

1. 前序遍历；

先访问根结点，然后再访问左子树，最后访问右子树

2. 中序遍历；

先访问左子树，中间访问根节点，最后访问右子树

3. 后序遍历；

先访问左子树，再访问右子树，最后访问根节点

如果我们分别对下面的树使用三种遍历方式进行遍历，得到的结果如下：

![](.\images\3种遍历的结果.png)

### 前序遍历

我们在创建的树上，添加前序遍历的API：

public Queue<Key> preErgodic()：使用前序遍历，获取整个树中的所有键

private void preErgodic(Node x,Queue<Key> keys)：使用前序遍历，把指定树x中的所有键放入到keys队列中

实现过程中，我们通过前序遍历，把每个结点的键取出，放入到队列中返回即可。 

**实现步骤：**

1. 把当前结点的key放入到队列中;

2. 找到当前结点的左子树，如果不为空，递归遍历左子树
2. 找到当前结点的右子树，如果不为空，递归遍历右子树

 **代码：**

```java
//获取整个树中所有的键
public Queue<Key> preErgodic(){
    Queue<Key> keys = new Queue<>();
    preErgodic(root, keys);
    return keys;
}

//获取指定树x的所有键，并放到keys队列中
private void preErgodic(Node x,Queue<Key> keys){
    if (x==null){
        return;
    }

    //把x结点的key放入到keys中
    keys.enqueue(x.key);

    //递归遍历x结点的左子树
    if (x.left!=null){
        preErgodic(x.left,keys);
    }

    //递归遍历x结点的右子树
    if (x.right!=null){
        preErgodic(x.right,keys);
    }

}

public class BinaryTreeErgodicTest {
	public static void main(String[] args) {
        //创建树对象
        BinaryTree<String, String> tree = new BinaryTree<>();
        //往树中添加数据
        tree.put("E", "5");
        tree.put("B", "2");
        tree.put("G", "7");
        tree.put("A", "1");
        tree.put("D", "4");
        tree.put("F", "6");
        tree.put("H", "8");
        tree.put("C", "3");

        //遍历
        Queue<String> keys = tree.preErgodic();
        for (String key : keys) {
            String value = tree.get(key);
            System.out.println(key+"----"+value);
        }
    }
}
```

### 中序遍历

我们在创建的树上，添加中序遍历的API：

public Queue<Key> midErgodic()：使用中序遍历，获取整个树中的所有键

private void midErgodic(Node x,Queue<Key> keys)：使用中序遍历，把指定树x中的所有键放入到keys队列中

**实现步骤：**

1. 找到当前结点的左子树，如果不为空，递归遍历左子树

2. 把当前结点的key放入到队列中;

找到当前结点的右子树，如果不为空，递归遍历右子树

 **代码：**

```java
//使用中序遍历获取树中所有的键
public Queue<Key> midErgodic(){
    Queue<Key> keys = new Queue<>();
    midErgodic(root,keys);
    return keys;
}

//使用中序遍历，获取指定树x中所有的键，并存放到key中
private void midErgodic(Node x,Queue<Key> keys){
    if (x==null){
        return;
    }
    //先递归，把左子树中的键放到keys中
    if (x.left!=null){
        midErgodic(x.left,keys);
    }
    //把当前结点x的键放到keys中
    keys.enqueue(x.key);
    //在递归，把右子树中的键放到keys中
    if(x.right!=null){
        midErgodic(x.right,keys);
    }
}

public class BinaryTreeErgodicTest {
	public static void main(String[] args) {
        //创建树对象
        BinaryTree<String, String> tree = new BinaryTree<>();
        //往树中添加数据
        tree.put("E", "5");
        tree.put("B", "2");
        tree.put("G", "7");
        tree.put("A", "1");
        tree.put("D", "4");
        tree.put("F", "6");
        tree.put("H", "8");
        tree.put("C", "3");

        //遍历
        Queue<String> keys = tree.midErgodic();
        for (String key : keys) {
            String value = tree.get(key);
            System.out.println(key+"----"+value);
        }
    }
}
```

### 后序遍历

我们在创建的树上，添加后序遍历的API：

public Queue<Key> afterErgodic()：使用后序遍历，获取整个树中的所有键

private void afterErgodic(Node x,Queue<Key> keys)：使用后序遍历，把指定树x中的所有键放入到keys队列中

**实现步骤：**

1. 找到当前结点的左子树，如果不为空，递归遍历左子树

2. 找到当前结点的右子树，如果不为空，递归遍历右子树

3. 把当前结点的key放入到队列中;

**代码：**

```java
//使用后序遍历，把整个树中所有的键返回
public Queue<Key> afterErgodic(){
    Queue<Key> keys = new Queue<>();
    afterErgodic(root,keys);
    return keys;
}

//使用后序遍历，把指定树x中所有的键放入到keys中
private void afterErgodic(Node x,Queue<Key> keys){
    if (x==null){
        return ;
    }

    //通过递归把左子树中所有的键放入到keys中
    if (x.left!=null){
        afterErgodic(x.left,keys);
    }
    //通过递归把右子树中所有的键放入到keys中
    if (x.right!=null){
        afterErgodic(x.right,keys);
    }
    //把x结点的键放入到keys中
    keys.enqueue(x.key);
}

public class BinaryTreeErgodicTest {
	public static void main(String[] args) {
        //创建树对象
        BinaryTree<String, String> tree = new BinaryTree<>();
        //往树中添加数据
        tree.put("E", "5");
        tree.put("B", "2");
        tree.put("G", "7");
        tree.put("A", "1");
        tree.put("D", "4");
        tree.put("F", "6");
        tree.put("H", "8");
        tree.put("C", "3");

        //遍历
        Queue<String> keys = tree.afterErgodic();
        for (String key : keys) {
            String value = tree.get(key);
            System.out.println(key+"----"+value);
        }
    }
}
```

## 二叉树的层序遍历

所谓的层序遍历，就是从根节点（第一层）开始，依次向下，获取每一层所有结点的值，有二叉树如下：

![](.\images\二叉树的层序遍历.png)

那么层序遍历的结果是：EBGADFHC

我们在创建的树上，添加层序遍历的API：

public Queue<Key> layerErgodic()：使用层序遍历，获取整个树中的所有键

**实现步骤：**

1. 创建一个Node队列，存储每一层的结点；

2. 使用循环从队列中弹出一个结点：

   - 获取当前结点的key；

   - 如果当前结点的左子结点不为空，则把左子结点放入到Key队列中

   - 如果当前结点的右子结点不为空，则把右子结点放入到Key队列中

![](.\images\二叉树的层序遍历实现步骤.png)

**代码：**

```java
//使用层序遍历，获取整个树中所有的键
public Queue<Key> layerErgodic(){
    //定义两个队列，分别存储树中的键和树中的结点
    Queue<Key> keys = new Queue<>();
    Queue<Node> nodes = new Queue<>();

    //默认，往队列中放入根结点
    nodes.enqueue(root);

    while(!nodes.isEmpty()){
        //从队列中弹出一个结点，把key放入到keys中
        Node n = nodes.dequeue();
        keys.enqueue(n.key);
        //判断当前结点还有没有左子结点，如果有，则放入到nodes中
        if (n.left!=null){
            nodes.enqueue(n.left);
        }
        //判断当前结点还有没有右子结点，如果有，则放入到nodes中
        if (n.right!=null){
            nodes.enqueue(n.right);
        }
    }
    return keys;
}

public class BinaryTreeErgodicTest {
	public static void main(String[] args) {
        //创建树对象
        BinaryTree<String, String> tree = new BinaryTree<>();
        //往树中添加数据
        tree.put("E", "5");
        tree.put("B", "2");
        tree.put("G", "7");
        tree.put("A", "1");
        tree.put("D", "4");
        tree.put("F", "6");
        tree.put("H", "8");
        tree.put("C", "3");

        //遍历
        Queue<String> keys = tree.layerErgodic();
        for (String key : keys) {
            String value = tree.get(key);
            System.out.println(key+"----"+value);
        }
    }
}
```

## 二叉树的最大深度问题

**需求：**

给定一棵树，请计算树的最大深度（树的根节点到最远叶子结点的最长路径上的结点数）;

![](.\images\二叉树的最大深度.png)

上面这棵树的最大深度为4。

**实现：**

我们在1.4中创建的树上，添加如下的API求最大深度：

public int maxDepth()：计算整个树的最大深度

private int maxDepth(Node x):计算指定树x的最大深度

**实现步骤：**

1. 如果根结点为空，则最大深度为0；

2. 计算左子树的最大深度；

3. 计算右子树的最大深度；

4. 当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1

**代码：**

```java
//获取整个树的最大深度
public int maxDepth(){
    return maxDepth(root);
}


//获取指定树x的最大深度
private int maxDepth(Node x){
    if (x==null){
        return 0;
    }
    //x的最大深度
    int max=0;
    //左子树的最大深度
    int maxL=0;
    //右子树的最大深度
    int maxR=0;

    //计算x结点左子树的最大深度
    if (x.left!=null){
        maxL = maxDepth(x.left);
    }
    //计算x结点右子树的最大深度
    if (x.right!=null){
        maxR = maxDepth(x.right);
    }
    //比较左子树最大深度和右子树最大深度，取较大值+1即可

    max = maxL>maxR?maxL+1:maxR+1;

    return max;
}

public class BinaryTreeMaxDepthTest {


    public static void main(String[] args) {
        //创建树对象
        BinaryTree<String, String> tree = new BinaryTree<>();
        //往树中添加数据
        tree.put("E", "5");
        tree.put("B", "2");
        tree.put("G", "7");
        tree.put("A", "1");
        tree.put("D", "4");
        tree.put("F", "6");
        tree.put("H", "8");
        tree.put("C", "3");

        int maxDepth = tree.maxDepth();
        System.out.println(maxDepth);
    }

}
```

## 折纸问题

**需求：**

请把一段纸条竖着放在桌子上，然后从纸条的下边向上方对折1次，压出折痕后展开。此时  折痕是凹下去的，即折痕突起的方向指向纸条的背面。如果从纸条的下边向上方连续对折2  次，压出折痕后展开，此时有三条折痕，从上到下依次是下折痕、下折痕和上折痕。

给定一 个输入参数N，代表纸条都从下边向上方连续对折N次，请从上到下打印所有折痕的方向 例如：N=1时，打印： down；N=2时，打印： down down up

![](.\images\折纸问题.png)

**分析：**

我们把对折后的纸张翻过来，让粉色朝下，这时把第一次对折产生的折痕看做是根结点，那第二次对折产生的下折  痕就是该结点的左子结点，而第二次对折产生的上折痕就是该结点的右子结点，这样我们就可以使用树型数据结构  来描述对折后产生的折痕。

这棵树有这样的特点：

1. 根结点为下折痕；

2. 每一个结点的左子结点为下折痕；

3. 每一个结点的右子结点为上折痕；

![](.\images\折纸问题分析.png)

**实现步骤：**

1. 定义结点类

2. 构建深度为N的折痕树；

3. 使用中序遍历，打印出树中所有结点的内容； 

**构建深度为 N的折痕树：**

1. 第一次对折，只有一条折痕，创建根结点；
2. 如果不是第一次对折，则使用队列保存根结点；
3. 循环遍历队列：

   - 从队列中拿出一个结点；
   
   - 如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；
   - 如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；
   
   - 判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一  个值为up的右子结点。
   

![](.\images\折纸问题解决思路.png)

**代码：**

```java
public class PagerFoldingTest {

    public static void main(String[] args) {

        //模拟这只过程，产生树
        Node<String> tree = createTree(2);
        //遍历树，打印每个结点
        printTree(tree);

    }

    //通过模拟对折N次纸，产生树
    public static Node<String> createTree(int N){
        //定义根结点
        Node<String> root=null;
        for (int i = 0; i < N; i++) {

            //1.当前是第一次对折
            if (i==0){
                root = new Node<>("down",null,null);
                continue;
            }
            //2.当前不是第一次对折
            //定义一个辅助队列，通过层序遍历的思想，找到叶子结点，叶子结点添加子节点
            Queue<Node> queue = new Queue<>();
            queue.enqueue(root);

            //循环遍历队列
            while(!queue.isEmpty()){
                //从队列中弹出一个结点
                Node<String> tmp = queue.dequeue();
                //如果有左子结点，则把左子结点放入到队列中
                if (tmp.left!=null){
                    queue.enqueue(tmp.left);
                }
                //如果有右子结点，则把右子结点放入到队列中
                if (tmp.right!=null){
                    queue.enqueue(tmp.right);
                }
                //如果同时没有左子结点和右子结点，那么证明该节点是叶子结点，只需要给该节点添加左子结点和右子结点即可
                if (tmp.left==null && tmp.right==null){
                    tmp.left = new Node<String>("down", null,null);
                    tmp.right = new Node<String>("up",null,null);
                }
            }
        }
        
        return root;
    }

    //打印树中每个结点到控制台
    public static void printTree(Node<String> root){
        //需要使用中序遍历完成
        if (root==null){
            return;
        }

        //打印左子树的每个结点
        if (root.left!=null){
            printTree(root.left);
        }
        //打印当前结点
        System.out.print(root.item+" ");
        //打印右子树的每个结点
        if (root.right!=null){
            printTree(root.right);
        }

    }

    //结点类
    private static class Node<T>{
        public T item;//存储元素
        public Node left;
        public Node right;

        public Node(T item, Node left, Node right) {
            this.item = item;
            this.left = left;
            this.right = right;
        }
    }
}
```

# 堆

## 堆的定义

堆是计算机科学中一类特殊的数据结构的统称，堆通常可以被看做是一棵完全二叉树的数组对象。 

**堆的特性：**

1. 它是完全二叉树，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求左满右不满。

![](.\images\堆的特性.png)

2.  它通常用数组来实现。

具体方法就是将二叉树的结点按照层级顺序放入数组中，根结点在位置1，它的子结点在位置2和3，而子结点的子结点则分别在位置4,5,6和7，以此类推。

![](.\images\堆与数组.png)

如果一个结点的位置为k，则它的父结点的位置为[k/2],而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动：从a[k]向上一层，就令k等于k/2，向下一层就令k等于2k或2k+1。

3. 每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这**两个子结点的顺序并没有做规定**，跟我们之前学习的二叉查找树是有区别的。

## 堆的 API 设计

| **类名** | **Heap>**                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Heap(int capacity)：创建容量为capacity的Heap对象             |
| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br />2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br />3.public T delMax():删除堆中最大的元素,并返回这个最大元素<br />4.public void insert(T t)：往堆中插入一个元素<br />5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br />6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置 |
| 成员变量 | 1. private T[] imtes : 用来存储元素的数组<br />2. private int N：记录堆中元素的个数 |

## 堆的实现

**insert 插入方法的实现**

堆是用数组完成数据元素的存储的，由于数组的底层是一串连续的内存地址，所以我们要往堆中插入数据，我们只能往数组中从索引0处开始，依次往后存放数据，但是堆中对元素的顺序是有要求的，每一个结点的数据要大于等于它的两个子结点的数据，所以每次插入一个元素，都会使得堆中的数据顺序变乱，这个时候我们就需要通过一些方法让刚才插入的这个数据放入到合适的位置。

![](.\images\insert插入方法的实现1.png)

![](.\images\insert插入方法的实现2.png)

所以，如果往堆中新插入元素，我们只需要不断的比较新结点a[k]和它的父结点a[k/2]的大小，然后根据结果完成数据元素的交换，就可以完成堆的有序调整。

**delMax 删除最大元素方法的实现**

由堆的特性我们可以知道，索引1处的元素，也就是根结点就是最大的元素，当我们把根结点的元素删除后，需要有一个新的根结点出现，这时我们可以暂时把堆中最后一个元素放到索引1处，充当根结点，但是它有可能不满足堆的有序性需求，这个时候我们就需要通过一些方法，让这个新的根结点放入到合适的位置。

![](.\images\delMax删除最大元素方法的实现1.png)

![](.\images\delMax删除最大元素方法的实现2.png)

所以，当删除掉最大元素后，只需要将最后一个元素放到索引1处，并不断的拿着当前结点a[k]与它的子结点a[2k]  和a[2k+1]中的较大者交换位置，即可完成堆的有序调整。

**堆的实现代码**

```java
public class Heap<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;

    public Heap(int capacity) {
        this.items = (T[]) new Comparable[capacity + 1];
        this.N = 0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j) {
        return items[i].compareTo(items[j]) < 0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i, int j) {
        T temp = items[i];
        items[i] = items[j];
        items[j] = temp;
    }

    //往堆中插入一个元素
    public void insert(T t) {
        items[++N] = t;
        swim(N);
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k) {
        //通过循环，不断的比较当前结点的值和其父结点的值，如果发现父结点的值比当前结点的值小，则交换位置
        while (k > 1) {
            //比较当前结点和其父结点

            if (less(k / 2, k)) {
                exch(k / 2, k);
            }

            k = k / 2;
        }

    }

    //删除堆中最大的元素,并返回这个最大元素
    public T delMax() {
        T max = items[1];

        //交换索引1处的元素和最大索引处的元素，让完全二叉树中最右侧的元素变为临时根结点
        exch(1, N);
        //最大索引处的元素删除掉
        items[N] = null;
        //元素个数-1
        N--;
        //通过下沉调整堆，让堆重新有序
        sink(1);
        return max;
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k) {
        //通过循环不断的对比当前k结点和其左子结点2*k以及右子结点2k+1处中的较大值的元素大小，如果当前结点小，则需要交换位置
        while (2 * k <= N) {
            //获取当前结点的子结点中的较大结点
            int max;//记录较大结点所在的索引
            if (2 * k + 1 <= N) {
                if (less(2 * k, 2 * k + 1)) {
                    max = 2 * k + 1;
                } else {
                    max = 2 * k;
                }
            } else {
                max = 2 * k;
            }


            //比较当前结点和较大结点的值
            if (!less(k, max)) {
                break;
            }

            //交换k索引处的值和max索引处的值
            exch(k, max);

            //变换k的值
            k = max;
        }

    }

    public static void main(String[] args) {
        Heap<String> heap = new Heap<String>(20);
        heap.insert("A");
        heap.insert("B");
        heap.insert("C");
        heap.insert("D");
        heap.insert("E");
        heap.insert("F");
        heap.insert("G");


        String del;
        while ((del = heap.delMax()) != null) {
            System.out.print(del + ",");
        }

    }
}
```

## 堆排序

给定一个数组：

String[] arr = {"S","O","R","T","E","X","A","M","P","L","E"}

请对数组中的字符按从小到大排序。

**实现步骤：**

1. 构造堆；

2. 得到堆顶元素，这个值就是最大值；

3. 交换堆顶元素和数组中的最后一个元素，此时所有元素中的最大元素已经放到合适的位置；

4. 对堆进行调整，重新让除了最后一个元素的剩余元素中的最大值放到堆顶；

5. 重复2~4这个步骤，直到堆中剩一个元素为止。

**API 设计：**

| **类名** | **HeapSort**                                                 |
| -------- | ------------------------------------------------------------ |
| 成员方法 | 1.public static void sort(Comparable[] source)：对source数组中的数据从小到大排序<br />2.private static void createHeap(Comparable[] source, Comparable[] heap):根据原数组source，构造出堆heap<br />3. private static boolean less(Comparable[] heap, int i, int j)：判断heap堆中索引i处的元素是否小于索引j处的元素<br />4. private static void exch(Comparable[] heap, int i, int j):交换heap堆中i索引和j索引处的值<br />5.private static void sink(Comparable[] heap, int target, int range):在heap堆中，对target处的元素做下沉，范围是0~range。 |

**堆构造过程**

堆的构造，最直观的想法就是另外再创建一个新数组，然后从左往右遍历原数组，每得到一个元素后，添加到新数组中，并通过上浮，对堆进行调整，最后新的数组就是一个堆。

上述的方式虽然很直观，也很简单，但是我们可以用更聪明一点的办法完成它。创建一个新数组，把原数组0~length-1的数据拷贝到新数组的1~length处，再从新数组长度的一半处开始往1索引处扫描（从右往左），然后  对扫描到的每一个元素做下沉调整即可。

![](.\images\堆构造过程.png)

![](.\images\堆构造过程2.png)

**堆排序过程**

对构造好的堆，我们只需要做类似于堆的删除操作，就可以完成排序。

1. 将堆顶元素和堆中最后一个元素交换位置；

2. 通过对堆顶元素下沉调整堆，把最大的元素放到堆顶(此时最后一个元素不参与堆的调整，因为最大的数据已经到了数组的最右边)

3. 重复1~2步骤，直到堆中剩最后一个元素。

![](.\images\堆排序过程.png)

![](.\images\堆排序过程2.png)

![](.\images\堆排序过程3.png)

![](.\images\堆排序过程4.png)

**代码：**

```java
public class HeapSort {
    //判断heap堆中索引i处的元素是否小于索引j处的元素
    private static boolean less(Comparable[] heap, int i, int j) {
        return heap[i].compareTo(heap[j]) < 0;
    }

    //交换heap堆中i索引和j索引处的值
    private static void exch(Comparable[] heap, int i, int j) {
        Comparable tmp = heap[i];
        heap[i] = heap[j];
        heap[j] = tmp;
    }


    //根据原数组source，构造出堆heap
    private static void createHeap(Comparable[] source, Comparable[] heap) {
        //把source中的元素拷贝到heap中，heap中的元素就形成一个无序的堆
        System.arraycopy(source, 0, heap, 1, source.length);

        //对堆中的元素做下沉调整(从长度的一半处开始，往索引1处扫描)
        for (int i = (heap.length) / 2; i > 0; i--) {
            sink(heap, i, heap.length - 1);
        }

    }


    //对source数组中的数据从小到大排序
    public static void sort(Comparable[] source) {
        //构建堆
        Comparable[] heap = new Comparable[source.length + 1];
        createHeap(source, heap);
        //定义一个变量，记录未排序的元素中最大的索引
        int N = heap.length - 1;
        //通过循环，交换1索引处的元素和排序的元素中最大的索引处的元素
        while (N != 1) {
            //交换元素
            exch(heap, 1, N);
            //排序交换后最大元素所在的索引，让它不要参与堆的下沉调整
            N--;
            //需要对索引1处的元素进行对的下沉调整
            sink(heap, 1, N);
        }

        //把heap中的数据复制到原数组source中
        System.arraycopy(heap, 1, source, 0, source.length);

    }


    //在heap堆中，对target处的元素做下沉，范围是0~range
    private static void sink(Comparable[] heap, int target, int range) {

        while (2 * target <= range) {
            //1.找出当前结点的较大的子结点
            int max;
            if (2 * target + 1 <= range) {
                if (less(heap, 2 * target, 2 * target + 1)) {
                    max = 2 * target + 1;
                } else {
                    max = 2 * target;
                }
            } else {
                max = 2 * target;
            }

            //2.比较当前结点的值和较大子结点的值
            if (!less(heap, target, max)) {
                break;
            }

            exch(heap, target, max);

            target = max;
        }
    }

}
```

# 优先队列

普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在某些情况下，我们可能需要找出  队列中的最大值或者最小值，例如使用一个队列保存计算机的任务，一般情况下计算机的任务都是有优先级的，我们需要在这些计算机的任务中找出优先级最高的任务先执行，执行完毕后就需要把这个任务从队列中移除。普通的  队列要完成这样的功能，需要每次遍历队列中的所有元素，比较并找出最大值，效率不是很高，这个时候，我们就可以使用一种特殊的队列来完成这种需求，优先队列。

![](.\images\优先队列.png)

优先队列按照其作用不同，可以分为以下两种： 

最大优先队列：

可以获取并删除队列中最大的值

最小优先队列：

可以获取并删除队列中最小的值

## 最大优先队列

我们之前学习过堆，而堆这种结构是可以方便的删除最大的值，所以，接下来我们可以基于堆区实现最大优先队列。

**最大优先队列 API 设计**

| **类名** | **MaxPriorityQueue>**                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | MaxPriorityQueue(int capacity)：创建容量为capacity的MaxPriorityQueue对象 |
| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br />2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br />3.public T delMax():删除队列中最大的元素,并返回这个最大元素<br />4.public void insert(T t)：往队列中插入一个元素<br />5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br />6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br />7.public int size():获取队列中元素的个数<br />8.public boolean isEmpty():判断队列是否为空 |
| 成员变量 | 1. private T[] imtes : 用来存储元素的数组<br />2. private int N：记录堆中元素的个数 |

**最大优先队列代码实现**

```java
public class MaxPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;


    public MaxPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity + 1];
        this.N = 0;
    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return N == 0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j) {
        return items[i].compareTo(items[j]) < 0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i, int j) {
        T tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }

    //往堆中插入一个元素
    public void insert(T t) {
        items[++N] = t;
        swim(N);
    }

    //删除堆中最大的元素,并返回这个最大元素
    public T delMax() {
        T max = items[1];
        exch(1, N);
        N--;
        sink(1);
        return max;
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k) {
        while (k > 1) {
            if (less(k / 2, k)) {
                exch(k / 2, k);
            }

            k = k / 2;
        }
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k) {

        while (2 * k <= N) {
            int max;
            if (2 * k + 1 <= N) {
                if (less(2 * k, 2 * k + 1)) {
                    max = 2 * k + 1;
                } else {
                    max = 2 * k;
                }
            } else {
                max = 2 * k;
            }


            if (!less(k, max)) {
                break;
            }

            exch(k, max);

            k = max;
        }
    }

}

public class MaxPriorityQueueTest {

    public static void main(String[] args) {
        //创建优先队列
        MaxPriorityQueue<String> queue = new MaxPriorityQueue<>(10);

        //往队列中存储元素
        queue.insert("A");
        queue.insert("B");
        queue.insert("C");
        queue.insert("D");
        queue.insert("E");
        queue.insert("F");
        queue.insert("G");

        //通过循环从队列中获取最大的元素
        while (!queue.isEmpty()) {
            String max = queue.delMax();
            System.out.print(max + " ");
        }

    }
}
```

## 最小优先队列

最小优先队列实现起来也比较简单，我们同样也可以基于堆来完成最小优先队列。 我们前面学习堆的时候，堆中存放数据元素的数组要满足都满足如下特性：

1. **最大的元素放在数组的索引 1 处。**
2. **每个结点的数据总是大于等于它的两个子结点的数据。**

![](.\images\最大优先队列.png)

其实我们之前实现的堆可以把它叫做最大堆，我们可以用相反的思想实现最小堆，让堆中存放数据元素的数组满足  如下特性：

1. **最小的元素放在数组的索引 1 处。**
2. **每个结点的数据总是小于等于它的两个子结点的数据。**

![](.\images\最小优先队列.png)

这样我们就能快速的访问到堆中最小的数据。

**最小优先队列 API 设计**

| **类名** | **MinPriorityQueue>**                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | MinPriorityQueue(int capacity)：创建容量为capacity的MinPriorityQueue对象 |
| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br />2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br />3.public T delMin():删除队列中最小的元素,并返回这个最小元素<br />4.public void insert(T t)：往队列中插入一个元素<br />5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br />6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br />7.public int size():获取队列中元素的个数<br />8.public boolean isEmpty():判断队列是否为空 |
| 成员变量 | 1. private T[] imtes : 用来存储元素的数组<br />2. private int N：记录堆中元素的个数 |

**最小优先队列代码实现**

```java
public class MinPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //记录堆中元素的个数
    private int N;


    public MinPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity + 1];
        this.N = 0;
    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return N == 0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j) {
        return items[i].compareTo(items[j]) < 0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i, int j) {
        T tmp = items[i];
        items[i] = items[j];
        items[j] = tmp;
    }

    //往堆中插入一个元素
    public void insert(T t) {
        items[++N] = t;
        swim(N);
    }

    //删除堆中最小的元素,并返回这个最小元素
    public T delMin() {
        T min = items[1];
        exch(1, N);
        N--;
        sink(1);
        return min;
    }

    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k) {
        //通过循环比较当前结点和其父结点的大小

        while (k > 1) {

            if (less(k, k / 2)) {
                exch(k, k / 2);
            }

            k = k / 2;
        }
    }

    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k) {
        //通过循环比较当前结点和其子结点中的较小值

        while (2 * k <= N) {
            //1.找到子结点中的较小值
            int min;
            if (2 * k + 1 <= N) {
                if (less(2 * k, 2 * k + 1)) {
                    min = 2 * k;
                } else {
                    min = 2 * k + 1;
                }
            } else {
                min = 2 * k;
            }

            //2.判断当前结点和较小值的大小

            if (less(k, min)) {
                break;
            }

            exch(k, min);

            k = min;
        }
    }
}

public class MinPriorityQueueTest {

    public static void main(String[] args) {

        //创建最小优先队列对象
        MinPriorityQueue<String> queue = new MinPriorityQueue<String>(10);
        //往队列中存数据
        queue.insert("G");
        queue.insert("F");
        queue.insert("E");
        queue.insert("D");
        queue.insert("C");
        queue.insert("B");
        queue.insert("A");

        //通过循环获取最小优先队列中的元素
        while (!queue.isEmpty()) {
            String min = queue.delMin();
            System.out.print(min + " ");
        }

    }
}
```

## 索引优先队列

在之前实现的最大优先队列和最小优先队列，他们可以分别快速访问到队列中最大元素和最小元素，但是他们有一个缺点，就是没有办法通过索引访问已存在于优先队列中的对象，并更新它们。为了实现这个目的，在优先队列的基础上，学习一种新的数据结构，索引优先队列。接下来我们以最小索引优先队列举列。

**索引优先队列实现思路**

**步骤一：**

存储数据时，给每一个数据元素关联一个整数，例如insert(int  k,T  t),我们可以看做k是t关联的整数，那么我们的实现需要通过k这个值，快速获取到队列中t这个元素，此时k这个值需要具有唯一性。

最直观的想法就是我们可以用一个T[] items数组来保存数据元素，在insert(int k,T t)完成插入时，可以把k看做是items数组的索引，把t元素放到items数组的索引k处，这样我们再根据k获取元素t时就很方便了，直接就可以拿到items[k]即可。

![](.\images\索引优先队列实现思路步骤一.png)

**步骤二：**

步骤一完成后的结果，虽然我们给每个元素关联了一个整数，并且可以使用这个整数快速的获取到该元素，但是， items数组中的元素顺序是随机的，并不是堆有序的，所以，为了完成这个需求，我们可以增加一个数组int[]pq,来  保存每个元素在items数组中的索引，pq数组需要堆有序，也就是说，pq[1]对应的数据元素items[pq[1]]要小于等于pq[2]和pq[3]对应的数据元素items[pq[2]]和items[pq[3]]。

![](.\images\索引优先队列实现思路步骤二.png)

**步骤三：**

通过步骤二的分析，我们可以发现，其实我们通过上浮和下沉做堆调整的时候，其实调整的是pq数组。如果需要对items中的元素进行修改，比如让items[0]=“H”,那么很显然，我们需要对pq中的数据做堆调整，而且是调整pq[9]中元素的位置。但现在就会遇到一个问题，我们修改的是items数组中0索引处的值，如何才能快速的知道需要挑中pq[9]中元素的位置呢？

最直观的想法就是遍历pq数组，拿出每一个元素和0做比较，如果当前元素是0，那么调整该索引处的元素即可，  但是效率很低。

我们可以另外增加一个数组，int[] qp,用来存储pq的逆序。例如： 在pq数组中：pq[1]=6;

那么在qp数组中，把6作为索引，1作为值，结果是：qp[6]=1;

![](.\images\索引优先队列实现思路步骤三.png)

当有了pq数组后，如果我们修改items[0]="H"，那么就可以先通过索引0，在qp数组中找到qp的索引：qp[0]=9,  那么直接调整pq[9]即可。

**索引优先队列 API 设计**

| **类名** | **IndexMinPriorityQueue>**                                   |
| -------- | ------------------------------------------------------------ |
| 构造方法 | IndexMinPriorityQueue(int capacity)：创建容量为capacity的IndexMinPriorityQueue对象 |
| 成员方法 | 1.private boolean less(int i,int j)：判断堆中索引i处的元素是否小于索引j处的元素<br />2.private void exch(int i,int j):交换堆中i索引和j索引处的值<br />3.public int delMin():删除队列中最小的元素,并返回该元素关联的索引<br />4.public void insert(int i,T t)：往队列中插入一个元素,并关联索引i<br />5.private void swim(int k):使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置<br />6.private void sink(int k):使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置<br />7.public int size():获取队列中元素的个数<br />8. public boolean isEmpty():判断队列是否为空<br />9. public boolean contains(int k):判断k对应的元素是否存在<br />10.public void changeItem(int i, T t):把与索引i关联的元素修改为t <br />11.public int minIndex():最小元素关联的索引<br />12.public void delete(int i):删除索引i关联的元素 |
| 成员变量 | 1. private T[] items : 用来存储元素的数组<br />2. private int[] pq:保存每个元素在items数组中的索引，pq数组需要堆有序<br />3.private int [] qp:保存pq的逆序，pq的值作为索引<br />4.private int N：记录堆中元素的个数 |

**索引优先队列代码实现**

```java
public class IndexMinPriorityQueue<T extends Comparable<T>> {
    //存储堆中的元素
    private T[] items;
    //保存每个元素在items数组中的索引，pq数组需要堆有序
    private int[] pq;
    //保存qp的逆序，pq的值作为索引，pq的索引作为值
    private int[] qp;
    //记录堆中元素的个数
    private int N;


    public IndexMinPriorityQueue(int capacity) {
        this.items = (T[]) new Comparable[capacity+1];
        this.pq = new int[capacity+1];
        this.qp= new int[capacity+1];
        this.N = 0;

        //默认情况下，队列中没有存储任何数据，让qp中的元素都为-1；
        for (int i = 0; i < qp.length; i++) {
            qp[i]=-1;
        }

    }

    //获取队列中元素的个数
    public int size() {
        return N;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return N==0;
    }

    //判断堆中索引i处的元素是否小于索引j处的元素
    private boolean less(int i, int j) {

        return items[pq[i]].compareTo(items[pq[j]])<0;
    }

    //交换堆中i索引和j索引处的值
    private void exch(int i, int j) {
        //交换pq中的数据
        int tmp = pq[i];
        pq[i] = pq[j];
        pq[j] = tmp;


        //更新qp中的数据
        qp[pq[i]]=i;
        qp[pq[j]] =j;

    }

    //判断k对应的元素是否存在
    public boolean contains(int k) {

        return qp[k] !=-1;
    }

    //最小元素关联的索引
    public int minIndex() {

        return pq[1];
    }


    //往队列中插入一个元素,并关联索引i
    public void insert(int i, T t) {
        //判断i是否已经被关联，如果已经被关联，则不让插入

        if (contains(i)){
            return;
        }
        //元素个数+1
        N++;
        //把数据存储到items对应的i位置处
        items[i] = t;
        //把i存储到pq中
        pq[N] = i;
        //通过qp来记录pq中的i
        qp[i]=N;

        //通过堆上浮完成堆的调整

        swim(N);

    }

    //删除队列中最小的元素,并返回该元素关联的索引
    public int delMin() {
        //获取最小元素关联的索引
        int minIndex = pq[1];

        //交换pq中索引1处和最大索引处的元素
        exch(1,N);
        //删除qp中对应的内容
        qp[pq[N]] = -1;
        //删除pq最大索引处的内容
        pq[N]=-1;
        //删除items中对应的内容
        items[minIndex] = null;
        //元素个数-1
        N--;
        //下沉调整
        sink(1);

        return minIndex;
    }

    //删除索引i关联的元素
    public void delete(int i) {
        //找到i在pq中的索引
        int k = qp[i];

        //交换pq中索引k处的值和索引N处的值
        exch(k,N);
        //删除qp中的内容
        qp[pq[N]] = -1;
        //删除pq中的内容
        pq[N]=-1;
        //删除items中的内容
        items[k]=null;
        //元素的数量-1
        N--;
        //堆的调整
        sink(k);
        swim(k);
    }

    //把与索引i关联的元素修改为为t
    public void changeItem(int i, T t) {
        //修改items数组中i位置的元素为t
        items[i] = t;
        //找到i在pq中出现的位置
        int k = qp[i];
        //堆调整
        sink(k);
        swim(k);
    }


    //使用上浮算法，使索引k处的元素能在堆中处于一个正确的位置
    private void swim(int k) {
        while(k>1){
            if (less(k,k/2)){
                exch(k,k/2);
            }

            k = k/2;
        }
    }


    //使用下沉算法，使索引k处的元素能在堆中处于一个正确的位置
    private void sink(int k) {
        while(2*k<=N){
            //找到子结点中的较小值
            int min;
            if (2*k+1<=N){
                if (less(2*k,2*k+1)){
                    min = 2*k;
                }else{
                    min = 2*k+1;
                }
            }else{
                min = 2*k;
            }
            //比较当前结点和较小值
            if (less(k,min)){
                break;
            }

            exch(k,min);
            k = min;
        }
    }

}

public class IndexMinPriorityQueueTest {

    public static void main(String[] args) {
        //创建索引最小优先队列对象
        IndexMinPriorityQueue<String> queue = new IndexMinPriorityQueue<>(10);

        //往队列中添加元素
        queue.insert(0,"A");
        queue.insert(1,"C");
        queue.insert(2,"F");

        //测试修改
        queue.changeItem(2,"B");

        //测试删除
        while(!queue.isEmpty()){
            int index = queue.delMin();
            System.out.print(index+" ");
        }
    }
}
```

# 平衡树

之前我们学习过二叉查找树，发现它的查询效率比单纯的链表和数组的查询效率要高很多，大部分情况下，确实是这样的，但不幸的是，在最坏情况下，二叉查找树的性能还是很糟糕。

例如我们依次往二叉查找树中插入9,8,7,6,5,4,3,2,1这9个数据，那么最终构造出来的树是长得下面这个样子：

![](.\images\二叉查找树的最坏情况.png)

我们会发现，如果我们要查找1这个元素，查找的效率依旧会很低。效率低的原因在于这个树并不平衡，全部是向左边分支，如果我们有一种方法，能够不受插入数据的影响，让生成的树都像完全二叉树那样，那么即使在最坏情况下，查找的效率依旧会很好。

## 2-3 查找树

为了保证查找树的平衡性，我们需要一些灵活性，因此在这里我们允许树中的一个结点保存多个键。确切的说，我们将一棵标准的二叉查找树中的结点称为2-结点(含有一个键和两条链)，而现在我们引入3-结点，它含有两个键和三条链。2-结点和3-结点中的每条链都对应着其中保存的键所分割产生的一个区间。

### 2-3 查找树的定义

一棵2-3查找树要么为空，要么满足下面两个要求：

**2-结点：**

含有一个键(及其对应的值)和两条链，左链接指向2-3树中的键都小于该结点，右链接指向的2-3树中的键都大  于该结点。

**3-结点：**

含有两个键(及其对应的值)和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。

![](.\images\2-3查找树的定义.png)

### 查找

将二叉查找树的查找算法一般化我们就能够直接得到2-3树的查找算法。要判断一个键是否在树中，我们先将它和  根结点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的连  接，并在其指向的子树中递归地继续查找。如果这个是空链接，查找未命中。

![](.\images\2-3查找树的查找.png)

### 插入

#### 向 2-结点中插入新键

往2-3树中插入元素和往二叉查找树中插入元素一样，首先要进行查找，然后将节点挂到未找到的节点上。2-3树之  所以能够保证在最差的情况下的效率的原因在于其插入之后仍然能够保持平衡状态。如果查找后未找到的节点是一  个2-结点，那么很容易，我们只需要将新的元素放到这个2-结点里面使其变成一个3-结点即可。但是如果查找的节  点结束于一个3-结点，那么可能有点麻烦。

![](.\images\向 2-结点中插入新键.png)

#### 向一棵只含有一个 3-结点的树中插入新键

假设2-3树只包含一个3-结点，这个结点有两个键，没有空间来插入第三个键了，最自然的方式是我们假设这个结  点能存放三个元素，暂时使其变成一个4-结点，同时他包含四条链接。然后，我们将这个4-结点的中间元素提升，  左边的键作为其左子结点，右边的键作为其右子结点。插入完成，变为平衡2-3查找树，树的高度从0变为1。

![](.\images\向一棵只含有一个 3-结点的树中插入新键.png)

#### 向一个父结点为 2-结点的3-结点中插入新键

和上面的情况一样，我们也可以将新的元素插入到3-结点中，使其成为一个临时的4-结点，然后，将该结点中  的中间元素提升到父结点即2-结点中，使其父结点成为一个3-结点，然后将左右结点分别挂在这个3-结点的恰当位置。

![](.\images\向一个父结点为 2-结点的3-结点中插入新键.png)

#### 向一个父结点为 3-结点的3-结点中插入新键

当我们插入的结点是3-结点的时候，我们将该结点拆分，中间元素提升至父结点，但是此时父结点是一个3-结点，  插入之后，父结点变成了4-结点，然后继续将中间元素提升至其父结点，直至遇到一个父结点是2-结点，然后将其  变为3-结点，不需要继续进行拆分。

![](.\images\向一个父结点为 3-结点的3-结点中插入新键.png)

![](.\images\向一个父结点为 3-结点的3-结点中插入新键2.png)

#### 分解根结点

当插入结点到根结点的路径上全部是3-结点的时候，最终我们的根结点会变成一个临时的4-结点，此时，就需要将根结点拆分为两个2-结点，树的高度加1。

![](.\images\分解根结点.png)

### 2-3 树的性质

通过对2-3树插入操作的分析，我们发现在插入的时候，2-3树需要做一些局部的变换来保持2-3树的平衡。  一棵完全平衡的2-3树具有以下性质：

1. 任意空链接到根结点的路径长度都是相等的。
2. 4-结点变换为3-结点时，树的高度不会发生变化，只有当根结点是临时的4-结点，分解根结点时，树高+1。
3. 2-3树与普通二叉查找树最大的区别在于，普通的二叉查找树是自顶向下生长，而2-3树是自底向上生长。

### 2-3 树的实现

直接实现2-3树比较复杂，因为：

- 需要处理不同的结点类型，非常繁琐； 
- 需要多次比较操作来将结点下移；
- 需要上移来拆分4-结点；
- 拆分4-结点的情况有很多种；

2-3查找树实现起来比较复杂，在某些情况插入后的平衡操作可能会使得效率降低。但是2-3查找树作为一种比较重要的概念和思路对于我们后面要讲到的红黑树、B树和B+树非常重要。

## 红黑树

我们前面介绍了2-3树，可以看到2-3树能保证在插入元素之后，树依然保持平衡状态，它的最坏情况下所有子结点  都是2-结点，树的高度为lgN,相比于我们普通的二叉查找树，最坏情况下树的高度为N，确实保证了最坏情况下的时间复杂度，但是2-3树实现起来过于复杂，所以我们介绍一种2-3树思想的简单实现：红黑树。

红黑树主要是对2-3树进行编码，红黑树背后的基本思想是用标准的二叉查找树(完全由2-结点构成)和一些额外的信息(替换3-结点)来表示2-3树。我们将树中的链接分为两种类型：

**红链接：**将两个2-结点连接起来构成一个3-结点； **黑链接：**则是2-3树中的普通链接。

确切的说，我们将3-结点表示为由由一条**左斜**的红色链接(两个2-结点其中之一是另一个的左子结点)相连的两个2- 结点。这种表示法的一个优点是，我们无需修改就可以直接使用标准的二叉查找树的get方法。

![](.\images\红黑树.png)

### 红黑树的定义

红黑树是含有红黑链接并满足下列条件的二叉查找树：

1. 红链接均为左链接；

2. 没有任何一个结点同时和两条红链接相连；

3. 该树是完美黑色平衡的，即任意空链接到根结点的路径上的黑链接数量相同；

下面是红黑树与2-3树的对应关系：

![](.\images\红黑树的定义.png)

### 红黑树结点 API

因为每个结点都只会有一条指向自己的链接（从它的父结点指向它），我们可以在之前的Node结点中添加一个布  尔类型的变量color来表示链接的颜色。如果指向它的链接是红色的，那么该变量的值为true，如果链接是黑色的，那么该变量的值为false。

![](.\images\链接的颜色.png)

**API 设计：**

| **类名** | **Node<Key,Value>**                                          |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Node(Key key, Value value, Node left, Node right，boolean color)：创建Node对象 |
| 成员变量 | 1.public Node left:记录左子结点<br />2.public Node right:记录右子结点<br />3.public Key key:存储键<br />4. public Value value:存储值<br />5. public boolean color:由其父结点指向它的链接的颜色 |

**代码：**

```java
//结点类
private class Node<Key,Value> {
    //存储键
    public Key key;
    //存储值
    private Value value;
    //记录左子结点
    public Node left;
    //记录右子结点
    public Node right;
    //由其父结点指向它的链接的颜色
    public boolean color;

    public Node(Key key, Value value, Node left, Node right, boolean color) {
        this.key = key;
        this.value = value;
        this.left = left;
        this.right = right;
        this.color = color;
    }
}
```

### 平衡化

在对红黑树进行一些增删改查的操作后，很有可能会出现红色的右链接或者两条连续红色的链接，而这些都不满足红黑树的定义，所以我们需要对这些情况通过旋转进行修复，让红黑树保持平衡。

#### 左旋

当某个结点的左子结点为黑色，右子结点为红色，此时需要左旋。

**前提：**当前结点为h，它的右子结点为x；

**左旋过程：**

1. 让x的左子结点变为h的右子结点：h.right=x.left; 
2. 让h成为x的左子结点：x.left=h;
3. 让h的color属性变为x的color属性值：x.color=h.color;
4. 让h的color属性变为RED：h.color=true;

![](.\images\左旋过程.png)

#### 右旋

当某个结点的左子结点是红色，且左子结点的左子结点也是红色，需要右旋

**前提：**当前结点为h，它的左子结点为x；

**右旋过程：**

1. 让x的右子结点成为h的左子结点：h.left = x.right;
2. 让h成为x的右子结点：x.right=h;
3. 让x的color变为h的color属性值：x.color = h.color;
4. 让h的color为RED；

![](.\images\右旋过程.png)

### 向单个 2-结点中插入新键

一棵只含有一个键的红黑树只含有一个2-结点。插入另一个键后，我们马上就需要将他们旋转。

- 如果新键小于当前结点的键，我们只需要新增一个红色结点即可，新的红黑树和单个3-结点完全等价。

![](.\images\向单个2-结点中插入新键1.png)

- 如果新键大于当前结点的键，那么新增的红色结点将会产生一条红色的右链接，此时我们需要通过左旋，把红色右链接变成左链接，插入操作才算完成。形成的新的红黑树依然和3-结点等价，其中含有两个键，一条红色链接。

![](.\images\向单个2-结点中插入新键2.png)

### 向底部的 2- 结点插入新键

用和二叉查找树相同的方式向一棵红黑树中插入一个新键，会在树的底部新增一个结点（可以保证有序性），唯一区别的地方是我们会用红链接将新结点和它的父结点相连。如果它的父结点是一个2-结点，那么刚才讨论的两种方式仍然适用。

![](.\images\向底部的2-结点插入新键.png)

### 颜色反转

当一个结点的左子结点和右子结点的color都为RED时，也就是出现了临时的4-结点，此时只需要把左子结点和右子  结点的颜色变为BLACK，同时让当前结点的颜色变为RED即可。

![](.\images\颜色反转.png)

### 向一棵双键树 (即一个3-结点)中插入新键

这种情况有可以分为三种子情况：

1. 新键大于原树中的两个键

![](.\images\新键大于原树中的两个键.png)

2. 新键小于原树中的两个键

![](.\images\新键小于原树中的两个键.png)

3. 新键介于原数中两个键之间

![](.\images\新键介于原数中两个键之间.png)

### 根结点的颜色总是黑色

之前我们介绍结点API的时候，在结点Node对象中color属性表示的是父结点指向当前结点的连接的颜色，由于根  结点不存在父结点，所以每次插入操作后，我们都需要把根结点的颜色设置为黑色。

### 向树底部的 3-结点插入新键

假设在树的底部的一个3-结点下加入一个新的结点。前面我们所讲的3种情况都会出现。指向新结点的链接可能是  3-结点的右链接（此时我们只需要转换颜色即可），或是左链接(此时我们需要进行右旋转然后再转换)，或是中链  接(此时需要先左旋转然后再右旋转，最后转换颜色)。颜色转换会使中间结点的颜色变红，相当于将它送入了父结  点。这意味着父结点中继续插入一个新键，我们只需要使用相同的方法解决即可，直到遇到一个2-结点或者根结点  为止。

![](.\images\向树底部的3-结点插入新键1.png)

![](.\images\向树底部的3-结点插入新键2.png)

### 红黑树的 API 设计

| **类名** | **RedBlackTree, Value>**                                     |
| -------- | ------------------------------------------------------------ |
| 构造方法 | RedBlackTree()：创建RedBlackTree对象                         |
| 成员方法 | 1.private boolean isRed(Node x)：判断当前结点的父指向链接是否为红色<br />2.private Node rotateLeft(Node h):左旋调整<br />3. private Node rotateRight(Node h):右旋调整<br />4. private void ﬂipColors(Node h)：颜色反转,相当于完成拆分4-结点<br />5.public void put(Key key, Value val):在整个树上完成插入操作<br />6. private Node put(Node h, Key key, Value val):在指定树中，完成插入操作,并返回添加元素后新的树<br />7. public Value get(Key key):根据key，从树中找出对应的值<br />8. private Value get(Node x, Key key):从指定的树x中，找出key对应的值<br />9.public int size():获取树中元素的个数 |
| 成员变量 | 1. private Node root : 记录根结点<br />2. private int N:记录树中元素的个数<br />3. private static ﬁnal boolean RED：红色链接标识<br />4.private static ﬁnal boolean BLACK:黑色链接标识 |

### 红黑树的实现

```java
public class RedBlackTree<Key extends Comparable<Key>, Value> {
    //根节点
    private Node root;
    //记录树中元素的个数
    private int N;
    //红色链接
    private static final boolean RED = true;
    //黑色链接
    private static final boolean BLACK = false;


    //结点类
    private class Node {
        //存储键
        public Key key;
        //存储值
        private Value value;
        //记录左子结点
        public Node left;
        //记录右子结点
        public Node right;
        //由其父结点指向它的链接的颜色
        public boolean color;

        public Node(Key key, Value value, Node left, Node right, boolean color) {
            this.key = key;
            this.value = value;
            this.left = left;
            this.right = right;
            this.color = color;
        }
    }


    //获取树中元素的个数
    public int size() {
        return N;
    }


    /**
     * 判断当前节点的父指向链接是否为红色
     *
     * @param x
     * @return
     */
    private boolean isRed(Node x) {
        if (x==null){
            return false;
        }
        return x.color==BLACK;
    }

    /**
     * 左旋转
     *
     * @param h
     * @return
     */
    private Node rotateLeft(Node h) {
        //找到h结点的右子结点x
        Node x = h.right;
        //找到x结点的左子结点，让x结点的左子结点称为h结点的右子结点
        h.right = x.left;
        //让h结点称为x结点的左子结点
        x.left = h;
        //让x结点的color属性变为h结点的color属性
        x.color = h.color;
        //让h结点的color属性变为RED
        h.color = RED;

        return x;
    }

    /**
     * 右旋
     *
     * @param h
     * @return
     */
    private Node rotateRight(Node h) {
        //找到h结点的左子结点 x
        Node x = h.left;
        //让x结点的右子结点成为h结点的左子结点
        h.left = x.right;
        //让h结点成为x结点的右子结点
        x.right = h;
        //让x结点的color属性变为h结点的color属性
        x.color = h.color;
        //让h结点的color属性为RED
        h.color = RED;

        return x;
    }

    /**
     * 颜色反转,相当于完成拆分4-节点
     *
     * @param h
     */
    private void flipColors(Node h) {
        //当前结点变为红色
        h.color = RED;
        //左子结点和右子结点变为黑色
        h.left.color=BLACK;
        h.right.color = BLACK;
    }

    /**
     * 在整个树上完成插入操作
     *
     * @param key
     * @param val
     */
    public void put(Key key, Value val) {
        root = put(root,key,val);
        //根结点的颜色总是黑色
        root.color = RED;
    }

    /**
     * 在指定树中，完成插入操作,并返回添加元素后新的树
     *
     * @param h
     * @param key
     * @param val
     */
    private Node put(Node h, Key key, Value val) {
        //判断h是否为空，如果为空则直接返回一个红色的结点就可以了
        if (h == null){
            //数量+1
            N++;
            return new Node(key,val,null,null,RED);
        }

        //比较h结点的键和key的大小
        int cmp = key.compareTo(h.key);
        if (cmp<0){
            //继续往左
            h.left = put(h.left,key,val);

        }else if (cmp>0){
            //继续往右
            h.right = put(h.right,key,val);

        }else{
            //发生值的替换
            h.value = val;
        }

        //进行左旋:当当前结点h的左子结点为黑色，右子结点为红色，需要左旋
        if (isRed(h.right) && !isRed(h.left)){
            h = rotateLeft(h);
        }

        //进行右旋：当当前结点h的左子结点和左子结点的左子结点都为红色，需要右旋
        if (isRed(h.left) && isRed(h.left.left)){
            h = rotateRight(h);
        }

        //颜色反转：当前结点的左子结点和右子结点都为红色时，需要颜色反转
        if (isRed(h.left) && isRed(h.right)){
            flipColors(h);
        }



        return h;
    }

    //根据key，从树中找出对应的值
    public Value get(Key key) {
        return get(root,key);
    }

    //从指定的树x中，查找key对应的值
    public Value get(Node x, Key key) {
        if (x == null){
            return null;
        }

        //比较x结点的键和key的大小
        int cmp = key.compareTo(x.key);
        if (cmp<0){
            return get(x.left,key);
        }else if (cmp>0){
            return get(x.right,key);
        }else{
           return x.value;
        }

    }

}

public class RedBlackTreeTest {

    public static void main(String[] args) {
        //创建红黑树
        RedBlackTree<String, String> tree = new RedBlackTree<>();

        //往树中插入元素
        tree.put("1","张三");
        tree.put("2","李四");
        tree.put("3","王五");
        //从树中获取元素
        String r1 = tree.get("1");
        System.out.println(r1);


        String r2 = tree.get("2");
        System.out.println(r2);

        String r3 = tree.get("3");
        System.out.println(r3);
    }
}
```

# B-树

前面我们已经学习了二叉查找树、2-3树以及它的实现红黑树。2-3树中，一个结点最多能有两个key，它的实现红黑树中使用对链接染色的方式去表达这两个key。接下来我们学习另外一种树型结构B树，这种数据结构中，一个结点允许多于两个key的存在。

B树是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(logn)的时间复杂度进行查找、顺序读取、插入和删除等操作。

## B 树的特性

B树中允许一个结点中包含多个key，可以是3个、4个、5个甚至更多，并不确定，需要看具体的实现。现在我们选择一个参数M，来构造一个B树，我们可以把它称作是M阶的B树，那么该树会具有如下特点：

- 每个结点最多有M-1个key，并且以升序排列；
- 每个结点最多能有M个子结点；
- 根结点至少有两个子结点；

![](.\images\B树的特性.png)

在实际应用中B树的阶数一般都比较大（通常大于100），所以，即使存储大量的数据，B树的高度仍然比较小，这样在某些应用场景下，就可以体现出它的优势。

## B树存储数据

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B树为例，看看B树的数据存储。

![](.\images\B树存储数据.png)

## B树在磁盘文件中的应用

在我们的程序中，不可避免的需要通过IO操作文件，而我们的文件是存储在磁盘上的。计算机操作磁盘上的文件是通过文件系统进行操作的，在文件系统中就使用到了B树这种数据结构。

### 磁盘

磁盘能够保存大量的数据，从GB一直到TB级，但是他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级 。

![](.\images\磁盘.png)

磁盘由盘片构成,每个盘片有两面，又称为盘面  。盘片中央有一个可以旋转的主轴，他使得盘片以固定的旋转速率旋转，通常是5400rpm或者是7200rpm,一个磁盘中包含了多个这样的盘片并封装在一个密封的容器内  。盘片的每个表面是由一组称为磁道同心圆组成的  ，每个磁道被划分为了一组扇区  ，每个扇区包含相等数量的数据位，通常是512个子节，扇区之间由一些间隙隔开,这些间隙中不存储数据 。

<center><img src=".\images\磁盘结构.png" style="zoom:50%;" /> <img src=".\images\磁道.png" style="zoom:50%;" /> <img src=".\images\单个扇区.png" style="zoom:50%;" /></center>



### 磁盘 IO

![](.\images\磁盘IO.png)

磁盘用磁头来读写存储在盘片表面的位，而磁头连接到一个移动臂上，移动臂沿着盘片半径前后移动，可以将磁头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到该位的值，也可以修改值。对磁盘的访问时间分为 **寻道时间**，**旋转时间**，以及**传送时间**。

由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I/O，减少读写操作。 为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的  局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。由于磁盘顺序读取的效率很高（不需要寻  道时间，只需很少的旋转时间），因此预读可以提高I/O效率。

页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储  块称为一页（1024个字节或其整数倍），预读的长度一般为页的整倍数。主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。

文件系统的设计者利用了磁盘预读原理，将一个结点的大小设为等于一个页（1024个字节或其整数倍），这样每个结点只需要一次I/O就可以完全载入。那么3层的B树可以容纳1024 * 1024 * 1024差不多10亿个数据，如果换成二  叉查找树，则需要30层！假定操作系统一次读取一个节点，并且根节点保留在内存中，那么B树在10亿个数据中查  找目标值，只需要小于3次硬盘读取就可以找到目标值，但红黑树需要小于30次，因此B树大大提高了IO的操作效率。

# B+树

B+树是对B树的一种变形树，它与B树的差异在于：

1. 非叶结点仅具有索引作用，也就是说，非叶子结点只存储key，不存储value；

2. 树的所有叶结点构成一个有序链表，可以按照key排序的次序遍历全部数据。

## B+ 树存储数据

若参数M选择为5，那么每个结点最多包含4个键值对，我们以5阶B+树为例，看看B+树的数据存储。

![](.\images\B+树存储数据.png)

## B+ 树和 B 树的对比

**B+** **树的优点在于：**

1.由于B+树在非叶子结点上不包含真正的数据，只当做索引使用，因此在内存相同的情况下，能够存放更多的key。  2.B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。

**B 树的优点在于：**

由于B树的每一个节点都包含key和value，因此我们根据key查找value时，只需要找到key所在的位置，就能找到value，但B+树只有叶子结点存储数据，索引每一次查找，都必须一次一次，一直找到树的最大深度处，也就是叶子结点的深度，才能找到value。

## B+ 树在数据库中的应用

在数据库的操作中，查询操作可以说是最频繁的一种操作，因此在设计数据库时，必须要考虑到查询的效率问题，  在很多数据库中，都是用到了B+树来提高查询的效率；

在操作数据库时，我们为了提高查询效率，可以基于某张表的某个字段建立索引，就可以提高查询效率，那其实这  个索引就是B+树这种数据结构实现的。

### 未建立主键索引查询

![](.\images\未建立主键索引查询.png)

执行 `select * from user where id=18`，需要从第一条数据开始，一直查询到第6条，发现id=18，此时才能查询出目标结果，共需要比较6次；

### 建立主键索引查询

![](.\images\建立主键索引查询.png)

### 区间查询

执行`select * from user where id>=12 and id<=18`,如果有了索引，由于B+树的叶子结点形成了一个有序链表，所以我们只需要找到id为12的叶子结点，按照遍历链表的方式顺序往后查即可，效率非常高。

# 并查集

并查集是一种树型的数据结构 ，并查集可以高效地进行如下操作： 

- 查询元素p和元素q是否属于同一组
- 合并元素p和元素q所在的组

![](.\images\并查集.png)

## 并查集结构

并查集也是一种树型结构，但这棵树跟我们之前讲的二叉树、红黑树、B树等都不一样，这种树的要求比较简单：

1. 每个元素都唯一的对应一个结点；

2. 每一组数据中的多个元素都在同一颗树中；

3. 一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系；

4. 元素在树中并没有子父级关系的硬性要求；

![](.\images\并查集结构.png)

## 并查集 API 设计

| **类名** | **UF**                                                       |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF(int N)：初始化并查集，以整数标识(0,N-1)个结点             |
| 成员方法 | 1.public int count()：获取当前并查集中的数据有多少个分组<br />2.public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中<br />3.public int ﬁnd(int p):元素p所在分组的标识符<br />4.public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | 1. private int[] eleAndGroup: 记录结点元素和该元素所在分组的标识<br />2. private int count：记录并查集中数据的分组个数 |

## 并查集的实现

### UF(int N) 构造方法实现

1. 初始情况下，每个元素都在一个独立的分组中，所以，初始情况下，并查集中的数据默认分为N个组；

2. 初始化数组eleAndGroup；

3. 把eleAndGroup数组的索引看做是每个结点存储的元素，把eleAndGroup数组每个索引处的值看做是该结点所在的分组，那么初始化情况下，i索引处存储的值就是i

![](.\images\UF(int N)构造方法实现.png)

### union(int p,int q)合并方法实现

1. 如果p和q已经在同一个分组中，则无需合并

2. 如果p和q不在同一个分组，则只需要将p元素所在组的所有的元素的组标识符修改为q元素所在组的标识符即可

3. 分组数量-1

![](.\images\union(int p,int q)合并方法实现.png)

### 代码

```java
public class UF {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;
    //初始化并查集
    public UF(int N){
        //初始化分组的数量,默认情况下，有N个分组
        this.count = N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];
        //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引
        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i] = i;
        }
    }

    //获取当前并查集中的数据有多少个分组
    public int count(){
        return count;
    }

    //元素p所在分组的标识符
    public int find(int p){
        return eleAndGroup[p];
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connected(int p,int q){
        return find(p) == find(q);
    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p,int q){
        //判断元素q和p是否已经在同一分组中，如果已经在同一分组中，则结束方法就可以了
        if (connected(p,q)){
            return;
        }

        //找到p所在分组的标识符
        int pGroup = find(p);

        //找到q所在分组的标识符
        int qGroup = find(q);

        //合并组：让p所在组的所有元素的组标识符变为q所在分组的标识符
        for (int i = 0; i < eleAndGroup.length; i++) {
            if (eleAndGroup[i]==pGroup){
                eleAndGroup[i] = qGroup;
            }
        }

        //分组个数-1
        this.count--;

    }

}

public class UFTest {

    public static void main(String[] args) {
        //创建并查集对象
        UF uf = new UF(5);
        System.out.println("默认情况下，并查集中有：" + uf.count() + "个分组");
        //从控制台录入两个要合并的元素，调用union方法合并，观察合并后并查集中的分组是否减少
        Scanner sc = new Scanner(System.in);
        while (true) {
            System.out.println("请输入第一个要合并的元素：");
            int p = sc.nextInt();
            System.out.println("请输入第二个要合并的元素：");
            int q = sc.nextInt();
            //判断这两个元素是否已经在同一组了
            if (uf.connected(p, q)) {
                System.out.println(p + "元素和" + q + "元素已经在同一个组中了");
                continue;
            }
            uf.union(p, q);
            System.out.println("当前并查集中还有：" + uf.count() + "个分组");
        }
    }
}
```

## 并查集应用举例

如果我们并查集存储的每一个整数表示的是一个大型计算机网络中的计算机，则我们就可以通过connected(int p,int  q)来检测，该网络中的某两台计算机之间是否连通？如果连通，则他们之间可以通信，如果不连通，则不能通信，此时我们又可以调用union(int p,int q)使得p和q之间连通，这样两台计算机之间就可以通信了。

一般像计算机这样网络型的数据，我们要求网络中的每两个数据之间都是相连通的，也就是说，我们需要调用很多  次union方法，使得网络中所有数据相连，其实我们很容易可以得出，如果要让网络中的数据都相连，则我们至少要调用N-1次union方法才可以，但由于我们的union方法中使用for循环遍历了所有的元素，所以很明显，我们之前实现的合并算法的时间复杂度是O(N^2)，如果要解决大规模问题，它是不合适的，所以我们需要对算法进行优化。

## UF_Tree 算法优化

为了提升union算法的性能，我们需要重新设计ﬁnd方法和union方法的实现，此时我们先需要对我们的之前数据结  构中的eleAndGourp数组的含义进行重新设定：

1. 我们仍然让eleAndGroup数组的索引作为某个结点的元素；

2. eleAndGroup[i]的值不再是当前结点所在的分组标识，而是该结点的父结点；

![](.\images\UF_Tree算法优化.png)

### UF_Tree API 设计

| **类名** | **UF_Tree**                                                  |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF_Tree(int N)：初始化并查集，以整数标识(0,N-1)个结点        |
| 成员方法 | 1. public int count()：获取当前并查集中的数据有多少个分组<br />2. public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中<br />3.public int ﬁnd(int p):元素p所在分组的标识符<br />4.public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | 1. private int[] eleAndGroup: 记录结点元素和该元素的父结点<br />2. private int count：记录并查集中数据的分组个数 |

### ﬁnd(int  p) 查询方法实现 

1. 判断当前元素p的父结点eleAndGroup[p]是不是自己，如果是自己则证明已经是根结点了；

2. 如果当前元素p的父结点不是自己，则让p=eleAndGroup[p]，继续找父结点的父结点,直到找到根结点为止；

![](.\images\ﬁnd(int p)查询方法实现.png)

### union(int  p,int q)合并方法实现

1. 找到p元素所在树的根结点

2. 找到q元素所在树的根结点

3. 如果p和q已经在同一个树中，则无需合并；

4. 如果p和q不在同一个分组，则只需要将p元素所在树根结点的父结点设置为q元素的根结点即可；

5. 分组数量-1

![](.\images\union(int p,int q)合并方法实现2.png)

### 代码

```java
public class UF_Tree {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;

    //初始化并查集
    public UF_Tree(int N) {
        //初始化分组的数量,默认情况下，有N个分组
        this.count = N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];

        //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引

        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i] = i;
        }

    }

    //获取当前并查集中的数据有多少个分组
    public int count() {
        return count;
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    //元素p所在分组的标识符
    public int find(int p) {
        while (true) {

            if (p == eleAndGroup[p]) {
                return p;
            }

            p = eleAndGroup[p];
        }

    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p, int q) {
        //找到p元素和q元素所在组对应的树的根结点

        int pRoot = find(p);
        int qRoot = find(q);

        //如果p和q已经在同一分组，则不需要合并了
        if (pRoot == qRoot) {
            return;
        }

        //让p所在的树的根结点的父结点为q所在树的根结点即可
        eleAndGroup[pRoot] = qRoot;

        //组的数量-1

        this.count--;

    }

}
```

### 优化后的性能分析

我们优化后的算法union，如果要把并查集中所有的数据连通，仍然至少要调用N-1次union方法，但是，我们发现union方法中已经没有了for循环，所以union算法的时间复杂度由O(N^2)变为了O(N)。

但是这个算法仍然有问题，因为我们之前不仅修改了union算法，还修改了ﬁnd算法。我们修改前的ﬁnd算法的时间复杂度在任何情况下都为O(1)，但修改后的ﬁnd算法在最坏情况下是O(N)：

![](.\images\优化后的性能分析.png)

在union方法中调用了ﬁnd方法，所以在最坏情况下union算法的时间复杂度仍然为O(N^2)。

## 路径压缩

UF_Tree中最坏情况下union算法的时间复杂度为O(N^2)，其最主要的问题在于最坏情况下，树的深度和数组的大小一样，如果我们能够通过一些算法让合并时，生成的树的深度尽可能的小，就可以优化ﬁnd方法。

之前我们在union算法中，合并树的时候将任意的一棵树连接到了另外一棵树，这种合并方法是比较暴力的，如果  我们把并查集中每一棵树的大小记录下来，然后在每次合并树的时候，把较小的树连接到较大的树上，就可以减小树的深度。

![](.\images\路径压缩.png)

只要我们保证每次合并，都能把小树合并到大树上，就能够压缩合并后新树的路径，这样就能提高ﬁnd方法的效率。为了完成这个需求，我们需要另外一个数组来记录存储每个根结点对应的树中元素的个数，并且需要一些代码调整数组中的值。

### UF_Tree_Weighted API设计

| **类名** | **UF_Tree_Weighted**                                         |
| -------- | ------------------------------------------------------------ |
| 构造方法 | UF_Tree_Weighted(int N)：初始化并查集，以整数标识(0,N-1)个结点 |
| 成员方法 | 1. public int count()：获取当前并查集中的数据有多少个分组<br />2. public boolean connected(int p,int q):判断并查集中元素p和元素q是否在同一分组中<br />3.public int ﬁnd(int p):元素p所在分组的标识符<br />4.public void union(int p,int q)：把p元素所在分组和q元素所在分组合并 |
| 成员变量 | 1.private int[] eleAndGroup: 记录结点元素和该元素的父结点<br />2.private int[] sz: 存储每个根结点对应的树中元素的个数<br />3.private int count：记录并查集中数据的分组个数 |

### 代码

```java
public class UF_Tree_Weighted {
    //记录结点元素和该元素所在分组的标识
    private int[] eleAndGroup;
    //记录并查集中数据的分组个数
    private int count;

    //用来存储每一个根结点对应的树中保存的结点的个数
    private int[] sz;

    //初始化并查集
    public UF_Tree_Weighted(int N) {
        //初始化分组的数量,默认情况下，有N个分组
        this.count = N;
        //初始化eleAndGroup数组
        this.eleAndGroup = new int[N];

        //初始化eleAndGroup中的元素及其所在的组的标识符,让eleAndGroup数组的索引作为并查集的每个结点的元素，并且让每个索引处的值(该元素所在的组的标识符)就是该索引

        for (int i = 0; i < eleAndGroup.length; i++) {
            eleAndGroup[i] = i;
        }

        this.sz = new int[N];
        //默认情况下，sz中每个索引处的值都是1
        for (int i = 0; i < sz.length; i++) {
            sz[i] = 1;
        }

    }

    //获取当前并查集中的数据有多少个分组
    public int count() {
        return count;
    }

    //判断并查集中元素p和元素q是否在同一分组中
    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }

    //元素p所在分组的标识符
    public int find(int p) {
        while (true) {

            if (p == eleAndGroup[p]) {
                return p;
            }

            p = eleAndGroup[p];
        }

    }

    //把p元素所在分组和q元素所在分组合并
    public void union(int p, int q) {
        //找到p元素和q元素所在组对应的树的根结点

        int pRoot = find(p);
        int qRoot = find(q);

        //如果p和q已经在同一分组，则不需要合并了
        if (pRoot == qRoot) {
            return;
        }

        //判断proot对应的树大还是qroot对应的树大，最终需要把较小的树合并到较大的树中

        if (sz[pRoot] < sz[qRoot]) {
            eleAndGroup[pRoot] = qRoot;
            sz[qRoot] += sz[pRoot];
        } else {
            eleAndGroup[qRoot] = pRoot;
            sz[pRoot] += sz[qRoot];
        }

        //组的数量-1

        this.count--;

    }

}
```

## 案例-畅通工程

某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目  标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？

在我们的测试数据文件夹中有一个trﬃc_project.txt文件，它就是城镇道路统计表，下面是对数据的解释：

![](.\images\案例-畅通工程.png)

总共有20个城市，目前已经修改好了7条道路，问还需要修建多少条道路，才能让这20个城市之间全部相通？  

**解题思路：**

1. 创建一个并查集UF_Tree_Weighted(20);

2. 分别调用union(0,1),union(6,9),union(3,8),union(5,11),union(2,12),union(6,10),union(4,8)，表示已经修建好的道路把对应的城市连接起来；

3. 如果城市全部连接起来，那么并查集中剩余的分组数目为1，所有的城市都在一个树中，所以，只需要获取当前并查集中剩余的数目，减去1，就是还需要修建的道路数目；

**代码：**

```java
public class Traffic_Project_Test {

    public static void main(String[] args) throws Exception {
        //构建一个缓冲读取流BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(Traffic_Project_Test.class.getClassLoader().getResourceAsStream("traffic_project.txt")));

        //读取第一行数据20
        int totalNumber = Integer.parseInt(br.readLine());

        //构建一个并查集对象
        UF_Tree_Weighted uf = new UF_Tree_Weighted(totalNumber);
        //读取第二行数据7
        int roadNumber = Integer.parseInt(br.readLine());
        //循环读取7条道路
        for (int i = 1; i <= roadNumber; i++) {
            String line = br.readLine();//0 1
            String[] str = line.split(" ");
            int p = Integer.parseInt(str[0]);
            int q = Integer.parseInt(str[1]);

            //调用并查集对象的union方法让两个城市相通
            uf.union(p, q);
        }

        //获取当前并查集中分组的数量-1就可以得到还需要修建的道路的数目
        int roads = uf.count() - 1;

        System.out.println("还需要修建" + roads + "条道路，才能实现畅通工程");
    }

}
```

# 图的入门

## 图的实际应用

在现实生活中，有许多应用场景会包含很多点以及点点之间的连接，而这些应用场景我们都可以用即将要学习的图这种数据结构去解决。

**地图：**

我们生活中经常使用的地图，基本上是由城市以及连接城市的道路组成，如果我们把城市看做是一个一个的点，把道路看做是一条一条的连接，那么地图就是我们将要学习的图这种数据结构。

<img src=".\images\地图.png" style="zoom:80%;" />

**电路图：**

下面是一个我们生活中经常见到的集成电路板，它其实就是由一个一个触点组成，并把触点与触点之间通过线进行连接，这也是我们即将要学习的图这种数据结构的应用场景

<img src=".\images\电路图.png" style="zoom:80%;" />

## 图的定义及分类

**定义：**图是由一组顶点和一组能够将两个顶点相连的边组成的

![](.\images\图的定义及分类.png)

**特殊的图：**

1. 自环：即一条连接一个顶点和其自身的边；

2. 平行边：连接同一对顶点的两条边；

![](.\images\特殊的图.png)

**图的分类：**

按照连接两个顶点的边的不同，可以把图分为以下两种： 

无向图：边仅仅连接两个顶点，没有其他含义；

有向图：边不仅连接两个顶点，并且具有方向；

## 无向图

### 图的相关术语

**相邻顶点：**

当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，并且称这条边依附于这两个顶点。 

**度：**

某个顶点的度就是依附于该顶点的边的个数

**子图：**

是一幅图的所有边的子集(包含这些边依附的顶点)组成的图； 

**路径：**

是由边顺序连接的一系列的顶点组成

**环：**

是一条至少含有一条边且终点和起点相同的路径

![](.\images\图的相关术语.png)

**连通图：**

如果图中任意一个顶点都存在一条路径到达另外一个顶点，那么这幅图就称之为连通图

**连通子图：**

一个非连通图由若干连通的部分组成，每一个连通的部分都可以称为该图的连通子图

![](.\images\连通子图.png)

### 图的存储结构

要表示一幅图，只需要表示清楚以下两部分内容即可：

1. 图中所有的顶点；

2. 所有连接顶点的边；

常见的图的存储结构有两种：邻接矩阵和邻接表

#### 邻接矩阵

1. 使用一个V*V的二维数组int\[V][V] adj,把索引的值看做是顶点；

2. 如果顶点v和顶点w相连，我们只需要将adj\[v][w]和adj\[w][v]的值设置为1,否则设置为0即可。

![](.\images\邻接矩阵.png)

很明显，邻接矩阵这种存储方式的空间复杂度是V^2的，如果我们处理的问题规模比较大的话，内存空间极有可能不够用。

#### 邻接表

1. 使用一个大小为V的数组 Queue[V] adj，把索引看做是顶点；

2. 每个索引处adj[v]存储了一个队列，该队列中存储的是所有与该顶点相邻的其他顶点

![](.\images\邻接表.png)

很明显，邻接表的空间并不是是线性级别的，所以后面我们一直采用邻接表这种存储形式来表示图。

### 图的实现

**图的 API 设计**

| **类名** | **Graph**                                                    |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Graph(int V)：创建一个包含V个顶点但不包含边的图              |
| 成员方法 | 1.public int V():获取图中顶点的数量<br />2.public int E():获取图中边的数量<br />3.public void addEdge(int v,int w):向图中添加一条边 v-w <br />4.public Queue adj(int v)：获取和顶点v相邻的所有顶点 |
| 成员变量 | 1.private ﬁnal int V: 记录顶点数量<br />2.private int E: 记录边数量<br />3.private Queue[] adj: 邻接表 |

**代码实现**

```java
public class Graph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;

    public Graph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];

        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }
    }


    //获取顶点数目
    public int V() {
        return V;
    }

    //获取边的数目
    public int E() {
        return E;
    }

    //向图中添加一条边 v-w
    public void addEdge(int v, int w) {
        //在无向图中，边是没有方向的，所以该边既可以说是从v到w的边，又可以说是从w到v的边，因此，需要让w出现在v的邻接表中，并且还要让v出现在w的邻接表中

        adj[v].enqueue(w);
        adj[w].enqueue(v);
        //边的数量+1
        E++;

    }

    //获取和顶点v相邻的所有顶点
    public Queue<Integer> adj(int v) {
        return adj[v];
    }

}
```

## 图的搜索

在很多情况下，我们需要遍历图，得到图的一些性质，例如，找出图中与指定的顶点相连的所有顶点，或者判定某  个顶点与指定顶点是否相通，是非常常见的需求。

有关图的搜索，最经典的算法有深度优先搜索和广度优先搜索，接下来我们分别讲解这两种搜索算法。

### 深度优先搜索

所谓的深度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找子结点，然后找兄弟结点。

![](.\images\深度优先搜索.png)

很明显，在由于边是没有方向的，所以，如果4和5顶点相连，那么4会出现在5的相邻链表中，5也会出现在4的相邻链表中，那么为了不对顶点进行**重复搜索**，应该要有相应的标记来表示当前顶点有没有搜索过，可以使用一个布尔类型的数组  boolean[V] marked,索引代表顶点，值代表当前顶点是否已经搜索，如果已经搜索，标记为true， 如果没有搜索，标记为false；

**API 设计：**

| **类名** | **DepthFirstSearch**                                         |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DepthFirstSearch(Graph G,int s)：构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相通顶点 |
| 成员方法 | 1.private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相通顶点<br />2.public boolean marked(int w):判断w顶点与s顶点是否相通<br />3.public int count():获取与顶点s相通的所有顶点的总数 |
| 成员变量 | 1. private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br />2. private int count：记录有多少个顶点与s顶点相通 |

**代码：**

```java
public class DepthFirstSearch {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录有多少个顶点与s顶点相通
    private int count;

    //构造深度优先搜索对象，使用深度优先搜索找出G图中s顶点的所有相邻顶点
    public DepthFirstSearch(Graph G, int s) {
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化跟顶点s相通的顶点的数量
        this.count = 0;

        dfs(G, s);
    }

    //使用深度优先搜索找出G图中v顶点的所有相通顶点
    private void dfs(Graph G, int v) {
        //把v顶点标识为已搜索
        marked[v] = true;

        for (Integer w : G.adj(v)) {
            //判断当前w顶点有没有被搜索过，如果没有被搜索过，则递归调用dfs方法进行深度搜索
            if (!marked[w]) {
                dfs(G, w);
            }

        }

        //相通顶点数量+1
        count++;
    }

    //判断w顶点与s顶点是否相通
    public boolean marked(int w) {
        return marked[w];
    }

    //获取与顶点s相通的所有顶点的总数
    public int count() {
        return count;
    }

}

public class DepthFirstSearchTest {

    public static void main(String[] args) {
        //准备Graph对象
        Graph G = new Graph(13);
        G.addEdge(0, 5);
        G.addEdge(0, 1);
        G.addEdge(0, 2);
        G.addEdge(0, 6);
        G.addEdge(5, 3);
        G.addEdge(5, 4);
        G.addEdge(3, 4);
        G.addEdge(4, 6);

        G.addEdge(7, 8);

        G.addEdge(9, 11);
        G.addEdge(9, 10);
        G.addEdge(9, 12);
        G.addEdge(11, 12);

        //准备深度优先搜索对象
        DepthFirstSearch search = new DepthFirstSearch(G, 0);

        //测试与某个顶点相通的顶点数量
        int count = search.count();
        System.out.println("与起点0相通的顶点的数量为:" + count);


        //测试某个顶点与起点是否相同
        boolean marked1 = search.marked(5);
        System.out.println("顶点5和顶点0是否相通：" + marked1);


        boolean marked2 = search.marked(7);
        System.out.println("顶点7和顶点0是否相通：" + marked2);

    }
}
```

### 广度优先搜索

所谓的广度优先搜索，指的是在搜索时，如果遇到一个结点既有子结点，又有兄弟结点，那么先找兄弟结点，然后找子结点。

![](.\images\广度优先搜索.png)

**API 设计：**

| **类名** | **BreadthFirstSearch**                                       |
| -------- | ------------------------------------------------------------ |
| 构造方法 | BreadthFirstSearch(Graph G,int s)：构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点 |
| 成员方法 | 1.private void bfs(Graph G, int v)：使用广度优先搜索找出G图中v顶点的所有相邻顶点<br />2.public boolean marked(int w):判断w顶点与s顶点是否相通<br />3.public int count():获取与顶点s相通的所有顶点的总数 |
| 成员变量 | 1. private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br />2. private int count：记录有多少个顶点与s顶点相通<br />3.private Queue waitSearch: 用来存储待搜索邻接表的点 |

**代码：**

```java
public class BreadthFirstSearch {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录有多少个顶点与s顶点相通
    private int count;
    //用来存储待搜索邻接表的点
    private Queue<Integer> waitSearch;

    //构造广度优先搜索对象，使用广度优先搜索找出G图中s顶点的所有相邻顶点
    public BreadthFirstSearch(Graph G, int s) {
        this.marked = new boolean[G.V()];
        this.count = 0;
        this.waitSearch = new Queue<Integer>();

        bfs(G, s);
    }

    //使用广度优先搜索找出G图中v顶点的所有相邻顶点
    private void bfs(Graph G, int v) {
        //把当前顶点v标识为已搜索
        marked[v] = true;
        //让顶点v进入队列，待搜索
        waitSearch.enqueue(v);
        //通过循环，如果队列不为空，则从队列中弹出一个待搜索的顶点进行搜索
        while (!waitSearch.isEmpty()) {
            //弹出一个待搜索的顶点
            Integer wait = waitSearch.dequeue();

            //遍历wait顶点的邻接表
            for (Integer w : G.adj(wait)) {

                if (!marked[w]) {
                    bfs(G, w);
                }
            }
        }

        //让相通的顶点+1；
        count++;

    }

    //判断w顶点与s顶点是否相通
    public boolean marked(int w) {
        return marked[w];
    }

    //获取与顶点s相通的所有顶点的总数
    public int count() {
        return count;
    }
}

public class BreadthFirstSearchTest {

    public static void main(String[] args) {

        //准备Graph对象
        Graph G = new Graph(13);
        G.addEdge(0, 5);
        G.addEdge(0, 1);
        G.addEdge(0, 2);
        G.addEdge(0, 6);
        G.addEdge(5, 3);
        G.addEdge(5, 4);
        G.addEdge(3, 4);
        G.addEdge(4, 6);

        G.addEdge(7, 8);

        G.addEdge(9, 11);
        G.addEdge(9, 10);
        G.addEdge(9, 12);
        G.addEdge(11, 12);


        //准备广度优先搜索对象
        BreadthFirstSearch search = new BreadthFirstSearch(G, 0);

        //测试与某个顶点相通的顶点数量
        int count = search.count();
        System.out.println("与起点0相通的顶点的数量为:" + count);


        //测试某个顶点与起点是否相同
        boolean marked1 = search.marked(5);
        System.out.println("顶点5和顶点0是否相通：" + marked1);


        boolean marked2 = search.marked(7);
        System.out.println("顶点7和顶点0是否相通：" + marked2);

    }
}
```

## 案例-畅通工程续1

某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目  标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。目前的道路状况，9号城市和10号城市是否相通？9号城市和8号城市是否相通？

在我们的测试数据文件夹中有一个trﬃc_project.txt文件，它就是诚征道路统计表，下面是对数据的解释：

![](.\images\案例-畅通工程.png)

总共有20个城市，目前已经修改好了7条道路，问9号城市和10号城市是否相通？9号城市和8号城市是否相通？ 

 **解题思路：**

1. 创建一个图Graph对象，表示城市；

2. 分别调用addEdge(0,1),addEdge(6,9),addEdge(3,8),addEdge(5,11),addEdge(2,12),addEdge(6,10),addEdge(4,8)， 表 示 已 经修建好的道路把对应的城市连接起来；

3. 通过Graph对象和顶点9，构建DepthFirstSearch对象或BreadthFirstSearch对象；

4. 调用搜索对象的marked(10)方法和marked(8)方法，即可得到9和城市与10号城市以及9号城市与8号城市是否相  通。

**代码：**

```java
public class Traffic_Project_Test2 {

    public static void main(String[] args) throws Exception {

        //构建一个缓冲读取流BufferedReader

        BufferedReader br = new BufferedReader(new InputStreamReader(Traffic_Project_Test2.class.getClassLoader().getResourceAsStream("traffic_project.txt")));

        //读取第一行数据20
        int totalNumber = Integer.parseInt(br.readLine());

        //构建一个Graph对象
        Graph G = new Graph(totalNumber);

        //读取第二行数据7
        int roadNumber = Integer.parseInt(br.readLine());
        //循环读取有限次(7)，读取已经修建好的道路
        for (int i = 1; i <= roadNumber; i++) {
            String road = br.readLine();//"0 1"
            String[] str = road.split(" ");
            int v = Integer.parseInt(str[0]);
            int w = Integer.parseInt(str[1]);
            //调用图的addEdge方法，把边添加到图中，表示已经修建好的道路

            G.addEdge(v, w);

        }

        //构建一个深度优先搜索对象，起点设置为顶点9
        DepthFirstSearch search = new DepthFirstSearch(G, 9);

        //调用marked方法，判断8顶点和10顶点是否与起点9相通
        System.out.println("顶点8和顶点9是否相通：" + search.marked(8));
        System.out.println("顶点10和顶点9是否相通：" + search.marked(10));

    }
}
```

## 路径查找

在实际生活中，地图是我们经常使用的一种工具，通常我们会用它进行导航，输入一个出发城市，输入一个目的地  城市，就可以把路线规划好，而在规划好的这个路线上，会路过很多中间的城市。这类问题翻译成专业问题就是：  从s顶点到v顶点是否存在一条路径？如果存在，请找出这条路径。

![](.\images\路径查找.png)

例如在上图上查找顶点0到顶点4的路径用红色标识出来,那么我们可以把该路径表示为 0-2-3-4。

**路径查找 API 设计**

| **类名** | **DepthFirstPaths**                                          |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DepthFirstPaths(Graph  G,int  s)：构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径 |
| 成员方法 | 1.private void dfs(Graph G, int v)：使用深度优先搜索找出G图中v顶点的所有相邻顶点<br />2.public boolean hasPathTo(int v):判断v顶点与s顶点是否存在路径<br />3.public Stack pathTo(int v):找出从起点s到顶点v的路径(就是该路径经过的顶点) |
| 成员变量 | 1. private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br />2. private int s:起点<br />3. private int[] edgeTo:索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点 |

**路径查找实现**

我们实现路径查找，最基本的操作还是得遍历并搜索图，所以，我们的实现暂且基于深度优先搜索来完成。其搜索  的过程是比较简单的。我们添加了edgeTo[]整型数组，这个整型数组会记录从每个顶点回到起点s的路径。

如果我们把顶点设定为0，那么它的搜索可以表示为下图：

![](.\images\路径查找实现.png)

![](.\images\路径查找实现2.png)

根据最终edgeTo的结果，我们很容易能够找到从起点0到任意顶点的路径；

**代码：**

```java
public class DepthFirstPaths {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //起点
    private int s;
    //索引代表顶点，值代表从起点s到当前顶点路径上的最后一个顶点
    private int[] edgeTo;

    //构造深度优先搜索对象，使用深度优先搜索找出G图中起点为s的所有路径
    public DepthFirstPaths(Graph G, int s) {
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化起点
        this.s = s;
        //初始化edgeTo数组
        this.edgeTo = new int[G.V()];

        dfs(G, s);
    }

    //使用深度优先搜索找出G图中v顶点的所有相邻顶点
    private void dfs(Graph G, int v) {
        //把v表示为已搜索
        marked[v] = true;

        //遍历顶点v的邻接表，拿到每一个相邻的顶点，继续递归搜索
        for (Integer w : G.adj(v)) {
            //如果顶点w没有被搜索，则继续递归搜索

            if (!marked[w]) {
                edgeTo[w] = v;//到达顶点w的路径上的最后一个顶点是v
                dfs(G, w);
            }

        }
    }

    //判断w顶点与s顶点是否存在路径
    public boolean hasPathTo(int v) {
        return marked[v];
    }

    //找出从起点s到顶点v的路径(就是该路径经过的顶点)
    public Stack<Integer> pathTo(int v) {
        if (!hasPathTo(v)) {
            return null;
        }

        //创建栈对象，保存路径中的所有顶点
        Stack<Integer> path = new Stack<>();

        //通过循环，从顶点v开始，一直往前找，到找到起点为止
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);
        }

        //把起点s放到栈中
        path.push(s);

        return path;
    }

}

public class DepthFirstPathsTest {

    public static void main(String[] args) throws Exception {
        //构建缓冲读取流BufferedReader
        BufferedReader br = new BufferedReader(new InputStreamReader(DepthFirstPathsTest.class.getClassLoader().getResourceAsStream("road_find.txt")));


        //读取第一行数据6
        int total = Integer.parseInt(br.readLine());

        //根据第一行数据构建一副图Graph
        Graph G = new Graph(total);
        //读取第二行数据8
        int edgeNumbers = Integer.parseInt(br.readLine());
        //继续通过循环读取每一条边关联的两个顶点，调用addEdge方法，添加边
        for (int i = 1; i <= edgeNumbers; i++) {
            String edge = br.readLine();//0 1
            String[] str = edge.split(" ");
            int v = Integer.parseInt(str[0]);
            int w = Integer.parseInt(str[1]);
            G.addEdge(v, w);
        }

        //构建路径查找对象，并设置起点为0
        DepthFirstPaths paths = new DepthFirstPaths(G, 0);
        //调用 pathTo(4)，找到从起点0到终点4的路径，返回Stack
        Stack<Integer> path = paths.pathTo(4);
        StringBuilder sb = new StringBuilder();
        //遍历栈对象
        for (Integer v : path) {
            sb.append(v + "-");
        }

        sb.deleteCharAt(sb.length() - 1);

        System.out.println(sb);
    }
}
```

# 有向图

在实际生活中，很多应用相关的图都是有方向性的，最直观的就是网络，可以从A页面通过链接跳转到B页面，那么a和b连接的方向是a->b,但不能说是b->a,此时我们就需要使用有向图来解决这一类问题，它和我们之前学习的无向图，最大的区别就在于连接是具有方向的，在代码的处理上也会有很大的不同。

![](.\images\有向图.png)

## 有向图的定义及相关术语

**定义：**

有向图是一副具有方向性的图，是由一组顶点和一组有方向的边组成的，每条方向的边都连着一对有序的顶点。  

**出度：**

由某个顶点指出的边的个数称为该顶点的出度。

**入度：**

指向某个顶点的边的个数称为该顶点的入度。

**有向路径：**

由一系列顶点组成，对于其中的每个顶点都存在一条有向边，从它指向序列中的下一个顶点。 

**有向环：**

一条至少含有一条边，且起点和终点相同的有向路径。

![](.\images\有向图的定义及相关术语.png)

**一副有向图中两个顶点 v 和 w 可能存在以下四种关系：**

1. 没有边相连；

2. 存在从v到w的边v—>w;

3. 存在从w到v的边w—>v;

4. 既存在w到v的边，也存在v到w的边，即双向连接；

理解有向图是一件比较简单的，但如果要通过眼睛看出复杂有向图中的路径就不是那么容易了。

![](.\images\复杂有向图.png)

## 有向图 API 设计

| **类名** | **Digraph**                                                  |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Digraph(int V)：创建一个包含V个顶点但不包含边的有向图        |
| 成员方法 | 1.public int V():获取图中顶点的数量<br />2.public int E():获取图中边的数量<br />3.public void addEdge(int v,int w):向有向图中添加一条边 v->w <br />4.public Queue adj(int v)：获取由v指出的边所连接的所有顶点<br />5.private Digraph reverse():该图的反向图 |
| 成员变量 | 1.private ﬁnal int V: 记录顶点数量<br />2.private int E: 记录边数量<br />3.private Queue[] adj: 邻接表 |

在api中设计了一个反向图，其因为有向图的实现中，用adj方法获取出来的是由当前顶点v指向的其他顶点，如果能得到其反向图，就可以很容易**得到指向w的其他顶点**。

## 有向图实现

```java
public class Digraph {
    //顶点数目
    private final int V;
    //边的数目
    private int E;
    //邻接表
    private Queue<Integer>[] adj;

    public Digraph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];
        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Integer>();
        }

    }


    //获取顶点数目
    public int V() {
        return V;
    }

    //获取边的数目
    public int E() {
        return E;
    }

    //向有向图中添加一条边 v->w
    public void addEdge(int v, int w) {
        //只需要让顶点w出现在顶点v的邻接表中，因为边是有方向的，最终，顶点v的邻接表中存储的相邻顶点的含义是：  v->其他顶点
        adj[v].enqueue(w);
        E++;
    }

    //获取由v指出的边所连接的所有顶点
    public Queue<Integer> adj(int v) {
        return adj[v];
    }

    //创建一个该图的反向图
    private Digraph reverse() {
        //创建有向图对象
        Digraph r = new Digraph(V);

        for (int v = 0; v < V; v++) {
            //获取由该顶点v指出的所有边
            for (Integer w : adj[v]) {//原图中表示的是由顶点v->w的边
                r.addEdge(w, v);//w->v
            }

        }
        return r;
    }
}
```

# 拓扑排序

在现实生活中，我们经常会同一时间接到很多任务去完成，但是这些任务的完成是有先后次序的。以我们学习java  学科为例，我们需要学习很多知识，但是这些知识在学习的过程中是需要按照先后次序来完成的。从java基础，到jsp/servlet，到ssm，到springboot等是个循序渐进且有依赖的过程。在学习jsp前要首先掌握java基础和html基础，学习ssm框架前要掌握jsp/servlet之类才行。

![](.\images\学习Java的顺序.png)

为了简化问题，我们使用整数为顶点编号的标准模型来表示这个案例：

![](.\images\学习Java的顺序图模型.png)

此时如果某个同学要学习这些课程，就需要指定出一个学习的方案，我们只需要对图中的顶点进行排序，让它转换为一个线性序列，就可以解决问题，这时就需要用到一种叫**拓扑排序**的算法。

**拓扑排序：**

给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素，此时就可以明确的表示出每个顶点的优先级。下列是一副拓扑排序后的示意图：

![](.\images\学习Java的顺序拓扑排序.png)

## 检测有向图中的环

如果学习x课程前必须先学习y课程，学习y课程前必须先学习z课程，学习z课程前必须先学习x课程，那么一定是有问题了，我们就没有办法学习了，因为这三个条件没有办法同时满足。其实这三门课程x、y、z的条件组成了一个环：

![](.\images\检测有向图中的环.png)

因此，如果我们要使用拓扑排序解决优先级问题，首先得保证图中没有环的存在。

### 检测有向环的 API 设计

| **类名** | **DirectedCycle**                                            |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DirectedCycle(Digraph G)：创建一个检测环对象，检测图G中是否有环 |
| 成员方法 | 1.private void dfs(Digraph G,int v)：基于深度优先搜索，检测图G中是否有环<br />2.public boolean hasCycle():判断图中是否有环 |
| 成员变量 | 1. private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br />2. private boolean hasCycle: 记录图中是否有环<br />3. private boolean[] onStack:索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上 |

### 检测有向环实现

在API中添加了onStack[] 布尔数组，索引为图的顶点，当我们深度搜索时：

1. 如果当前顶点正在搜索，则把对应的onStack数组中的值改为true，标识进栈；

2. 如果当前顶点搜索完毕，则把对应的onStack数组中的值改为false，标识出栈；

3. 如果即将要搜索某个顶点，但该顶点已经在栈中，则图中有环；

![](.\images\检测有向环实现1.png)

![](.\images\检测有向环实现2.png)

**代码：**

```java
public class DirectedCycle {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //记录图中是否有环
    private boolean hasCycle;
    //索引代表顶点，使用栈的思想，记录当前顶点有没有已经处于正在搜索的有向路径上
    private boolean[] onStack;

    //创建一个检测环对象，检测图G中是否有环
    public DirectedCycle(Digraph G) {
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化hasCycle
        this.hasCycle = false;
        //初始化onStack数组
        this.onStack = new boolean[G.V()];

        //找到图中每一个顶点，让每一个顶点作为入口，调用一次dfs进行搜索
        for (int v = 0; v < G.V(); v++) {
            //判断如果当前顶点还没有搜索过，则调用dfs进行搜索
            if (!marked[v]) {
                dfs(G, v);
            }
        }
    }

    //基于深度优先搜索，检测图G中是否有环
    private void dfs(Digraph G, int v) {
        //把顶点v表示为已搜索
        marked[v] = true;

        //把当前顶点进栈
        onStack[v] = true;

        //进行深度搜索
        for (Integer w : G.adj(v)) {
            //判断如果当前顶点w没有被搜索过，则继续递归调用dfs方法完成深度优先搜索
            if (!marked[w]) {
                dfs(G, w);
            }

            //判断当前顶点w是否已经在栈中，如果已经在栈中，证明当前顶点之前处于正在搜索的状态，那么现在又要搜索一次，证明检测到环了
            if (onStack[w]) {
                hasCycle = true;
                return;
            }
        }
        //把当前顶点出栈
        onStack[v] = false;
    }

    //判断当前有向图G中是否有环
    public boolean hasCycle() {
        return hasCycle;
    }

}

//测试代码
public class DirectedCycleTest {
    
    public static void main(String[] args) throws Exception {
        //创建输入流
       BufferedReader reader = new BufferedReader(new InputStreamReader(DirectedCycleTest.class.getClassLoader().getResourceAsStream("cycle_test.t xt")));
        //读取顶点个数，初始化Graph图
        int number = Integer.parseInt(reader.readLine());
        Digraph G = new Digraph(number);
        //读取边的个数
        int roadNumber = Integer.parseInt(reader.readLine());
        //读取边，并调用addEdge方法
        for (int i = 0; i < roadNumber; i++) {
            String line = reader.readLine();
            int p = Integer.parseInt(line.split(" ")[0]);
            int q = Integer.parseInt(line.split(" ")[1]);
            G.addEdge(p, q); 
        }

        //创建测试检测环对象
        DirectedCycle cycle = new DirectedCycle(G);
        //输出图中是否有环
        System.out.println(cycle.hasCycle()); 
    }

}
```

## 基于深度优先的顶点排序

如果要把图中的顶点生成线性序列其实是一件非常简单的事，之前我们学习并使用了多次深度优先搜索，我们会发现其实深度优先搜索有一个特点，那就是在一个连通子图上，**每个顶点只会被搜索一次**，如果我们能在深度优先搜索的基础上，添加一行代码，只需要将搜索的顶点放入到线性序列的数据结构中，我们就能完成这件事。

### 顶点排序 API 设计

| **类名** | **DepthFirstOrder**                                          |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DepthFirstOrder(Digraph G)：创建一个顶点排序对象，生成顶点线性序列； |
| 成员方法 | 1.private void dfs(Digraph G,int v)：基于深度优先搜索，生成顶点线性序列<br />2.public Stack reversePost():获取顶点线性序列 |
| 成员变量 | 1. private boolean[] marked: 索引代表顶点，值表示当前顶点是否已经被搜索<br />2. private Stack reversePost: 使用栈，存储顶点序列 |

### 顶点排序实现

在API的设计中，我们添加了一个栈reversePost用来存储顶点，当我们深度搜索图时，每搜索完毕一个顶点，把该顶点放入到reversePost中，这样就可以实现顶点排序。

![](.\images\顶点排序实现1.png)

![](.\images\顶点排序实现2.png)

![](.\images\顶点排序实现3.png)

**代码：**

```java
public class DepthFirstOrder {
    //索引代表顶点，值表示当前顶点是否已经被搜索
    private boolean[] marked;
    //使用栈，存储顶点序列
    private Stack<Integer> reversePost;

    //创建一个检测环对象，检测图G中是否有环
    public DepthFirstOrder(Digraph G) {
        //初始化marked数组
        this.marked = new boolean[G.V()];
        //初始化reversePost栈
        this.reversePost = new Stack<Integer>();

        //遍历图中的每一个顶点，让每个顶点作为入口，完成一次深度优先搜索
        for (int v = 0; v < G.V(); v++) {
            if (!marked[v]) {
                dfs(G, v);
            }
        }
    }

    //基于深度优先搜索，把顶点排序
    private void dfs(Digraph G, int v) {
        //标记当前v已经被搜索
        marked[v] = true;
        //通过循环深度搜索顶点v
        for (Integer w : G.adj(v)) {
            //如果当前顶点w没有搜索，则递归调用dfs进行搜索
            if (!marked[w]) {
                dfs(G, w);
            }
        }
        //让顶点v进栈
        reversePost.push(v);
    }

    //获取顶点线性序列
    public Stack<Integer> reversePost() {
        return reversePost;
    }
}
```

前面已经实现了环的检测以及顶点排序，那么拓扑排序就很简单了，基于一幅图，先检测有没有环，如果没有环，  则调用顶点排序即可。

**API 设计：**

| **类名** | **TopoLogical**                                              |
| -------- | ------------------------------------------------------------ |
| 构造方法 | TopoLogical(Digraph G)：构造拓扑排序对象                     |
| 成员方法 | 1.public boolean isCycle()：判断图G是否有环<br />2.public Stack order():获取拓扑排序的所有顶点 |
| 成员变量 | 1.private Stack order: 顶点的拓扑排序                        |

**代码：**

```java
public class TopoLogical {
    //顶点的拓扑排序
    private Stack<Integer> order;

    //构造拓扑排序对象
    public TopoLogical(Digraph G) {
        //创建一个检测有向环的对象
        DirectedCycle cycle = new DirectedCycle(G);
        //判断G图中有没有环，如果没有环，则进行顶点排序：创建一个顶点排序对象
        if (!cycle.hasCycle()) {
            DepthFirstOrder depthFirstOrder = new DepthFirstOrder(G);
            order = depthFirstOrder.reversePost();
        }
    }

    //判断图G是否有环
    private boolean isCycle() {
        return order == null;
    }

    //获取拓扑排序的所有顶点
    public Stack<Integer> order() {
        return order;
    }
}

public class TopoLogicalTest {

    public static void main(String[] args) {
        //准备有向图
        Digraph digraph = new Digraph(6);
        digraph.addEdge(0, 2);
        digraph.addEdge(0, 3);
        digraph.addEdge(2, 4);
        digraph.addEdge(3, 4);
        digraph.addEdge(4, 5);
        digraph.addEdge(1, 3);

        //通过TopoLogical对象堆有向图中的顶点进行排序
        TopoLogical topoLogical = new TopoLogical(digraph);

        //获取顶点的线性序列进行打印

        Stack<Integer> order = topoLogical.order();
        StringBuilder sb = new StringBuilder();
        for (Integer w : order) {
            sb.append(w + "->");
        }
        String str = sb.toString();
        int index = str.lastIndexOf("->");
        str = str.substring(0, index);
        System.out.println(str);
    }
}
```

# 加权无向图

加权无向图是一种为每条边关联一个权重值或是成本的图模型。这种图能够自然地表示许多应用。在一副航空图中，边表示航线，权值则可以表示距离或是费用。在一副电路图中，边表示导线，权值则可能表示导线的长度即成本，或是信号通过这条先所需的时间。此时我们很容易就能想到，最小成本的问题，例如，从西安飞纽约，怎样飞才能使时间成本最低或者是金钱成本最低？

在下图中，从顶点0到顶点4有三条路径，分别为0-2-3-4,0-2-4,0-5-3-4,那我们如果要通过哪条路径到达4顶点最好呢？此时就要考虑，哪条路径的成本最低。

![](.\images\加权无向图.png)

## 加权无向图边的表示

加权无向图中的边我们就不能简单的使用v-w两个顶点表示了，而必须要给边关联一个权重值，因此我们可以使用对象来描述一条边。

**API 设计：**

| **类名** | **Edge implements Comparable**                               |
| -------- | ------------------------------------------------------------ |
| 构造方法 | Edge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 |
| 成员方法 | 1.public double weight():获取边的权重值<br />2.public int either():获取边上的一个点<br />3. public int other(int vertex)):获取边上除了顶点vertex外的另外一个顶点<br />4. public int compareTo(Edge that)：比较当前边和参数that边的权重，如果当前边权重大，返回1，如果一样大，返回0，如果当前权重小，返回-1 |
| 成员变量 | 1.private ﬁnal int v：顶点一<br />2.private ﬁnal int w：顶点二<br />3.private ﬁnal double weight：当前边的权重 |

**代码：**

```java
public class Edge implements Comparable<Edge> {
    private final int v;//顶点一
    private final int w;//顶点二
    private final double weight;//当前边的权重

    //通过顶点v和w，以及权重weight值构造一个边对象
    public Edge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight() {
        return weight;
    }

    //获取边上的一个点
    public int either() {
        return v;
    }

    //获取边上除了顶点vertex外的另外一个顶点
    public int other(int vertex) {
        if (vertex == v) {
            return w;
        } else {
            return v;
        }
    }

    @Override
    public int compareTo(Edge that) {
        //使用一个遍历记录比较的结果
        int cmp;

        if (this.weight() > that.weight()) {
            //如果当前边的权重值大，则让cmp=1；
            cmp = 1;
        } else if (this.weight() < that.weight()) {
            //如果当前边的权重值小，则让cmp=-1；
            cmp = -1;
        } else {
            //如果当前边的权重值和that边的权重值一样大，则让cmp=0
            cmp = 0;
        }

        return cmp;
    }
}
```

## 加权无向图的实现

之前我们已经完成了无向图，在无向图的基础上，我们只需要把边的表示切换成Edge对象即可。

**API 设计：**

| **类名** | **EdgeWeightedGraph**                                        |
| -------- | ------------------------------------------------------------ |
| 构造方法 | EdgeWeightedGraph(int V)：创建一个含有V个顶点的空加权无向图  |
| 成员方法 | 1.public int V():获取图中顶点的数量<br />2.public int E():获取图中边的数量<br />3.public void addEdge(Edge e):向加权无向图中添加一条边e <br />4.public Queue adj(int v)：获取和顶点v关联的所有边<br />5.public Queue edges()：获取加权无向图的所有边 |
| 成员变量 | 1.private ﬁnal int V: 记录顶点数量<br />2.private int E: 记录边数量<br />3.private Queue[] adj: 邻接表 |

**代码：**

```java
public class EdgeWeightedGraph {
    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表
    private Queue<Edge>[] adj;

    //创建一个含有V个顶点的空加权无向图
    public EdgeWeightedGraph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];
        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<Edge>();
        }

    }

    //获取图中顶点的数量
    public int V() {
        return V;
    }

    //获取图中边的数量
    public int E() {
        return E;
    }


    //向加权无向图中添加一条边e
    public void addEdge(Edge e) {
        //需要让边e同时出现在e这个边的两个顶点的邻接表中
        int v = e.either();
        int w = e.other(v);

        adj[v].enqueue(e);
        adj[w].enqueue(e);

        //边的数量+1
        E++;
    }

    //获取和顶点v关联的所有边
    public Queue<Edge> adj(int v) {
        return adj[v];
    }

    //获取加权无向图的所有边
    public Queue<Edge> edges() {

        //创建一个队列对象，存储所有的边
        Queue<Edge> allEdges = new Queue<>();

        //遍历图中的每一个顶点，找到该顶点的邻接表，邻接表中存储了该顶点关联的每一条边

        //因为这是无向图，所以同一条边同时出现在了它关联的两个顶点的邻接表中，需要让一条边只记录一次；
        for (int v = 0; v < V; v++) {
            //遍历v顶点的邻接表，找到每一条和v关联的边
            for (Edge e : adj(v)) {
				// 3 < 5，这次会添加到队列中，下次找到 5 < 3，就不会添加到队列中了
                // 不存在相等的情况，因为数组的索引值代表顶点，索引不可能重复
                if (e.other(v) < v) {
                    allEdges.enqueue(e);
                }

            }
        }
        return allEdges;
    }
}
```

# 最小生成树

之前学习的加权图，我们发现它的边关联了一个权重，那么我们就可以根据这个权重解决最小成本问题，但如何才能找到最小成本对应的顶点和边呢？最小生成树相关算法可以解决。

![](.\images\最小生成树.png)

## 最小生成树定义及相关约定

**定义：**

图的生成树是它的一棵含有其所有顶点的**无环**连通子图，一副加权无向图的最小生成树它的一棵**权值最小**(树中所有边的权重之和)的生成树。

![](.\images\最小生成树定义.png)

**约定：**

只考虑连通图。最小生成树的定义说明它只能存在于连通图中，如果图不是连通的，那么分别计算每个连通图子图的最小生成树，合并到一起称为最小生成森林。

![](.\images\最小生成树约定.png)

所有边的权重都各不相同。如果不同的边权重可以相同，那么一副图的最小生成树就可能不唯一了，虽然我们的算法可以处理这种情况，但为了好理解，我们约定所有边的权重都各不相同。

## 最小生成树原理

### 树的性质

1. 用一条边接树中的任意两个顶点都会产生一个新的环；

![](.\images\树的性质1.png)

2. 从树中删除任意一条边，将会得到两棵独立的树；

![](.\images\树的性质2.png)

### 切分定理

要从一副连通图中找出该图的最小生成树，需要通过切分定理完成。

**切分：**

将图的所有顶点按照某些规则分为两个非空且没有交集的集合。

**横切边：**

连接两个属于不同集合的顶点的边称之为横切边。

例如我们将图中的顶点切分为两个集合，灰色顶点属于一个集合，白色顶点属于另外一个集合，那么效果如下：

![](.\images\切分定理横切边.png)

**切分定理：**

在一副加权图中，给定任意的切分，它的横切边中的权重最小者必然属于图中的最小生成树。

![](.\images\切分定理1.png)

**注意 :**一次切分产生的多个横切边中，权重最小的边不一定是所有横切边中唯一属于图的最小生成树的边。

![](.\images\切分定理2.png)

## 贪心算法

贪心算法是计算图的最小生成树的基础算法，它的基本原理就是切分定理，**使用切分定理找到最小生成树的一条边，不断的重复直到找到最小生成树的所有边**。如果图有V个顶点，那么需要找到V-1条边，就可以表示该图的最小生成树。

![](.\images\贪心算法1.png)

![](.\images\贪心算法2.png)

![](.\images\贪心算法3.png)

计算图的最小生成树的算法有很多种，但这些算法都可以看做是贪心算法的一种特殊情况，这些算法的不同之处在于保存切分和判定权重最小的横切边的方式。

## Prim算法

我们学习第一种计算最小生成树的方法叫Prim算法，它的每一步都会为一棵生成中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将**下一条连接树中的顶点**与**不在树中的顶点且权重最小的边**加入到树中。

**Prim 算法的切分规则：**

把最小生成树中的顶点看做是一个集合，把不在最小生成树中的顶点看做是另外一个集合。

![](.\images\Prim算法的切分规则.png)

### Prim 算法 API 设计

| **类名** | **PrimMST**                                                  |
| -------- | ------------------------------------------------------------ |
| 构造方法 | PrimMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象； |
| 成员方法 | 1. private void visit(EdgeWeightedGraph G, int v)：将顶点v添加到最小生成树中，并且更新数据<br />2. public Queue edges():获取最小生成树的所有边 |
| 成员变量 | 1.private Edge[] edgeTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边<br />2.private double[] distTo: 索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重<br />3.private boolean[] marked:索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false<br />4.private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边 |

### Prim 算法的实现原理

Prim算法始终将图中的顶点切分成两个集合，最小生成树顶点和非最小生成树顶点，通过不断的重复做某些操作，可以逐渐将非最小生成树中的顶点加入到最小生成树中，直到所有的顶点都加入到最小生成树中。

我们在设计API的时候，使用最小索引优先队列存放树中顶点与非树中顶点的有效横切边，那么它是如何表示的呢？我们可以让最小索引优先队列的索引值表示图的顶点，让最小索引优先队列中的值表示从其他某个顶点到当前顶点的边权重。

![](.\images\Prim算法的实现原理1.png)

初始化状态，先默认0是最小生成树中的唯一顶点，其他的顶点都不在最小生成树中，此时横切边就是顶点0的邻接表中0-2,0-4,0-6,0-7这四条边，我们只需要将索引优先队列的2、4、6、7索引处分别存储这些边的权重值就可以表示了。

现在只需要从这四条横切边中找出权重最小的边，然后把对应的顶点加进来即可。所以找到0-7这条横切边的权重最小，因此把0-7这条边添加进来，此时0和7属于最小生成树的顶点，其他的不属于，现在顶点7的邻接表中的边也成为了横切边，这时需要做两个操作：

1、0-7这条边已经不是横切边了，需要让它失效：

只需要调用最小索引优先队列的delMin()方法即可完成；

2、2和4顶点各有**两条连接**指向最小生成树，需要只保留一条：

4-7的权重小于0-4的权重，所以保留4-7，调用索引优先队列的change(4,0.37)即可，

0-2的权重小于2-7的权重，所以保留0-2，不需要做额外操作。

![](.\images\Prim 算法的实现原理2.png)

我们不断重复上面的动作，就可以把所有的顶点添加到最小生成树中。

**代码**

```java
public class PrimMST {
    //索引代表顶点，值表示当前顶点和最小生成树之间的最短边
    private Edge[] edgeTo;
    //索引代表顶点，值表示当前顶点和最小生成树之间的最短边的权重
    private double[] distTo;
    //索引代表顶点，如果当前顶点已经在树中，则值为true，否则为false
    private boolean[] marked;
    //存放树中顶点与非树中顶点之间的有效横切边
    private IndexMinPriorityQueue<Double> pq;

    //根据一副加权无向图，创建最小生成树计算对象
    public PrimMST(EdgeWeightedGraph G) {
        //初始化edgeTo
        this.edgeTo = new Edge[G.V()];
        //初始化distTo
        this.distTo = new double[G.V()];
        for (int i = 0; i < distTo.length; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        //初始化marked
        this.marked = new boolean[G.V()];
        //初始化pq
        pq = new IndexMinPriorityQueue<Double>(G.V());

        //默认让顶点0进入到树中，但是树中只有一个顶点0，因此，0顶点默认没有和其他的顶点相连，所以让distTo对应位置处的值存储0.0
        distTo[0] = 0.0;
        pq.insert(0, 0.0);

        //遍历索引最小优先队列，拿到最小和N切边对应的顶点，把该顶点加入到最小生成树中
        while (!pq.isEmpty()) {
            visit(G, pq.delMin());
        }


    }


    //将顶点v添加到最小生成树中，并且更新数据
    private void visit(EdgeWeightedGraph G, int v) {
        //把顶点v添加到最小生成树中
        marked[v] = true;
        //更新数据
        for (Edge e : G.adj(v)) {
            //获取e边的另外一个顶点(当前顶点是v)
            //e这条边是v到w，或者w到v的
            int w = e.other(v);
            //判断另外一个顶点是不是已经在树中，如果在树中，则不做任何处理，如果不再树中，更新数据
            if (marked[w]) {
                continue;
            }


            //判断边e的权重是否小于从w顶点到树中已经存在的最小边的权重；
            //distTo[w] 保存着最小生成树之间的最小边的权重，w 到最小生成树之间可能有多条边，
            //如果找到了一条比现存最小变权重还要小的边，则更新edgeTo[w]、distTo[w]
            if (e.weight() < distTo[w]) {
                //更新数据
                edgeTo[w] = e;
                distTo[w] = e.weight();

                // 最小优先队列，存放树中顶点与非树中顶点之间的有效横切边
                // 如果已经存在，更新，没有存在，则增加
                if (pq.contains(w)) {
                    pq.changeItem(w, e.weight());
                } else {
                    pq.insert(w, e.weight());
                }

            }


        }

    }

    //获取最小生成树的所有边
    public Queue<Edge> edges() {
        //创建队列对象
        Queue<Edge> allEdges = new Queue<>();
        //遍历edgeTo数组，拿到每一条边，如果不为null，则添加到队列中
        for (int i = 0; i < edgeTo.length; i++) {
            if (edgeTo[i] != null) {
                allEdges.enqueue(edgeTo[i]);
            }
        }
        return allEdges;
    }

}

public class PrimMSTTest {

    public static void main(String[] args) throws Exception {


        //准备一副加权无向图
        BufferedReader br = new BufferedReader(new InputStreamReader(PrimMSTTest.class.getClassLoader().getResourceAsStream("min_create_tree_test.txt")));
        int total = Integer.parseInt(br.readLine());
        EdgeWeightedGraph G = new EdgeWeightedGraph(total);

        int edgeNumbers = Integer.parseInt(br.readLine());
        for (int e = 1; e <= edgeNumbers; e++) {
            String line = br.readLine();//4 5 0.35

            String[] strs = line.split(" ");

            int v = Integer.parseInt(strs[0]);
            int w = Integer.parseInt(strs[1]);

            double weight = Double.parseDouble(strs[2]);

            //构建加权无向边
            Edge edge = new Edge(v, w, weight);
            G.addEdge(edge);

        }

        //创建一个PrimMST对象，计算加权无向图中的最小生成树
        PrimMST primMST = new PrimMST(G);


        //获取最小生成树中的所有边
        Queue<Edge> edges = primMST.edges();

        //遍历打印所有的边
        for (Edge e : edges) {
            int v = e.either();
            int w = e.other(v);
            double weight = e.weight();
            System.out.println(v + "-" + w + " :: " + weight);

        }


    }
}
```

## kruskal 算法

kruskal算法是计算一副加权无向图的最小生成树的另外一种算法，它的主要思想是按照边的权重(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入最小生成树的边构成环，直到树中含有V-1条边为止。

**kruskal 算法和 prim 算法的区别：**

Prim算法是一条边一条边的构造最小生成树，每一步都为一棵树添加一条边。kruskal算法构造最小生成树的时候也是一条边一条边地构造，但它的切分规则是不一样的。它每一次寻找的边会连接一片森林中的两棵树。如果一副加权无向图由V个顶点组成，初始化情况下每个顶点都构成一棵独立的树，则V个顶点对应V棵树，组成一片森林， kruskal算法每一次处理都会将两棵树合并为一棵树，直到整个森林中只剩一棵树为止。

![](.\images\kruskal算法.png)

### kruskal 算法 API 设计

| **类名** | **KruskalMST**                                               |
| -------- | ------------------------------------------------------------ |
| 构造方法 | KruskalMST(EdgeWeightedGraph G)：根据一副加权无向图，创建最小生成树计算对象； |
| 成员方法 | 1.public Queue edges():获取最小生成树的所有边                |
| 成员变量 | 1. private Queue mst：保存最小生成树的所有边<br />2. private UF_Tree_Weighted uf: 索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并<br />3. private MinPriorityQueue pq: 存储图中所有的边，使用最小优先队列，对边按照权重进行排序 |

### kruskal 算法的实现原理

在设计API的时候，使用了一个MinPriorityQueue    pq存储图中所有的边，每次使用pq.delMin()取出权重最小的边，并得到该边关联的两个顶点v和w，通过uf.connect(v,w)判断v和w是否已经连通，如果连通，则证明这两个顶点在同一棵树中，那么就不能再把这条边添加到最小生成树中，因为在一棵树的任意两个顶点上添加一条边，都会形成环，而最小生成树不能有环的存在，如果不连通，则通过uf.connect(v,w)把顶点v所在的树和顶点w所在的树合并成一棵树，并把这条边加入到mst队列中，这样如果把所有的边处理完，最终mst中存储的就是最小生树的所有边。

![](.\images\kruskal 算法的实现原理1.png)

![](.\images\kruskal 算法的实现原理2.png)

![](.\images\kruskal 算法的实现原理3.png)

### 代码

```java
public class KruskalMST {
    //保存最小生成树的所有边
    private Queue<Edge> mst;
    //索引代表顶点，使用uf.connect(v,w)可以判断顶点v和顶点w是否在同一颗树中，使用uf.union(v,w)可以把顶点v所在的树和顶点w所在的树合并
    private UF_Tree_Weighted uf;
    //存储图中所有的边，使用最小优先队列，对边按照权重进行排序
    private MinPriorityQueue<Edge> pq;

    //根据一副加权无向图，创建最小生成树计算对象
    public KruskalMST(EdgeWeightedGraph G) {

        //初始化mst
        this.mst = new Queue<Edge>();
        //初始化uf
        this.uf = new UF_Tree_Weighted(G.V());
        //初始化pq
        this.pq = new MinPriorityQueue<>(G.E() + 1);
        //把图中所有的边存储到pq中
        for (Edge e : G.edges()) {
            pq.insert(e);
        }

        //遍历pq队列，拿到最小权重的边，进行处理

        while (!pq.isEmpty() && mst.size() < G.V() - 1) {
            //找到权重最小的边
            Edge e = pq.delMin();
            //找到该边的两个顶点
            int v = e.either();
            int w = e.other(v);

            //判断这两个顶点是否已经在同一颗树中，如果在同一颗树中，则不对该边做处理，如果不在一棵树中，则让这两个顶点属于的两棵树合并成一棵树
            if (uf.connected(v, w)) {
                continue;
            }

            uf.union(v, w);

            //让边e进入到mst队列中
            mst.enqueue(e);

        }

    }

    //获取最小生成树的所有边
    public Queue<Edge> edges() {
        return mst;
    }
}

public class KruskalMSTTest {

    public static void main(String[] args) throws Exception {


        //准备一副加权无向图
        BufferedReader br = new BufferedReader(new InputStreamReader(KruskalMSTTest.class.getClassLoader().getResourceAsStream("min_create_tree_test.txt")));
        int total = Integer.parseInt(br.readLine());
        EdgeWeightedGraph G = new EdgeWeightedGraph(total);

        int edgeNumbers = Integer.parseInt(br.readLine());
        for (int e = 1; e <= edgeNumbers; e++) {
            String line = br.readLine();//4 5 0.35

            String[] strs = line.split(" ");

            int v = Integer.parseInt(strs[0]);
            int w = Integer.parseInt(strs[1]);

            double weight = Double.parseDouble(strs[2]);

            //构建加权无向边
            Edge edge = new Edge(v, w, weight);
            G.addEdge(edge);

        }

        //创建一个KruskalMST对象，计算加权无向图中的最小生成树
        KruskalMST primMST = new KruskalMST(G);


        //获取最小生成树中的所有边
        Queue<Edge> edges = primMST.edges();

        //遍历打印所有的边
        for (Edge e : edges) {
            int v = e.either();
            int w = e.other(v);
            double weight = e.weight();
            System.out.println(v + "-" + w + " :: " + weight);

        }
    }
}
```

# 加权有向图

之前学习的加权无向图中，边是没有方向的，并且同一条边会同时出现在该边的两个顶点的邻接表中，为了能够处理含有方向性的图的问题，我们需要实现以下加权有向图。

## 加权有向图边的表示

**API 设计：**

| **类名** | **DirectedEdge**                                             |
| -------- | ------------------------------------------------------------ |
| 构造方法 | DirectedEdge(int v,int w,double weight)：通过顶点v和w，以及权重weight值构造一个边对象 |
| 成员方法 | 1.public double weight():获取边的权重值<br />2.public int from():获取有向边的起点<br />3.public int to():获取有向边的终点 |
| 成员变量 | 1.private ﬁnal int v：起点<br />2.private ﬁnal int w：终点<br />3.private ﬁnal double weight：当前边的权重 |

**代码：**

```java
public class DirectedEdge {
    private final int v;//起点
    private final int w;//终点
    private final double weight;//当前边的权重

    //通过顶点v和w，以及权重weight值构造一个边对象
    public DirectedEdge(int v, int w, double weight) {
        this.v = v;
        this.w = w;
        this.weight = weight;
    }

    //获取边的权重值
    public double weight() {
        return weight;
    }

    //获取有向边的起点
    public int from() {
        return v;
    }

    //获取有向边的终点
    public int to() {
        return w;
    }
}
```

## 加权有向图的实现

之前我们已经完成了有向图，在有向图的基础上，我们只需要把边的表示切换成DirectedEdge对象即可。

**API 设计：**

| **类名** | **EdgeWeightedDigraph**                                      |
| -------- | ------------------------------------------------------------ |
| 构造方法 | EdgeWeightedDigraph(int V)：创建一个含有V个顶点的空加权有向图 |
| 成员方法 | 1.public int V():获取图中顶点的数量<br />2.public int E():获取图中边的数量<br />3.public void addEdge(DirectedEdge e):向加权有向图中添加一条边e <br />4.public Queue adj(int v)：获取由顶点v指出的所有的边<br />5.public Queue edges()：获取加权有向图的所有边 |
| 成员变量 | 1.private ﬁnal int V: 记录顶点数量<br />2.private int E: 记录边数量<br />3.private Queue[] adj: 邻接表 |

**代码：**

```java
public class EdgeWeightedDigraph {
    //顶点总数
    private final int V;
    //边的总数
    private int E;
    //邻接表
    private Queue<DirectedEdge>[] adj;

    //创建一个含有V个顶点的空加权有向图
    public EdgeWeightedDigraph(int V) {
        //初始化顶点数量
        this.V = V;
        //初始化边的数量
        this.E = 0;
        //初始化邻接表
        this.adj = new Queue[V];

        for (int i = 0; i < adj.length; i++) {
            adj[i] = new Queue<DirectedEdge>();
        }
    }

    //获取图中顶点的数量
    public int V() {
        return V;
    }

    //获取图中边的数量
    public int E() {
        return E;
    }


    //向加权有向图中添加一条边e
    public void addEdge(DirectedEdge e) {
        //边e是有方向的，所以只需要让e出现在起点的邻接表中即可
        int v = e.from();
        adj[v].enqueue(e);
        E++;
    }

    //获取由顶点v指出的所有的边
    public Queue<DirectedEdge> adj(int v) {
        return adj[v];
    }

    //获取加权有向图的所有边
    public Queue<DirectedEdge> edges() {
        //遍历图中的每一个顶点，得到该顶点的邻接表，遍历得到每一条边，添加到队列中返回即可
        Queue<DirectedEdge> allEdges = new Queue<>();
        for (int v = 0; v < V; v++) {
            for (DirectedEdge edge : adj[v]) {
                allEdges.enqueue(edge);
            }
        }
        return allEdges;
    }
}
```

# 最短路径

有了加权有向图之后，我们立刻就能联想到实际生活中的使用场景，例如在一副地图中，找到地点a与地点b之间的路径，这条路径可以是距离最短，也可以是时间最短，也可以是费用最小等，如果我们把距离、时间、费用看做是成本，那么就需要找到地点a和地点b之间成本最小的路径，也就是我们接下来要解决的最短路径问题。

## 最短路径定义及性质

**定义：**

在一副加权有向图中，从顶点s到顶点t的最短路径是所有从顶点s到顶点t的路径中总权重最小的那条路径。

![](.\images\最短路径定义.png)

**性质：**

1. 路径具有方向性；

2. 权重不一定等价于距离。权重可以是距离、时间、花费等内容，权重最小指的是成本最低

3. 只考虑连通图。一副图中并不是所有的顶点都是可达的，如果s和t不可达，那么它们之间也就不存在最短路径，  为了简化问题，这里只考虑连通图。

4. 最短路径不一定是唯一的。从一个顶点到达另外一个顶点的权重最小的路径可能会有很多条，这里只需要找出一  条即可。

**最短路径树：**

给定一副加权有向图和一个顶点s，以s为起点的一棵最短路径树是图的一副子图，它包含顶点s以及从s可达的所有顶点。这棵有向树的根结点为s，树的每条路径都是有向图中的一条最短路径。

## 最短路径树 API 设计

计算最短路径树的经典算法是dijstra算法，为了实现它，先设计如下API：

| **类名** | **DijkstraSP**                                               |
| -------- | ------------------------------------------------------------ |
| 构造方法 | public DijkstraSP(EdgeWeightedDigraph G, int s)：根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象 |
| 成员方法 | 1.private void relax(EdgeWeightedDigraph G, int v)：松弛图G中的顶点v <br />2.public double distTo(int v):获取从顶点s到顶点v的最短路径的总权重<br />3.public boolean hasPathTo(int v):判断从顶点s到顶点v是否可达<br />4.public Queue pathTo(int v):查询从起点s到顶点v的最短路径中所有的边 |
| 成员变量 | 1. private DirectedEdge[] edgeTo: 索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边<br />2. private double[] distTo: 索引代表顶点，值表示从顶点s到当前顶点的最短路径的总权重<br />3. private IndexMinPriorityQueue pq:存放树中顶点与非树中顶点之间的有效横切边 |

## 松弛技术

松弛这个词来源于生活：一条橡皮筋沿着两个顶点的某条路径紧紧展开，如果这两个顶点之间的路径不止一条，还有存在更短的路径，那么**把皮筋转移到更短的路径上**，皮筋就可以放松了。

![](.\images\松弛技术.png)

松弛这种简单的原理刚好可以用来计算最短路径树。

在我们的API中，需要用到两个成员变量edgeTo和distTo，分别存储边和权重。一开始给定一幅图G和顶点s，我们只知道图的边以及这些边的权重，其他的一无所知，此时初始化顶点s到顶点s的最短路径的总权重disto[s]=0；顶点s到其他顶点的总权重默认为无穷大，随着算法的执行，不断的使用松弛技术处理图的边和顶点，并按一定的条件更新edgeTo和distTo中的数据，最终就可以得到最短路径树。

**边的松弛：**

放松边v->w意味着检查从s到w的最短路径是否先从s到v，然后再从v到w？

如果是，则v-w这条边需要加入到最短路径树中，更新edgeTo和distTo中的内容：edgeTo[w]=表示v->w这条边的DirectedEdge对象，distTo[w]=distTo[v]+v->w这条边的权重；

如果不是，则忽略v->w这条边。

![](.\images\边的松弛.png)

**顶点的松弛：**

顶点的松弛是基于边的松弛完成的，只需要把某个顶点指出的所有边松弛，那么该顶点就松弛完毕。例如要松弛顶点v，只需要遍历v的邻接表，把每一条边都松弛，那么顶点v就松弛了。

如果把起点设置为顶点0，那么找出起点0到顶点6的最短路径0->2->7>3->6的过程如下:

![](.\images\顶点的松弛.png)

## Dijstra 算法实现

Disjstra算法的实现和Prim算法很类似，构造最短路径树的每一步都是向这棵树中添加一条新的边，而这条新的边  是有效横切边pq队列中的权重最小的边。

```java
public class DijkstraSP {
    //索引代表顶点，值表示从顶点s到当前顶点的最短路径上的最后一条边
    private DirectedEdge[] edgeTo;
    //索引代表顶点，值表示从顶点s到当前顶点的最短路径的总权重
    private double[] distTo;
    //存放树中顶点与非树中顶点之间的有效横切边
    private IndexMinPriorityQueue<Double> pq;

    //根据一副加权有向图G和顶点s，创建一个计算顶点为s的最短路径树对象
    public DijkstraSP(EdgeWeightedDigraph G, int s) {
        //初始化edgeTo
        this.edgeTo = new DirectedEdge[G.V()];
        //初始化distTo
        this.distTo = new double[G.V()];
        for (int i = 0; i < distTo.length; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        //初始化pq
        this.pq = new IndexMinPriorityQueue<>(G.V());

        //找到图G中以顶点s为起点的最短路径树

        //默认让顶点s进入到最短路径树中
        distTo[s] = 0.0;
        pq.insert(s, 0.0);

        //遍历pq

        while (!pq.isEmpty()) {
            relax(G, pq.delMin());
        }

    }

    //松弛图G中的顶点v
    private void relax(EdgeWeightedDigraph G, int v) {

        for (DirectedEdge edge : G.adj(v)) {
            //获取到该边的终点w
            int w = edge.to();

            //通过松弛技术，判断从起点s到顶点w的最短路径是否需要先从顶点s到顶点v，然后再由顶点v到顶点w
            if (distTo(v) + edge.weight() < distTo(w)) {
                distTo[w] = distTo[v] + edge.weight();
                edgeTo[w] = edge;

                //判断pq中是否已经存在顶点w，如果存在，则更新权重，如果不存在，则直接添加
                if (pq.contains(w)) {
                    pq.changeItem(w, distTo(w));
                } else {
                    pq.insert(w, distTo(w));
                }

            }
        }

    }

    //获取从顶点s到顶点v的最短路径的总权重
    public double distTo(int v) {
        return distTo[v];
    }

    //判断从顶点s到顶点v是否可达
    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    //查询从起点s到顶点v的最短路径中所有的边
    public Queue<DirectedEdge> pathTo(int v) {
        //判断从顶点s到顶点v是否可达，如果不可达，直接返回null
        if (!hasPathTo(v)) {
            return null;
        }

        //创建队列对象
        Queue<DirectedEdge> allEdges = new Queue<>();

        while (true) {
            DirectedEdge e = edgeTo[v];
            if (e == null) {
                break;
            }

            allEdges.enqueue(e);

            v = e.from();
        }


        return allEdges;
    }

}

public class DijkstraSPTest {

    public static void main(String[] args) throws Exception {
        //创建一副加权有向图
        BufferedReader br = new BufferedReader(new InputStreamReader(DijkstraSPTest.class.getClassLoader().getResourceAsStream("min_route_test.txt")));
        int total = Integer.parseInt(br.readLine());
        EdgeWeightedDigraph G = new EdgeWeightedDigraph(total);

        int edgeNumbers = Integer.parseInt(br.readLine());
        for (int i = 1; i <= edgeNumbers; i++) {
            String line = br.readLine();//4 5 0.35
            String[] strs = line.split(" ");
            int v = Integer.parseInt(strs[0]);
            int w = Integer.parseInt(strs[1]);

            double weight = Double.parseDouble(strs[2]);

            DirectedEdge e = new DirectedEdge(v, w, weight);
            G.addEdge(e);

        }
        //创建DijkstraSP对象，查找最短路径树
        DijkstraSP dijkstraSP = new DijkstraSP(G, 0);

        //查找最短路径,0->6的最短路径
        Queue<DirectedEdge> edges = dijkstraSP.pathTo(6);


        //遍历打印
        for (DirectedEdge edge : edges) {

            System.out.println(edge.from() + "->" + edge.to() + " ：： " + edge.weight());
        }

    }
}
```

