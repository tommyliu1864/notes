# 前言

## 学习目标

- 从底层深入理解运行时数据区
- 深入理解对象与垃圾回收机制!

## JVM的跨平台与语言无关性
- JVM 的跨平台

- JVM 的语言无关性

  ![](.\pictures\JVM的垮平台与语言无关性.png)

## Java程序从编译到执行的过程
- Java 程序运行过程
- JDK、JRE与JVM
![](.\pictures\Java程序从编译到执行的过程.png)

## Java SE体系架构
- JDK 提供了工具
- JRE 提供了基础类库
- JVM 只是一个翻译

<img src=".\pictures\Java SE体系架构.jpg" style="zoom:80%;" />

## JVM 的大致运行过程
![](.\pictures\JVM的运行过程.png)

# 运行时数据区域
- Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域

## 学JVM学的是什么？
- 学的是Java程序在运行时，程序数据在内存中的管理
- JVM 会对我们的应用程序的数据，进行分类管理，我们要知道什么数据放到什么地方，以及什么时候会被回收，什么时候会被腾挪

<img src=".\pictures\运行时数据区.png" style="zoom:80%;" />

## Java 方法运行的内存区域

### 虚拟机栈
- 存储当前线程运行方法所需的数据，指令、返回地址
- 栈是什么样的数据结构？先进后出(FILO)的数据结构，
- 虚拟机栈在JVM运行过程中存储当前线程运行方法所需的数据，指令、返回地址。
- Java 虚拟机栈是基于线程的。哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生命周期是和线程一样的。
- 栈里的每条数据，就是栈帧。在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦完成相应的调用，则出栈。所有的栈帧都出栈后，线程也就结束了。
- 每个栈帧，都包含四个区域：(局部变量表、操作数栈、动态连接、返回地址)
- 栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k

### 栈帧
- 局部变量表
    - 顾名思义就是局部变量的表，用于存放我们的局部变量的。首先它是一个32位的长度，主要存放我们的Java的八大基础数据类型，一般32位就可以存放下，如果是64位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的Object对象，我们只需要存放它的一个引用地址即可。
    
- 操作数据栈
    - 存放我们方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的java数据类型，所以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的，操作数栈运行方法就是JVM一直运行入栈/出栈的操作
    
- 动态连接
    - Java语言特性多态（需要类运行时才能确定具体的方法）。
    
- 返回地址
    - 正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表<非栈帧中的>来确定）
    
      <img src=".\pictures\栈帧.jpg" style="zoom:80%;" />

### 栈帧执行对内存区域的影响
- javap -c 反汇编指令
- 字节码助记码解释地址：https://cloud.tencent.com/developer/article/1333540
<img src=".\pictures\栈帧执行对内存区域的影响.png" style="zoom:80%;" />



<img src=".\pictures\栈帧执行对内存区域的影响2.png" style="zoom:80%;" />

### 程序计数器
- 指向当前线程正在执行的字节码指令的地址
- 较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。
程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。
由于 Java 是多线程语言，当执行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。
程序计数器也是JVM中唯一不会OOM(OutOfMemory)的内存区域

### 本地方法（Native）运行的内存区域
**本地方法栈**

- 本地方法栈保存的是native方法的信息
- 当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单地动态链接并直接调用native方法
- 虚拟机规范无强制规定，各版本虚拟机自由实现HotSpot直接把本地方法栈和虚拟机栈合二为一

## 线程共享的区域
### 方法区
- 类信息
- 常量
- 静态变量
- 即时编译期编译后的代码

#### 方法区/永久代
- 很多开发者都习惯将方法区称为“永久代”，其实这两者并不是等价的。
- HotSpot 虚拟机使用永久代来实现方法区，但在其它虚拟机中，例如，Oracle 的 JRockit、IBM 的 J9 就不存在永久代一说。因此，方法区只是 JVM 中规范的一部分，可以说，在 HotSpot 虚拟机中，设计人员使用了永久代来实现了 JVM 规范的方法区。
- 方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、静态变量、常量、运行时常量池、字符串常量池。
- JVM 在执行某个类的时候，必须先加载。在加载类（加载、验证、准备、解析、初始化）的时候，JVM 会先加载 class 文件，而在 class 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种字面量和符号引用。
- 字面量包括字符串（String a=“b”）、基本类型的常量（final 修饰的变量），符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。
- 而当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时的常量池中；在解析阶段，JVM 会把符号引用替换为直接引用（对象的索引值）。
- 例如，类中的一个字符串常量在 class 文件中时，存放在 class 文件常量池中的；在 JVM 加载完类之后，JVM 会将这个字符串常量放到运行时常量池中，并在解析阶段，指定该字符串对象的索引值。运行时常量池是全局共享的，多个类共用一个运行时常量池，class 文件中常量池多个相同的字符串在运行时常量池只会存在一份。
- 方法区与堆空间类似，也是一个共享内存区，所以方法区是线程共享的。假如两个线程都试图访问方法区中的同一个类信息，而这个类还没有装入 JVM，那么此时就只允许一个线程去加载它，另一个线程必须等待。在 HotSpot 虚拟机、Java7 版本中已经将永久代的静态变量和运行时常量池转移到了堆中，其余部分则存储在 JVM 的非堆内存中，而 Java8 版本已经将方法区中实现的永久代去掉了，并用元空间（class metadata）代替了之前的永久代，并且元空间的存储位置是本地
- 元空间大小参数： 
    - jdk1.7及以前（初始和最大值）：-XX:PermSize；-XX:MaxPermSize；
    - jdk1.8以后（初始和最大值）：-XX:MetaspaceSize； -XX:MaxMetaspaceSize
    - jdk1.8以后大小就只受本机总内存的限制（如果不设置参数的话）

### Java 堆
- 对象实例（几乎所有）
- 数组

#### Java 堆的大小参数设置
- -Xms：堆的最小值；
- -Xmx：堆的最大值；
- -Xmn：新生代的大小；
- -XX:NewSize；新生代最小值；
- -XX:MaxNewSize：新生代最大值；
- 例如- Xmx256m
- JVM参数参考：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html

### 补充
- 堆是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是在这里存储的。我们常说的垃圾回收，操作的对象就是堆。
- 堆空间一般是程序启动时，就申请了，但是并不一定会全部使用。
- 随着对象的频繁创建，堆空间占用的越来越多，就需要不定期的对不再使用的对象进行回收。这个在 Java 中，就叫作 GC（Garbage Collection）。
- 那一个对象创建的时候，到底是在堆上分配，还是在栈上分配呢？这和两个方面有关：对象的类型和在 Java 类中存在的位置。
- Java 的对象可以分为基本数据类型和普通对象。
- 对于普通对象来说，JVM 会首先在堆上创建对象，然后在其他地方使用的其实是它的引用。比如，把这个引用保存在虚拟机栈的局部变量表中。
- 对于基本数据类型来说（byte、short、int、long、float、double、char)，有两种情况。当你在方法体内声明了基本数据类型的对象，它就会在栈上直接分配。其他情况，都是在堆上分配。

## 直接内存
- 不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。
- 如果使用了NIO,这块区域会被频繁使用，在Java堆内可以用directByteBuffer对象直接引用并操作。
- 这块内存不受Java堆大小限制，但受本机总内存的限制，可以通过MaxDirectMemorySize来设置（默认与堆内存最大值一样），所以也会出现OOM异常。

![](.\pictures\直接内存.png)

## 从底层深入理解运行时数据区
**开启HSDB工具**

Jdk1.8启动JHSDB的时候必须将sawindbg.dll复制到对应目录的jre下

将C:\Program Files\Java\jdk1.8.0_111\jre\bin\sawindbg.dll复制到 C:\Program Files\Java\jre1.8.0_111\bin

进入 C:\Program Files\Java\jdk1.8.0_111\lib，执行 java -cp .\sa-jdi.jar sun.jvm.hotspot.HSDB

<img src=".\pictures\HSDB.png" style="zoom:80%;" />

- show the stack memory for the current thread

  <img src=".\pictures\HSDB2.png" style="zoom:80%;" />

- object histogram

  <img src=".\pictures\HSDB-object histogram.png" style="zoom:80%;" />

- inspect

  <img src=".\pictures\HSDB-inspect.png" style="zoom:80%;" />

- heap parameters

  <img src=".\pictures\HSDB-heap parameters.png" style="zoom:80%;" />

  <img src=".\pictures\深入理解运行时数据区.png" style="zoom:80%;" />

  ![](.\pictures\运行时数据区分布.png)

**步骤**

- 申请内存
- 类加载，class进入方法区
- 常量、静态变量入方法区
- 虚拟机栈入栈帧
- 栈帧的方法执行

**JPS**

-  jps是jdk提供的一个查看当前Java进程的小工具， 可以看做是Java Virtual Machine Process Status Tool的缩写。

## 深入辨析堆和栈

### 功能
以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；
而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；

### 线程独享还是共享
栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。
堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。

### 空间大小
栈的内存要远远小于堆内存，栈的深度是有限制的，可能发生StackOverFlowError问题。

## 内存溢出

- ### 栈溢出
  
    - 参数：-Xss1m， 具体默认值需要查看官网：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html#BABHDABI
    - HotSpot版本中栈的大小是固定的，是不支持拓展的。
    java.lang.StackOverflowError  
    - 一般的方法调用是很难出现的，如果出现了可能会是无限递归。
- ### 堆溢出
  
    - 内存溢出：申请内存空间,超出最大堆内存空间。
    - 如果是内存溢出，则通过 调大 -Xms，-Xmx参数。
- ### 方法区溢出
  
    - 运行时常量池溢出
    - 方法区中保存的Class对象没有被及时回收掉或者Class信息占用的内存超过了我们配置。
    - Class要被回收，条件比较苛刻（仅仅是可以，不代表必然，因为还有一些参数可以进行控制）
        - 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
        - 加载该类的ClassLoader已经被回收。
        - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
- ### 本机直接内存溢出


## 虚拟机优化技术
### 编译优化技术——方法内联
方法内联的优化行为，就是把目标方法的代码原封不动的“复制”到调用的方法中，避免真实的方法调用而已。

### 栈的优化技术——栈帧之间数据的共享
在一般的模型中，两个不同的栈帧的内存区域是独立的，但是大部分的JVM在实现中会进行一些优化，使得两个栈帧出现一部分重叠。（主要体现在方法中有参数传递的情况），让下面栈帧的操作数栈和上面栈帧的部分局部变量重叠在一起，这样做不但节约了一部分空间，更加重要的是在进行方法调用时就可以直接公用一部分数据，无需进行额外的参数复制传递了。

![](.\pictures\栈帧之间数据的共享.png)

# 对象

## 虚拟机中对象的创建过程

![](.\pictures\虚拟机中对象的创建过程.png)

### 检查加载

- 首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（符号引用：符号引用以一组符号来描述所引用的目标），并且检查类是否已经被加载、解析和初始化过。

### 分配内存

接下来虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

- 指针碰撞
    - 如果Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。

- 空闲列表
    - 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
    - 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。
    - 如果是Serial、ParNew等带有压缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。
    - 如果是使用CMS这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。

![](.\pictures\空闲列表.png)

### 并发安全
除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。

- CAS机制（Compare And Swap）
    - 解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；

- 分配缓冲
    - 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），JVM在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。
    - TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间，减少同步开销。
    - TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。
    - 参数：
        - -XX:+UseTLAB 允许在年轻代空间中使用线程本地分配块（TLAB）。默认情况下启用此选项。要禁用TLAB，请指定-XX:-UseTLAB。 https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.htm

![](.\pictures\TLAB.png)

### 内存空间初始化
- （注意不是构造方法）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 设置
- 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息（Java classes在Java hotspot VM内部表示为类元数据）、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。

### 对象初始化
- 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化(构造方法)，这样一个真正可用的对象才算完全产生出来。

## 对象的内存布局

![](.\pictures\对象的内存布局.png)

- 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
- 对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。
- 对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
- 如果对象是一个java数组，那么在对象头中还有一块用于记录数组长度的数据。
- 第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。当对象其他数据部分没有对齐时，就需要通过对齐填充来补全。

## 对象的访问定位
建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。

### 使用句柄
如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

![](.\pictures\使用句柄.png)

### 直接指针
- 如果使用直接指针访问， reference中存储的直接就是对象地址。
- 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。
- 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。
- 对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。

![](.\pictures\直接指针.png)


## 判断对象的存活
在堆里面存放着几乎所有的对象实例，垃圾回收器在对对进行回收前，要做的事情就是确定这些对象中哪些还是“存活”着，哪些已经“死去”（死去代表着不可能再被任何途径使用得对象了）
- 引用计数算法

- 可达性分析(根可达)

- finalize

  ![](.\pictures\可达性分析.png)

### 引用计数算法
在对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1，当引用失效时，计数器减1.
Python在用，但主流虚拟机没有使用，因为存在对象相互引用的情况，这个时候需要引入额外的机制来处理，这样做影响效率。

### 可达性分析
来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
作为GC Roots的对象包括下面几种：
- 虚拟机栈（栈帧中的本地变量表）中引用的对象。
- 方法区中类静态属性引用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI（即一般说的Native方法）引用的对象。
- JVM的内部引用（class对象、异常对象NullPointException、OutofMemoryError，系统类加载器）。
- 所有被同步锁(synchronized关键)持有的对象。
- JVM内部的JMXBean、JVMTI中注册的回调、本地代码缓存等
- JVM实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收只回收部分代时）

### Finalize方法
即使通过可达性分析判断不可达的对象，也不是“非死不可”，它还会处于“缓刑”阶段，真正要宣告一个对象死亡，需要经过两次标记过程，一次是没有找到与GCRoots的引用链，它将被第一次标记。随后进行一次筛选（如果对象覆盖了finalize），我们可以在finalize中去拯救。


## 各种引用
### 强引用
一般的Object obj = new Object() ，就属于强引用。在任何情况下，只有有强引用关联（与根可达）还在，垃圾回收器就永远不会回收掉被引用的对象。

### 软引用 SoftReference
- 一些有用但是并非必需，用软引用关联的对象，系统将要发生内存溢出（OuyOfMemory）之前，这些对象就会被回收（如果这次回收后还是没有足够的空间，才会抛出内存溢出）。参见代码：
VM参数 -Xms10m  -Xmx10m -XX:+PrintGC

- 例如，一个程序用来处理用户提供的图片。如果将所有图片读入内存，这样虽然可以很快的打开图片，但内存空间使用巨大，一些使用较少的图片浪费内存空间，需要手动从内存中移除。如果每次打开图片都从磁盘文件中读取到内存再显示出来，虽然内存占用较少，但一些经常使用的图片每次打开都要访问磁盘，代价巨大。这个时候就可以用软引用构建缓存。

### 弱引用 WeakReference
- 一些有用（程度比软引用更低）但是并非必需，用弱引用关联的对象，只能生存到下一次垃圾回收之前，GC发生时，不管内存够不够，都会被回收。
- 当一个对象仅仅被 WeakReference（弱引用）指向, `而没有任何其他strong reference（强引用）指向的时候`, 如果这时GC运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。
- 注意：软引用 SoftReference和弱引用 WeakReference，可以用在内存资源紧张的情况下以及创建不是很重要的数据缓存。当系统内存不足的时候，缓存中的内容是可以被释放的。
- 实际运用（WeakHashMap、ThreadLocal）

### 虚引用 PhantomReference
- 幽灵引用，最弱（随时会被回收掉）
- 垃圾回收的时候收到一个通知，就是为了监控垃圾回收器是否正常工作。

# 垃圾回收机制

## 学习垃圾回收的意义

- Java与C++等语言最大的技术区别：自动化的垃圾回收机制（GC）
- 为什么要了解GC和内存分配策略
    - 面试需要
    - GC对应用的性能是有影响的；
    - 写代码有好处
- 栈：栈中的生命周期是跟随线程，所以一般不需要关注
- 堆：堆中的对象是垃圾回收的重点
- 方法区/元空间：这一块也会发生垃圾回收，不过这块的效率比较低，一般不是我们关注的重点

## 对象的分配策略
### 对象的分配原则
- 对象优先在Eden分配
- 空间分配担保
- 大对象直接进入老年代
- 长期存活的对象进入老年代
- 动态对象年龄判定

![](.\pictures\对象的分配策略.png)

#### 栈中分配对象
##### 没有逃逸
- 即方法中的对象没有发生逃逸。
- 逃逸分析的原理：分析对象动态作用域，当一个对象在方法中定义后，它可能被外部方法所引用，比如：调用参数传递到其他方法中，这种称之为方法逃逸，甚至还有可能被外部线程访问到，例如：赋值给其他线程中访问的变量，这个称之为线程逃逸。
- 从不逃逸到方法逃逸到线程逃逸，称之为对象由低到高的不同逃逸程度。
- 如果确定一个对象不会逃逸出线程之外，那么让对象在栈上分配内存可以提高JVM的效率。

##### 逃逸分析
- 如果是逃逸分析出来的对象可以在栈上分配的话，那么该对象的生命周期就跟随线程了，就不需要垃圾回收，如果是频繁的调用此方法则可以得到很大的性能提高。
  采用了逃逸分析后，满足逃逸的对象在栈上分配

- 没有开启逃逸分析，对象都在堆上分配，会频繁触发垃圾回收（垃圾回收会影响系统性能），导致代码运行慢

  <img src=".\pictures\逃逸分析.png" style="zoom:80%;" />

### 对象优先在Eden分配
虚拟机参数：
- -Xms20m
- -Xmx20m
- -Xmn10m
- -XX:+PrintGCDetails

-XX:+PrintGCDetails 打印垃圾回收日志，程序退出时输出当前内存的分配情况

注意：新生代初始时就有大小

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间分配时，虚拟机将发起一次Minor GC。

**为什么要把对象分为新生代和老年代？分开存储的目的是什么？**

可以设计不同的回收机制

**为什么要设计要不同的回收机制？**

因为大部分的新对象都是朝生夕死，新生代可能没1秒钟清理，老年代10分钟清理；假如你在深圳，冬天的衣服和夏天衣服肯定不是放在同一个地方，夏天的衣服天天要穿，冬天的羽绒服也就穿一两周。

### 大对象直接进入老年代
- -Xms20m
- -Xmx20m
- -Xmn10m
- -XX:+PrintGCDetails
- -XX:PretenureSizeThreshold=4m
- -XX:+UseSerialGC

PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。

最典型的大对象是那种很长的字符串以及数组。这样做的目的：1.避免大量内存复制,2.避免提前进行垃圾回收，明明内存有空间进行分配。

### 长期存活的对象进入老年代
如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1，对象在Survivor区中每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定程度(并发的垃圾回收器默认为15),CMS是6时，就会被晋升到老年代中。

-XX:MaxTenuringThreshold调整

### 对象年龄动态判定
为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

### 空间分配担保

在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果担保失败则会进行一次Full GC；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。


### 堆中的优化技术
- 本地线程分配缓冲(TLAB)


## 分代收集理论
- 绝大部分的对象都是朝生夕死

- 对象熬过多次垃圾回收，越难回收

- 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

- 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。

  ![](.\pictures\分代收集理论.png)

## 复制算法（Copying）
**特点**

- 实现简单、运行高效

- 内存复制、没有内存碎片

- 利用率只有一半

  ![](.\pictures\复制算法.png)

- 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半。
注意：内存移动是必须实打实的移动（复制），不能使用指针玩。
- 专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
- HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）

## 标记-清除算法（Mark-Sweep）
**特点**

- 执行效率不稳定

- 内存碎片导致提前GC

  ![](.\pictures\标记-清除算法.png)

- 算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

- 它的主要不足空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

## 标记-整理算法（Mark-Compact）
**特点**

- 对象移动

- 引用更新

- 用户线程暂停

- 没有内存碎片

  ![](.\pictures\标记-整理算法.png)

- 首先标记出所有需要回收的对象，在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。标记整理算法虽然没有内存碎片，但是效率偏低。

## JVM中常见的垃圾收集器
- 单线程垃圾收集器 

- 多线程并行垃圾收集器 

- 多线程并发垃圾收集器

  ![](.\pictures\JVM中常见的垃圾收集器.png)

  ![](.\pictures\JVM中常见的垃圾收集器2.png)

  ![](.\pictures\JVM中常见的垃圾收集器3.png)

- 并行：垃圾收集的多线程的同时进行。
- 并发：垃圾收集的多线程和应用的多线程同时进行。
- 吞吐量=运行用户代码时间/(运行用户代码时间+ 垃圾收集时间)
- 垃圾收集时间= 垃圾回收频率 * 单次垃圾回收时间

## 简单的垃圾回收器工作示意图
![](.\pictures\简单的垃圾回收器工作示意图.png)


### Serial/Serial Old
- 最古老的，单线程，独占式，成熟，适合单CPU  服务器
- -XX:+UseSerialGC 新生代和老年代都用串行收集器
- -XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old
- -XX:+UseParallelGC 新生代使用ParallerGC，老年代使用Serial Old

### ParNew 
- 和Serial基本没区别，唯一的区别：多线程，多CPU的，停顿时间比Serial少
- -XX:+UseParNewGC 新生代使用ParNew，老年代使用Serial Old

### Parallel Scavenge（ParallerGC）/Parallel Old
- 关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
- 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

### CMS垃圾回收器工作示意图

<img src=".\pictures\CMS垃圾回收器工作示意图.png" style="zoom:80%;" />

- 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。
- 从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：
    - 初始标记-短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。
    - 并发标记-和用户的应用程序同时进行，进行GC Roots追踪的过程
    - 重新标记-短暂，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短
    - 并发清除

- 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。
- -XX:+UseConcMarkSweepGC ，表示新生代使用ParNew，老年代的用CMS
- 浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。


## Stop The World现象
- 什么是STW

- 为什么要STW

- STW的危害

  ![](.\pictures\Stop The World现象.png)

  ![](.\pictures\Stop The World现象2.png)

## G1图示
<img src=".\pictures\Garbage First.png" style="zoom:80%;" />

- -XX:+UseG1GC

### 并行与并发
G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

### 分代收集
与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

### 空间整合
与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

### 内存布局
在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

### 新生代GC
回收Eden区和survivor区，回收后，所有eden区被清空，存在一个survivor区保存了部分数据。老年代区域会增多，因为部分新生代的对象会晋升到老年代。

### 并发标记周期 
- 初始标记：短暂，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，产生一个全局停顿，都伴随有一次新生代的GC。
- 根区域扫描：扫描survivor区可以直接到达的老年代区域。
- 并发标记阶段：扫描和查找整个堆的存活对象，并标记。
- 重新标记：会产生全局停顿，对并发标记阶段的结果进行修正。
- 独占清理：会产生全局停顿，对GC回收比例进行排序，供混合收集阶段使用
- 并发清理：识别并清理完全空闲的区域，并发进行

### 混合收集 
对含有垃圾比例较高的Region进行回收。


- G1当出现内存不足的的情况，也可能进行的FullGC回收。
- G1中重要的参数：
    - -XX:MaxGCPauseMillis 指定目标的最大停顿时间，G1尝试调整新生代和老年代的比例，堆大小，晋升年龄来达到这个目标时间。
    - -XX:ParallerGCThreads：设置GC的工作线程数量


# JVM的几种常量池
- Class 文件常量池
- 运行时常量池
- 字符串常量池

![](.\pictures\JVM的几种常量池.png)

## Class 文件常量池
- class 文件中存在常量池，其在编译阶段就已经确定。
- 用javap -v 命令查看编译后的文件：javap -v JavaBean.class
- class文件常量池主要存放两大常量：字面量和符号引用

![](.\pictures\Class 文件常量池.png)

```java
public class ClassConstantPool {

    private int value = 1;
    public String s = "abc";
    public final static int f = 0x101;

    public void setValue(int v) {
        final int temp = 3;
        this.value = temp + v;
    }

    public int getValue() {
        return value;
    }
}
```

![](.\pictures\Class 文件常量池2.png)

### 字面量
字面量主要包括：
- 文本字符串，也就是我们经常声明的：public String s = "abc";中的"abc"
```
 #9 = Utf8               s
 #3 = String             #31            // abc
 #31 = Utf8              abc
```

- 用final修饰的成员变量，包括静态变量、实例变量和局部变量
```
 #11 = Utf8               f
 #12 = Utf8               ConstantValue
 #13 = Integer            257
```

- 存在于常量池的字面量，指的是数据的值，也就是abc和0x101(257)，通过对常量池的观察可知这两个字面量是确实存在于常量池中。
- 而对于基本类型数据(甚至是方法中的局部变量)，也就是上面的private int value = 1;常量池中只保留了他的的字段描述符I和字段的名称value，他们的字面量不会存在于常量池。

### 符号引用
符号引用主要包括下面三类常量：
- 类和接口的全限定名，也就是Ljava/lang/String;这样，将类名中原来的"."替换为"/"得到的，主要用于在运行时解析得到类的直接引用，像上面：

```bash
 #5 = Class              #33            // com/dongnaoedu/jvmstudylib/JavaBean
 #33 = Utf8               JavaBasicKnowledge/JavaBean
```

- 字段的名称和描述符，字段也就是类或者接口中声明的变量，包括类级别变量(static)和实例级的变量

```bash
 #4 = Fieldref           #5.#32         // com/dongnaoedu/jvmstudylib/JavaBean.value:I
 #5 = Class              #33            // com/dongnaoedu/jvmstudylib/JavaBean
 #32 = NameAndType       #7:#8          // value:I
 
 #7 = Utf8               value
 #8 = Utf8               I
 
 //这两个是局部变量，只保留字段名称
 #23 = Utf8               v
 #24 = Utf8               temp
```

- 方法的名称和描述符，方法的描述类似于JNI动态注册时的“方法签名”，也就是参数类型+返回值类型:

```bash
  #21 = Utf8               setValue
  #22 = Utf8               (I)V
 
  #25 = Utf8               getValue
  #26 = Utf8               ()I
```

## 运行时常量池
- 所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息。
运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。

## 字符串常量池
- 字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。
- 看一个题目：

    ```java
    String s1 = "Hello";
    String s2 = "Hello";
    String s3 = "Hel" + "lo";
    String s4 = "Hel" + new String("lo");
    String s5 = new String("Hello");
    String s7 = "H";
    String s8 = "ello";
    String s9 = s7 + s8;
     
    System.out.println(s1 == s2);  // true
    System.out.println(s1 == s3);  // true
    System.out.println(s1 == s4);  // false
    System.out.println(s1 == s9);  // false
    ```
    
### intern方法
- 如果字符串常量池里存在一个和当前字符串对象等价的字符串对象(equals==true认为相同),那么返回字符串常量池里那个对象.如果不存在,把当前字符串对象存进常量池, 返回当前字符串对象。

```java
String test1 = "abc";
String test2 = new String("abc");
String str = test2.intern();
```

![](.\pictures\intern 方法.png)

- 字符串引用str，如果直接用str=test2，那么就会如图中蓝线所示，指向不在常量池中的字符串对象

- 如果使用上面的str=test2.intern()，则会如同红线所示(因为常量池里的字符串对象和test2是等价的，intern会返回常量池里的那个

- 不在常量池中的字符串对象"str"在没有其他引用的情况下，可以进行回收，这是intern()真正的好处.

  <img src="E:\dongnaoedu\vip\JVM\pictures\字符串常量池.png" style="zoom: 50%;" />

  ![](.\pictures\字符串常量池2.png)

# 面试题
- JVM内存结构说一下？
- 什么情况下内存栈溢出？ 
- 描述new一个对象的流程！ 
- Java对象会不会分配在栈中？ 
- 如果判断一个对象是否被回收，有哪些算法，实际虚拟机使用得最多的是什么？ 
- GC收集算法有哪些？他们的特点是什么？ 
- JVM中一次完整的GC流程是怎样的？
- 对象如何晋级到老年代？ 
- Java中的几种引用关系，他们的区别是什么？ 
- final、finally、finalize的区别？ 
- String s = new String(“xxx”);创建了几个对象？